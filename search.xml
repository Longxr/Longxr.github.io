<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[印象笔记转换 markdown]]></title>
      <url>https://longxuan.ren/2024/06/16/evernote2md/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>印象笔记会员快要到期了，看着界面上各种鸡肋功能还限制登录设备，赶紧把数据迁移出来，卸载垃圾软件。 <a id="more"></a></excerpt></p>
<p><the rest of contents | 余下全文><br>以前有时候会有印象笔记网页的剪藏功能，不过实际上收藏的文章很少再去看一遍，只是在囤积电子垃圾罢了，知识还是需要自己整理归纳放到博客或者自己的笔记中才是有用的。从这个角度看，印象笔记完全就是鸡肋，markdown 支持也超弱，后续自己的笔记直接迁移到 Obsidian 。</the></p>
<h2 id="导出笔记"><a href="#导出笔记" class="headerlink" title="导出笔记"></a>导出笔记</h2><p>印象笔记默认是不支持直接导出文章为 markdown 的，需要先在印象笔记里选择所有笔记后，菜单选择导出成 enex 格式。</p>
<h2 id="笔记格式转换"><a href="#笔记格式转换" class="headerlink" title="笔记格式转换"></a>笔记格式转换</h2><p>使用 <a href="https://github.com/wormi4ok/evernote2md" target="_blank" rel="noopener">evernote2md</a> 可以将 enex 格式的文件转成 markdown 格式的文本文件，命令行如下：</p>
<pre><code class="shell">evernote2md (flags) [input] [outputDir]
</code></pre>
<p>导出后发现有 500+ 各种技术文章，完全想不起来有收集这么多，都没印象了笑死…</p>
]]></content>
      
        <categories>
            
            <category> note </category>
            
        </categories>
        
        
        <tags>
            
            <tag> evernote </tag>
            
            <tag> markdown </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python 安装 onnxruntime-gpu、paddlepaddle-gpu 报错处理]]></title>
      <url>https://longxuan.ren/2024/06/12/PythonPaddlepaddle-gpu/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>最近看到一个挂机脚本，依赖里面用到了 onnxruntime-gpu、paddlepaddle-gpu，本机环境搭建时碰到的坑做个记录。 <a id="more"></a></excerpt></p>
<p><the rest of contents | 余下全文><br><a href="https://github.com/lazydog28/mc_auto_boss" target="_blank" rel="noopener">刷声骸脚本</a>，成熟的电脑要学会自己玩游戏了。</the></p>
<h2 id="CUDA-安装"><a href="#CUDA-安装" class="headerlink" title="CUDA 安装"></a>CUDA 安装</h2><p>注意看要用到 CUDA 的库支持的版本，比如 <a href="https://onnxruntime.ai/docs/execution-providers/CUDA-ExecutionProvider.html#requirements" target="_blank" rel="noopener">onnxruntime 安装依赖</a></p>
<h3 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h3><p><a href="https://developer.nvidia.com/cuda-toolkit-archive" target="_blank" rel="noopener">CUDA 历史版本下载</a><br><a href="https://developer.nvidia.com/rdp/cudnn-archive" target="_blank" rel="noopener">cuDNN 历史版本下载</a></p>
<h3 id="CUDA-配置查看"><a href="#CUDA-配置查看" class="headerlink" title="CUDA 配置查看"></a>CUDA 配置查看</h3><p>nvidia-smi //查看显卡支持的 CUDA 版本<br>nvcc –version //查看当前安装的 CUDA 版本</p>
<h2 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h2><h3 id="onnxruntime-gpu-报错处理"><a href="#onnxruntime-gpu-报错处理" class="headerlink" title="onnxruntime-gpu 报错处理"></a>onnxruntime-gpu 报错处理</h3><h4 id="CUDA-PATH-is-set-but-CUDA-wasnt-able-to-be-loaded"><a href="#CUDA-PATH-is-set-but-CUDA-wasnt-able-to-be-loaded" class="headerlink" title="CUDA_PATH is set but CUDA wasnt able to be loaded"></a>CUDA_PATH is set but CUDA wasnt able to be loaded</h4><p>onnxruntime::python::CreateExecutionProviderInstance CUDA_PATH is set but CUDA wasnt able to be loaded. Please install the correct version of CUDA andcuDNN as mentioned in the GPU requirements page (<a href="https://onnxruntime.ai/docs/execution-providers/CUDA-ExecutionProvider.html#requirements)" target="_blank" rel="noopener">https://onnxruntime.ai/docs/execution-providers/CUDA-ExecutionProvider.html#requirements)</a>, make sure they’re in the PATH, and that your GPU is supported</p>
<p>CUDA、cuDNN、onnxruntime-gpu 版本不匹配，比如我安装时官网最新 CUDA 已经 12.5 了，但是 onnxruntime-gpu 最新版本 1.18 只支持到 CUDA 12.4, cuDNN 8.9.2.26。于是又重新去装 CUDA…cuDNN 下载解压后复制到 CUDA 所在版本目录即可。</p>
<p>另外默认 onnxruntime-gpu 是用的 CUDA 11.8，如果要用 CUDA 12.4，需要卸载默认装的再重新安装，可以参考<a href="https://onnxruntime.ai/docs/install/#install-onnx-runtime-gpu-cuda-12x" target="_blank" rel="noopener">官方安装文档</a></p>
<pre><code class="shell">pip uninstall onnxruntime-gpu
pip install onnxruntime-gpu --extra-index-url https://aiinfra.pkgs.visualstudio.com/PublicPackages/_packaging/onnxruntime-cuda-12/pypi/simple/
</code></pre>
<h4 id="Could-not-locate-zlibwapi-dll-Please-make-sure-it-is-in-your-library-path"><a href="#Could-not-locate-zlibwapi-dll-Please-make-sure-it-is-in-your-library-path" class="headerlink" title="Could not locate zlibwapi.dll. Please make sure it is in your library path!"></a>Could not locate zlibwapi.dll. Please make sure it is in your library path!</h4><p>cuDNN 8.9.x 版本需要装下 zlib，由于 CUDA bin 目录已经加到环境变量，直接把 zlib dll 放到 CUDA bin 目录下就行<br><a href="https://docs.nvidia.com/deeplearning/cudnn/archives/cudnn-892/install-guide/index.html#install-zlib-windows" target="_blank" rel="noopener">cuDNN on Windows</a></p>
<h3 id="paddlepaddle-gpu"><a href="#paddlepaddle-gpu" class="headerlink" title="paddlepaddle-gpu"></a>paddlepaddle-gpu</h3><h4 id="The-third-party-dynamic-library-cublas64-118-dll-cublas64-11-dll-that-Paddle-depends-on-is-not-configured-correctly-error-code-is-126"><a href="#The-third-party-dynamic-library-cublas64-118-dll-cublas64-11-dll-that-Paddle-depends-on-is-not-configured-correctly-error-code-is-126" class="headerlink" title="The third-party dynamic library (cublas64_118.dll;cublas64_11.dll) that Paddle depends on is not configured correctly. (error code is 126)"></a>The third-party dynamic library (cublas64_118.dll;cublas64_11.dll) that Paddle depends on is not configured correctly. (error code is 126)</h4><p>默认 paddlepaddle-gpu 和 CUDA 版本不匹配…重装。<a href="https://www.paddlepaddle.org.cn/install/quick?docurl=/documentation/docs/zh/install/pip/windows-pip.html" target="_blank" rel="noopener">paddlepaddle 安装</a></p>
<pre><code class="shell">pip uninstall paddlepaddle-gpu
pip install paddlepaddle-gpu==2.6.1.post120 -f https://www.paddlepaddle.org.cn/whl/windows/mkl/avx/stable.html
</code></pre>
<p>装好后可以检测下</p>
<pre><code class="python">import paddle
paddle.utils.run_check()
</code></pre>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> onnxruntime </tag>
            
            <tag> paddlepaddle </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python Anaconda 使用]]></title>
      <url>https://longxuan.ren/2024/05/25/PythonAnaconda/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>Anaconda 是一个开源的 Python 发行版本，用它来管理 python 环境。 <a id="more"></a></excerpt></p>
<p><the rest of contents | 余下全文><br>不同项目用到的 Python 版本不同，依赖的三方库也可能不同，如果都在默认的 Python 环境安装依赖可能会有冲突，这时候就可以用 Anaconda 针对不同的项目设置不同的 Python 版本以及下载不同版本的依赖库。</the></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官网下载安装包即可，<a href="https://docs.anaconda.com/free/miniconda/" target="_blank" rel="noopener">miniconda 下载</a></p>
<h3 id="添加镜像源"><a href="#添加镜像源" class="headerlink" title="添加镜像源"></a>添加镜像源</h3><p>如果能翻墙可以直接忽略，镜像源主要处理下载被墙的问题。</p>
<pre><code class="shell">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
conda config --set show_channel_urls yes

//更新conda，保持conda最新
conda update conda

//更新anaconda
conda update anaconda
</code></pre>
<h2 id="虚拟环境管理"><a href="#虚拟环境管理" class="headerlink" title="虚拟环境管理"></a>虚拟环境管理</h2><p>不同的 Python 环境是独立的，可以分别装不同的 Python。</p>
<pre><code class="shell">//创建虚拟环境，后面加上 anaconda 参数, 会把base的基础包一起安装
conda create -n env_name python=x.x

//列出当前所有环境，列出的环境中，当前环境前面有个*号
conda info --envs

//激活环境
conda activate env_name

//取消激活，取消激活当前环境的话，后面的环境名也可以省了
conda deactivate env_name

//删除环境
conda remove -n env_name --all

//克隆环境
conda create -n new_env_name --clone env_name

//导出环境配置，导出的配置文件会在当前目录下
conda env export &gt; environment.yml

//通过配置文件创建环境
conda env create -f environment.yml
</code></pre>
<h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><h3 id="使用-conda-管理当前环境包"><a href="#使用-conda-管理当前环境包" class="headerlink" title="使用 conda 管理当前环境包"></a>使用 conda 管理当前环境包</h3><p>包的管理是针对当前环境的，所以最好是用 Anaconda Prompt 来操作，在终端位置前可以看到当前虚拟环境名，在其他终端也可以通过<code>conda info --envs</code>来查看当前环境</p>
<pre><code class="shell">//在当前环境安装包
conda install &lt;package_name&gt;

//删除当前环境的包
conda remove &lt;package_name&gt;

//更新当前环境的包
conda update &lt;package_name&gt;

//更新当前环境所有包
conda update --all

//查看当前环境安装的包
conda list

//查找包，模糊匹配
conda search &lt;package_name&gt;

//查找包，精确查找
conda search --full-name &lt;package_name&gt;

</code></pre>
<h3 id="使用-pip-管理当前环境包"><a href="#使用-pip-管理当前环境包" class="headerlink" title="使用 pip 管理当前环境包"></a>使用 pip 管理当前环境包</h3><p>用 pip 和 conda 安装的包，都可以通过 list 命令查看到已安装包时看到，混着用貌似也没事，看了下安装路径都是<code>C:\Users\Administrator\Anaconda3\envs\&lt;env_name&gt;\Lib\site-packages</code></p>
<pre><code class="shell">//在当前环境安装包
pip install &lt;package_name&gt;

//删除当前环境的包
pip uninstall &lt;package_name&gt;

//更新当前环境的包
pip install &lt;package_name&gt; --upgrade

//更新当前环境所有包（仅供参考，我是用的conda更新所有包）
pip freeze --local | grep -v &#39;^\-e&#39; | cut -d = -f 1 | xargs -n1 pip install -U --user

//查看当前环境安装的包
pip list

</code></pre>
<h3 id="使用-conda-管理指定环境包"><a href="#使用-conda-管理指定环境包" class="headerlink" title="使用 conda 管理指定环境包"></a>使用 conda 管理指定环境包</h3><p>conda 对包的管理在不切换环境时也可以进行，只需要在对应命令后面加上对应的虚拟环境名即可</p>
<pre><code class="shell">//在指定环境安装包
conda install -n &lt;env_name&gt; &lt;package_name&gt;

//删除指定环境的包
conda remove -n &lt;env_name&gt; &lt;package_name&gt;

//更新指定环境的包
conda update -n &lt;env_name&gt; &lt;package_name&gt;

//更新指定环境所有包
conda update -n &lt;env_name&gt; --all

//查看指定环境安装的包
conda list -n &lt;env_name&gt;

</code></pre>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Anaconda </tag>
            
            <tag> conda </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[docker 常用命令]]></title>
      <url>https://longxuan.ren/2024/03/25/DockerCommand/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>记录下常用的 docker 命令 <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="底层技术支持"><a href="#底层技术支持" class="headerlink" title="底层技术支持"></a>底层技术支持</h2><ul>
<li>Namespaces: 做隔离 pid，net，ipc，mnt，uts</li>
<li>Control groups: 做资源限制</li>
<li>Union file systems: Container 和 image 的分层</li>
</ul>
<h2 id="Docker-使用"><a href="#Docker-使用" class="headerlink" title="Docker 使用"></a>Docker 使用</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><pre><code>sudo systemctl start docker                               //启动docker
docker pull ${CONTAINER NAME}                             //拉取镜像
docker images                                             //查看本地所有镜像
docker ps                                                 //查看所有正在运行的容器，加-q返回id
docker ps -a                                              //查看所有容器，加-q返回id
docker rmi ${IMAGE NAME/ID}                               //删除镜像
docker rm ${CONTAINER NAME/ID}                            //删除容器
docker save ${IMAGE NAME} &gt; ${FILE NAME}.tar              //将镜像保存成文件
docker load &lt; ${FILE NAME}.tar                            //从文件加载镜像
docker start ${CONTAINER NAME/ID}                         //运行一个以前运行过的容器
docker stop ${CONTAINER NAME/ID}                          //停止一个正在运行的容器
docker logs ${CONTAINER NAME/ID}                          //显示运行容器的日志
docker run...                                             //运行一个容器
    --name ${container name}                              //设置容器名称
    -it                                                   //启动交互式容器, 默认打开一个终端，后面还可以写终端命令，会替换Dockerfile的CMD
    -p ${host port}:${container port}                     //指定端口映射
    -P                                                    //随机端口映射，将容器暴露的端口(EXPOSE) 随机映射到宿主机的一个端口，访问宿主机端口就相当于访问容器端口
    -e ${env name}=${env value}                           //添加环境变量
    -d                                                    //后台运行，守护式容器
    -v ${host folder path}:${container folder path}       //将主机目录挂在到容器内，类似软链接文件是同步的，$(pwd)代表当前目录
</code></pre><h3 id="高级命令"><a href="#高级命令" class="headerlink" title="高级命令"></a>高级命令</h3><pre><code># Advance use
docker inspect ${CONTAINER NAME/ID}                       //查看容器信息
docker ps -f &quot;status=exited&quot;                              //显示所有退出的容器
docker ps -a -q                                           //显示所有容器id
docker ps -f &quot;status=exited&quot; -q                           //显示所有退出容器的id
docker restart $(docker ps -q)                            //重启所有正在运行的容器
docker stop $(docker ps -a -q)                            //停止所有容器
docker rm $(docker ps -aq)                                //删除所有容器
docker rm $(docker ps -f &quot;status=exited&quot; -q)              //删除所有退出的容器
docker rm $(docker stop $(docker ps -a -q))               //停止并删除所有容器
docker start $(docker ps -a -q)                           //启动所有容器
docker rmi $(docker images -a -q)                         //删除所有镜像
docker exec -it ${CONTAINER NAME/ID} /bin/bash            //进入容器内
docker exec -it ${CONTAINER NAME/ID} ping ${CONTAINER NAME/ID} //一个容器ping另外一个容器
docker exec -it ${CONTAINER NAME/ID} ip a                 //查看容器网络接口
docker top ${CONTAINER NAME/ID}                           //显示一个容器的top信息
docker stats                                              //显示容器统计信息(正在运行)
docker stats -a                                           //显示所有容器的统计信息(包括没有运行的)
docker stats -a --no-stream                               //显示所有容器的统计信息(包括没有运行的) ，只显示一次
docker stats --no-stream | sort -k8 -h                    //统计容器信息并以使用流量作为倒序
docker system
docker system df                                          //显示硬盘占用
docker system events                                      //显示容器的实时事件
docker system info                                        //显示系统信息
docker system prune                                       //清理文件，清除所有停止的容器，没有被用的nerwork等
</code></pre><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><h3 id="免除-sudo-输入"><a href="#免除-sudo-输入" class="headerlink" title="免除 sudo 输入"></a>免除 sudo 输入</h3><p>将当前用户添加到 docker 用户组，再重新打开终端即可</p>
<pre><code>sudo groupadd docker                                      //装了docker就默认创建了docker用户组了，可以不用这一步
sudo gpasswd -a longxr docker
systemctl restart docker
newgrp - docker                                           //切换会话或者重启机器
</code></pre><h3 id="交互式容器"><a href="#交互式容器" class="headerlink" title="交互式容器"></a>交互式容器</h3><h4 id="进入"><a href="#进入" class="headerlink" title="进入"></a>进入</h4><p>docker -it ${CONTAINER_NAME}</p>
<h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><ol>
<li>输入 exit 回车，容器会停止运行</li>
<li>ctrl+P+Q (大写模式)，容器不退出</li>
</ol>
<h3 id="进入守护式容器"><a href="#进入守护式容器" class="headerlink" title="进入守护式容器"></a>进入守护式容器</h3><ol>
<li>docker attach ${CONTAINER_NAME}，直接进入容器启动命令的终端，不会启动新进程</li>
<li>docker exec -it ${CONTAINER_NAME} {command}, 在容器终端打开新终端，并且可以启动新进程</li>
</ol>
<h3 id="主机与容器间的文件拷贝"><a href="#主机与容器间的文件拷贝" class="headerlink" title="主机与容器间的文件拷贝"></a>主机与容器间的文件拷贝</h3><pre><code>docker cp ${CONTAINER_NAME}:{CONTAINER_PATH} {HOST_PATH}，容器到主机
docker cp  {HOST_PATH} ${CONTAINER_NAME}:{CONTAINER_PATH}，主机到容器
</code></pre><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><h3 id="构建自己的-Docker-镜像"><a href="#构建自己的-Docker-镜像" class="headerlink" title="构建自己的 Docker 镜像"></a>构建自己的 Docker 镜像</h3><pre><code>//通过container来构建image，不推荐
docker container commit
docker image build

//通过Dockerfile生成，Dockfile在当前文件夹下，最后路径就写了个.
docker build -t longxr/centos-vim-new .
</code></pre><h3 id="Dockerfile-语法"><a href="#Dockerfile-语法" class="headerlink" title="Dockerfile 语法"></a>Dockerfile 语法</h3><pre><code>FROM scratch                                                //制作base image
FROM centos                                                 //使用 centos base image

LABEL maintainer=&quot;test@a.com&quot;                               //添加描述
LABEL version=&quot;1.0&quot;
LABEL description=&quot;This is description&quot;

WORKDIR /test                                               //设置工作目录，没有则创建，尽量用绝对目录，不要使用RUN cd
ADD hello /                                                 //添加hello文件
ADD test.tar.gz /                                           //添加文件到根目录并解压缩
WORKDIR /root
COPY hello test/                                            //将hello添加到/root/test/hello

RUN yum install wget                                        //添加远程文件使用curl、wget
RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;

ENV MYSQL_VERSION 5.6                                       //设置常量，增加可维护性
RUN apt-get install -y mysql-server=&quot;${MYSQL_VERSION}&quot; \
&amp;&amp; rm -rf /var/lib/apt/lists/*

//shell格式
RUN yum update &amp;&amp; yum install -y vim                        //执行命令并创建新的Image Layer，所以命令尽量合成一行写
CMD  echo &quot;hello docker&quot;                                    //设置容器启动后默认执行的命令和参数
ENTRYPOINT &quot;hello docker&quot;                                   //设置容器启动时运行的命令，让容器以服务的形式运行

//exec格式
RUN [&quot;apt-get&quot;, &quot;install&quot;, &quot;-y&quot;, &quot;vim&quot;]
CMD [&quot;bin/bash&quot;, &quot;-c&quot;, &quot;echo hello docker&quot;]                 //如果docker run 指定了其他命令则忽略，多个CMD只有最后的会执行
ENTRYPOINT [&quot;bin/bash&quot;, &quot;-c&quot;, &quot;echo hello docker&quot;]          //不会被忽略，一定执行

EXPOSE 5000                                                 //暴露5000端口给外部访问
</code></pre><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><pre><code>docker-compose up -d                                        //根据docker-compose.yml来创建容器、network、volume并启动，需要看日志的话就不要后台运行 (去掉-d)
                       --scale ${CONTAINER NAME}=3  //同时创建多个容器
docker-compose down                                         //停止并删除up所创建的内容（本地的image不会删除）
docker-compose  start                                       //启动容器
docker-compose stop                                         //停止容器
docker-compose ps                                           //查看当前运行的容器
docker-compose exec mysql bash                              //进入容器中

</code></pre><h2 id="docker-swarm"><a href="#docker-swarm" class="headerlink" title="docker-swarm"></a>docker-swarm</h2><h3 id="概念相关"><a href="#概念相关" class="headerlink" title="概念相关"></a>概念相关</h3><ul>
<li>node: 部署了 docker engine 的 host 实例，既可以是物理主机，也可以是虚拟主机。</li>
<li>task: 在具体某个 docker container 中执行的具体命令，是 Swarm 中的最小的调度单位。</li>
<li>service: 是指一组任务的集合，服务定义了任务的属性。</li>
<li>manager: 负责维护 docker cluster 的 docker engine，通常有多个 manager 在集群中，manager 之间通过 raft 协议进行状态同步，当然 manager 角色 engine 所在 host 也参与负载调度。</li>
<li>worker: 参与容器集群负载调度，仅用于承载 tasks。</li>
</ul>
<h3 id="集群创建"><a href="#集群创建" class="headerlink" title="集群创建"></a>集群创建</h3><p>仅做记录，平时群晖最多到 docker-compose 创建项目就够了</p>
<h4 id="本地虚拟机"><a href="#本地虚拟机" class="headerlink" title="本地虚拟机"></a>本地虚拟机</h4><pre><code>docker-machine create manger1
docker-machine create worker1
docker-machine create worker2

docker-machine ssh manger1
docker swarm --init --advertise-addr &lt;manger1-ip&gt;         // 如果是安装包装的docker，直接docker swarm --init即可
docker swarm join-token worker                            //加入worker节点需要输入的命令，在init的时候也会打印出来
docker swarm join-token manager                           //加入manager节点需要输入的命令
exit

docker-machine ssh manager2                               //添加manager
docker swarm join --token xxx                             //这里直接粘贴上面的加入manager命令
exit

docker-machine ssh manager3                               //推荐3个或5个manager节点(必须是奇数)来实现高可用。有半数以上manager可用，swarm就可以继续工作
docker swarm join --token xxx                             //这里直接粘贴上面的加入manager命令
exit

docker-machine ssh worker1                                //添加worker
docker swarm join --token xxx                             //这里直接粘贴上面的加入worker命令
exit

docker-machine ssh worker2
docker swarm join-token &lt;token&gt; &lt;ip&gt;:&lt;port&gt;
exit

docker-machine ssh manger1
docker node ls                                            //进入manager节点，可以查看集群node状态
</code></pre></the>]]></content>
      
        <categories>
            
            <category> docker </category>
            
        </categories>
        
        
        <tags>
            
            <tag> docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[NAS 域名访问和 Nginx 反代理]]></title>
      <url>https://longxuan.ren/2024/03/03/NASDomainAndNginx/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>有公网 IP 的话可以设置通过域名访问家里的 NAS，另外 NAS 上服务多了端口记不过来，可以给不同的服务设置对应的子域名 <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<p>有了 NAS 之后在家里折腾了一段时间，家里用着不错。如果想要在外面也能访问 NAS 的话，至少还要准备一个域名以及给宽带申请下公网 IP。都有了的话可以参考下述内容开搞~</p>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>域名一个，买个小众点的就行，小众的短域名 10 年也才几百块钱。<br>公网 IP，可以打电话给运营商，顺便还会上门给你光猫改桥接。</p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="DDNS"><a href="#DDNS" class="headerlink" title="DDNS"></a>DDNS</h2><p>先来完成第一个步骤，让 NAS 可以通过域名访问。当买好域名和申请了公网 IP 后，就可以在域名解析的配置里加上 IP 的记录，当访问域名时就会解析到指定的 IP 地址。但是对于普通用户来说申请到的 公网 IP 都是动态的，重启下路由器 IP 就会变，这时候就需要使用 DDNS 服务来定时的更新自己的 IP 到域名解析的记录里了。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/NASDomainAndNginx-2024-03-03-23-38-54.png" alt="NASDomainAndNginx-2024-03-03-23-38-54"></p>
<h3 id="申请-AccessKey"><a href="#申请-AccessKey" class="headerlink" title="申请 AccessKey"></a>申请 AccessKey</h3><p>由于我的域名是在阿里云买的，所以这里就用阿里提供的服务了。登录了自己的阿里云账号后点击头像，有个 AccessKey 管理，会提示你使用子账号，跳转到新界面首先根据说明创建一个子账号。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/NASDomainAndNginx-2024-03-03-23-47-49.png" alt="NASDomainAndNginx-2024-03-03-23-47-49"></p>
<p>阿里的对于每个子账号的权限都可以单独设置，比如我们这里只是用于 DNS 解析，在创建好账号后，权限管理只需要添加 AliyunDNSFullAccess 就行了。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/NASDomainAndNginx-2024-03-03-23-53-44.png" alt="NASDomainAndNginx-2024-03-03-23-53-44"></p>
<p>在账号的下方认证管理可以创建一个该账号的 AccessKey，创建好后会弹出一个弹窗，上面有 AccessKey ID 和 AccessKey Secret，以及包含这俩的 csv，记得保存好这个 csv，这个弹窗关了之后就看不到了，只能重新再创建了。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/NASDomainAndNginx-2024-03-04-00-00-00.png" alt="NASDomainAndNginx-2024-03-04-00-00-00"></p>
<h3 id="DDNS-GO-安装"><a href="#DDNS-GO-安装" class="headerlink" title="DDNS-GO 安装"></a>DDNS-GO 安装</h3><p>有群晖的话可以配置下<a href="https://spk7.imnks.com" target="_blank" rel="noopener">矿神 SDK</a> 的套件来源，配置好套件来源后，直接搜索安装好 DDNS-GO。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/NASDomainAndNginx-2024-03-04-00-02-25.png" alt="NASDomainAndNginx-2024-03-04-00-02-25"><br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/NASDomainAndNginx-2024-03-04-00-04-10.png" alt="NASDomainAndNginx-2024-03-04-00-04-10"></p>
<h3 id="脚本配置"><a href="#脚本配置" class="headerlink" title="脚本配置"></a>脚本配置</h3><p>安装好 DDNS-GO 直接运行并点击打开，就会跳转到其配置页面上，在配置页最上方选好阿里云，并填上 AccessKey ID 和 AccessKey Secret，在下方填好自己的域名并点击最下方的保存就完成了。<br><strong>这里如果你申请的域名是 <code>abc.com</code>，记得在前面加个星号，填成 <code>*.abc.com</code>，因为我们后面是要配置不同服务的子域名的。</strong><br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/NASDomainAndNginx-2024-03-04-00-08-21.png" alt="NASDomainAndNginx-2024-03-04-00-08-21"></p>
<h2 id="证书添加"><a href="#证书添加" class="headerlink" title="证书添加"></a>证书添加</h2><p>现在浏览器访问请求时，如果加了 https 是要校验 ssl 证书的，如果没有的话会提示这个网站有风险。免费证书的话可以在阿里云上申请，搜索【数字证书管理服务】。我之前申请的时候免费的能用一年，不过在写这篇文章的时候登录上去看了下，现在好像不交钱只有 3 个月了，有点坑…</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/NASDomainAndNginx-2024-03-04-00-28-57.png" alt="NASDomainAndNginx-2024-03-04-00-28-57"></p>
<p>申请好证书后把证书下载到本地，然后在 安全性里选择证书，新增并导入（第一个证书可以勾选设为默认证书）。在导入界面上选择之前下载的证书文件导入，私钥选择 xxx.key，证书选择 xxx.pem。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/NASDomainAndNginx-2024-03-04-00-35-46.png" alt="NASDomainAndNginx-2024-03-04-00-35-46"></p>
<p>导入完证书后点击设置，将你想要换成自己域名的服务都改成你自己的域名。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/NASDomainAndNginx-2024-03-04-00-44-16.png" alt="NASDomainAndNginx-2024-03-04-00-44-16"></p>
<h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><p>如果在内网想访问 NAS 上的某个服务，可以通过 <code>NAS 局域网IP:port</code> 的方式直接请求。<br>但是对于外网的访问，即使知道了当前家里的公网 IP，是不能直接访问内网 NAS 机器上的端口的，需要先做下端口转发，使得访问 <code>公网IP:port</code> 的请求能转发到 <code>NAS 局域网IP:port</code>，现在的路由器都支持该功能，在路由器的配置页设置就行。<br><strong>有的路由器有提供 DMZ 功能，这个功能是将局域网内的一个 IP 直接暴露在外网，这个挺危险的，如果有人知道了你的公网 IP 就能不断尝试访问不同的端口，建议不要使用该功能</strong></p>
<p>我们先转发个 5001 端口，浏览器输入 <code>https://域名:5001</code> 就可以看到自己的群晖登录界面。</p>
<h2 id="反代理子域名"><a href="#反代理子域名" class="headerlink" title="反代理子域名"></a>反代理子域名</h2><p>在完成了上面的内容后，就可以可以通过<code>https://域名:port</code>直接访问 NAS 的服务了，此时可以将每个 NAS 服务的端口都通过路由器转发。只是暴露端口每次都要去路由器添加，添加的时候麻烦，用起来也记不住。这时候要反代理上场了，可以只暴露一个端口，不同服务通过子域名来区分，访问连接变成 <code>https://服务名.域名:18443</code>。</p>
<h3 id="部署-Nginx-Proxy-Manager"><a href="#部署-Nginx-Proxy-Manager" class="headerlink" title="部署 Nginx Proxy Manager"></a>部署 Nginx Proxy Manager</h3><p>打开群晖的 Container Manager，注册表搜索 <code>nginx-proxy-manager</code>，下载 Star 最多的这个即可。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/NASDomainAndNginx-2024-03-04-00-56-22.png" alt="NASDomainAndNginx-2024-03-04-00-56-22"></p>
<p>创建容器指定下自己的端口号和本地路径，由于群晖的 80、443 等端口都是被 Web Station 给占用了，这里需要换成其他自定义的端口如 18080、18443。文件夹映射我的是:</p>
<ul>
<li><code>/docker/NginxProxyManger/data</code> =&gt; <code>/data</code></li>
<li><code>/docker/NginxProxyManger/letencrypt</code> =&gt; <code>//etc/letsencrypt</code></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/NASDomainAndNginx-2024-03-04-00-59-26.png" alt="NASDomainAndNginx-2024-03-04-00-59-26"></p>
<p>再勾选下容器的【启用自动重新启动】，配置好后就可以运行容器了。访问的管理端地址就是上面映射的 81 端口，比如我的管理端地址就是：<code>NAS 局域网IP:18081</code>。第一次打开这个页面时，默认用户：<a href="mailto:`admin@example.com" target="_blank" rel="noopener">`admin@example.com</a><code>，密码：</code>changeme`。首次登录后，需要修改用户名、登录邮箱以及登录密码。</p>
<h3 id="配置-Nginx-Proxy-Manager"><a href="#配置-Nginx-Proxy-Manager" class="headerlink" title="配置 Nginx Proxy Manager"></a>配置 Nginx Proxy Manager</h3><p>打开管理端页面配置好邮箱和登录密码后，可以点击 SSL Certificates -&gt; Add SSL Certificate，导入之前创建的，或者申请个新的：<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/NASDomainAndNginx-2024-03-04-01-10-45.png" alt="NASDomainAndNginx-2024-03-04-01-10-45"></p>
<p>如果是新申请如下，DDNS 的配置上面有介绍过，这里类似，就不再赘述了。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/NASDomainAndNginx-2024-03-04-01-11-41.png" alt="NASDomainAndNginx-2024-03-04-01-11-41"></p>
<p>证书添加好后就可以添加自己想要的子域名了，点击 Hosts -&gt; Add Proxy Host:<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/NASDomainAndNginx-2024-03-04-01-16-02.png" alt="NASDomainAndNginx-2024-03-04-01-16-02"></p>
<p>填好想自己想要的子域名，以及 NAS 服务的端口，比如我有个 test 功能的端口是 23333，就如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/NASDomainAndNginx-2024-03-04-01-18-06.png" alt="NASDomainAndNginx-2024-03-04-01-18-06"></p>
<p>SSL 配置页记得把所有开关都开下，证书选择上一步添加好的 SSL 证书。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/NASDomainAndNginx-2024-03-04-01-19-55.png" alt="NASDomainAndNginx-2024-03-04-01-19-55"></p>
<p>此时再把 Nginx Proxy Manager 的 https 端口 18443（创建容器时自定义的）设置好路由器的端口转发，就可以实现通过 <code>https://test.域名:18443</code> 访问 NAS 的服务了。后期有新的服务可以参考同样的形式在 Nginx Proxy Manager 配置 Proxy Host 就能实现，如：<code>https://test2.域名:18443</code></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/678250017" target="_blank" rel="noopener">群晖搭建 Nginx Proxy Manager，个人最推荐的反代工具</a></li>
<li><a href="https://blog.csdn.net/weixin_42523454/article/details/128100870" target="_blank" rel="noopener">群晖添加 SSL 证书，开启 https</a></li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> NAS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> docker </tag>
            
            <tag> NAS </tag>
            
            <tag> Nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 常用命令记录]]></title>
      <url>https://longxuan.ren/2023/07/04/LinuxCommond/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>记录常用的终端命令 <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h1 id="服务器信息"><a href="#服务器信息" class="headerlink" title="服务器信息"></a>服务器信息</h1><h2 id="内核版本"><a href="#内核版本" class="headerlink" title="内核版本"></a>内核版本</h2><p>终端显示内核命令，<code>uname -r</code></p>
<p><a href="https://www.kernel.org/" target="_blank" rel="noopener">内核发布地址</a>，主版本号、次版本号(奇数开发版、偶数稳定版)、末版本号</p>
<h2 id="发行版本"><a href="#发行版本" class="headerlink" title="发行版本"></a>发行版本</h2><p>终端显示发行版本，<code>lsb_release -a</code></p>
<ol>
<li>RedHat，技术支持收费版，软件更新慢，稳得一笔</li>
<li>Fedora，软件新，稳定性一般</li>
<li>CentOS，软件较新又稳定，小公司服务器首选</li>
<li>Ubuntu，桌面版选择</li>
<li>Debian，桌面版选择</li>
</ol>
<h1 id="软件包安装"><a href="#软件包安装" class="headerlink" title="软件包安装"></a>软件包安装</h1><h2 id="常用安装源替换"><a href="#常用安装源替换" class="headerlink" title="常用安装源替换"></a>常用安装源替换</h2><ol>
<li><a href="https://developer.aliyun.com/mirror" target="_blank" rel="noopener">阿里</a></li>
<li><a href="http://mirrors.163.com/" target="_blank" rel="noopener">网易</a></li>
<li><a href="https://mirrors.cloud.tencent.com/" target="_blank" rel="noopener">腾讯</a></li>
</ol>
<h2 id="rpm-安装"><a href="#rpm-安装" class="headerlink" title="rpm 安装"></a>rpm 安装</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>需要软件的 rpm 安装包，并且有依赖的安装包需要自己先安装依赖。<br>rpm 包格式：name-1.2.33-el7.x86_64.rpm，el7 表示 centos7、RedHat7…</p>
<h3 id="rpm-参数"><a href="#rpm-参数" class="headerlink" title="rpm 参数"></a>rpm 参数</h3><ul>
<li>-q xxx 查询软件包，-qa | more 查询所有安装的包</li>
<li>-i 安装软件包</li>
<li>-e 卸载软件包</li>
</ul>
<h2 id="yum-安装"><a href="#yum-安装" class="headerlink" title="yum 安装"></a>yum 安装</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>在线安装，安装软件时会自动处理依赖问题。</p>
<h3 id="yum-参数"><a href="#yum-参数" class="headerlink" title="yum 参数"></a>yum 参数</h3><ul>
<li>install 安装软件包</li>
<li>remove 卸载软件包</li>
<li>list | grouplist 查看软件包</li>
<li>update 升级软件包</li>
<li>yum 被锁定时，rm -f /var/run/yum.pid</li>
</ul>
<h3 id="更换-yum-源"><a href="#更换-yum-源" class="headerlink" title="更换 yum 源"></a>更换 yum 源</h3><p>去<a href="https://developer.aliyun.com/mirror" target="_blank" rel="noopener">阿里云镜像站</a> 复制替换源的命令<br>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup<br>wget -O /etc/yum.repos.d/CentOS-Base.repo <a href="http://mirrors.aliyun.com/repo/Centos-7.repo" target="_blank" rel="noopener">http://mirrors.aliyun.com/repo/Centos-7.repo</a><br>yum makecache</p>
<h2 id="源代码安装"><a href="#源代码安装" class="headerlink" title="源代码安装"></a>源代码安装</h2><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>对于一些在当前系统没有发布安装包，或是需要自己修改源码的软件，可以通过自己编译来安装。</p>
<pre><code>//下载，解压到指定xxx目录
./configure --prefix=/usr/local/xxx
make -j2
make install
</code></pre><h1 id="服务器交互"><a href="#服务器交互" class="headerlink" title="服务器交互"></a>服务器交互</h1><h2 id="centos-访问-windows-共享文件夹"><a href="#centos-访问-windows-共享文件夹" class="headerlink" title="centos 访问 windows 共享文件夹"></a>centos 访问 windows 共享文件夹</h2><pre><code>sudo mkdir /mnt/windows
sudo mount -t cifs -o username=smb,password=shared //192.168.31.31/shared /mnt/windows
cp -r /mnt/windows/test/ ./
sudo chmod -R 777 ./test
</code></pre><h2 id="centos-ssh-登录"><a href="#centos-ssh-登录" class="headerlink" title="centos ssh 登录"></a>centos ssh 登录</h2><ol>
<li>生成 ssh 密钥，ssh-keygen -t rsa -C”github 邮箱”</li>
<li>编辑.ssh/config，配置好服务器 User、host、IdentityFile</li>
<li>终端操作</li>
</ol>
<pre><code>SET REMOTEHOST=name@server-ip
scp %USERPROFILE%\.ssh\id_rsa.pub %REMOTEHOST%:~/tmp.pub
ssh %REMOTEHOST% &quot;mkdir -p ~/.ssh &amp;&amp; chmod 700 ~/.ssh &amp;&amp; cat ~/tmp.pub &gt;&gt; ~/.ssh/authorized_keys &amp;&amp; chmod 600 ~/.ssh/authorized_keys &amp;&amp; rm -f ~/tmp.pub&quot;

//上面要是连接还需要密码的话就重启下服务器ssh服务
service sshd restart
</code></pre><h2 id="vscode-remote-ssh"><a href="#vscode-remote-ssh" class="headerlink" title="vscode remote-ssh"></a>vscode remote-ssh</h2><h3 id="群晖-remote-ssh"><a href="#群晖-remote-ssh" class="headerlink" title="群晖 remote-ssh"></a>群晖 remote-ssh</h3><pre><code class="shell">cd /etc/ssh
sudo vim sshd_config
# 修改 AllowTcpForwarding: no 为 AllowTcpForwarding : yes
:wq #vim 改完保存文件
sudo synosystemctl restart sshd.service # 重启群晖 ssh 服务
</code></pre>
<h3 id="centos-下载报错"><a href="#centos-下载报错" class="headerlink" title="centos 下载报错"></a>centos 下载报错</h3><p>连接如果出现错误，错误日志为 wget 下载失败，在上面应该有一串哈希值的 commit-id，对应 vscode 某个 release 版本。直接用本地电脑访问  <a href="https://update.code.visualstudio.com/commit" target="_blank" rel="noopener">https://update.code.visualstudio.com/commit</a>:<commit-id>/server-linux-x64/stable<br>下载后将<code>vscode-server-linux-x64.tar.gz</code>文件解压到<code>~/.vscode-server/bin/&lt;commit-id&gt;</code>，<br>scp vscode-server-linux-x64.tar.gz user@ip:/home/longxr/.vscode-server/bin/<commit-id>/<br>tar zxf vscode-server-linux-x64.tar.gz -C .</commit-id></commit-id></p>
<h3 id="centos-登录出错"><a href="#centos-登录出错" class="headerlink" title="centos 登录出错"></a>centos 登录出错</h3><ol>
<li>换机器登录服务器可能导致服务端装了不同的 vscode-server 导致不断重连让选择平台，可以先用 xshell 登录删除相关目录：<code>sudo rm -rf /home/longxr/.vscode-server</code></li>
<li>连接失败提示命名管道不存在，删除本机 ssh 目录下的<code>known_hosts</code>文件</li>
</ol>
<h1 id="常用目录"><a href="#常用目录" class="headerlink" title="常用目录"></a>常用目录</h1><ul>
<li>/ 根目录</li>
<li>/bin 命令保存目录（普通用户权限）</li>
<li>/sbin 命令保存目录（root 权限）</li>
<li>/boot 启动目录，包含启动相关文件，和开机有关</li>
<li>/dev 设备文件保存目录</li>
<li>/etc 配置文件保存目录，类似 windows 注册表</li>
<li>/home 普通用户家目录</li>
<li>/lib 系统库保存目录</li>
<li>/mnt 系统挂载目录</li>
<li>/media 挂载目录（常用于光盘挂载）</li>
<li>/root 超级用户家目录</li>
<li>/tmp 临时目录</li>
<li>/proc 直接写入内存的</li>
<li>/sys 直接写入内存的</li>
<li>/usr 系统软件资源目录</li>
<li>/var 系统相关文档内容</li>
</ul>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><pre><code>//查看目录下内容
ls -l            //长格式显示文件，-lh以便于人识别的方式显示（文件大小），-lhS列表按照文件由大到小显示
ls -a           //显示隐藏文件
ls -r           //逆序显示
ls -t           //按时间顺序显示
ls -R           //递归显示，可以查看多级目录

//切换目录
cd floder
cd ./floder

//新建目录
mkdir a b c
mkdir -p a/b/c  //新建多级目录

//删除
rmdir a         //只能删除空目录
rm -rf           //删除非空目录
rm -rf /*       //删库跑路

//复制
cp  /src /dst       //复制文件
cp -r /src /dst     //复制目录
cp -v /src /dst     //终端显示从源到目标的箭头
cp -p /src /dst     //复制并保留文件用户、时间、权限
cp -a /src /dst     //复制并保留文件所有属性，等于-dpR
cp -Rf /src/*   /dst/   //将src目录下的所有东西拷到temp下而不拷贝src目录本身

//移动
mv /src /dst        //重命名、改名

//修改目录下所有文件权限
sudo chmod -R 777 /test
//修改目录下所有文件所属用户
sudo chown -R myuser /path/to/folder

//查看文本文件
cat a.txt             //查看文件内容
head -5 a.txt       //查看文件前5行
tail -5 a.txt        //查看文件末尾5行
wc -l a.txt         //输出文件行数
cat app.log | grep -30 ‘keyword’ //查询关键字前后30行

//打包压缩
tar cf test.tar src/          //只打包，大
tar czf test.tar.gz src/      //gzip压缩，快
tar cjf test.tar.bz2 src/     //bzip2压缩，慢
zip -r test.zip src/          //zip压缩

//解压缩
tar xf test.tar -C dst/        //tar解包
tar zxf test.tar.gz -C dst/   //gzip解包，.tgz同
tar jxf test.tar.bz2 -C dst/  //bzip2解包，.tbz2同
unzip -o test.zip -d dst/                  //uzip解压缩
</code></pre><h2 id="特殊技巧"><a href="#特殊技巧" class="headerlink" title="特殊技巧"></a>特殊技巧</h2><pre><code>//权限被据绝的时候，会将上一条命令加上sudo输出
sudo!!

//切换应用到后台
Ctrl+Z  //暂停应用程序
...        //处理其他事情
fg      //切换到之前的应用

//ssh登出后仍然运行命令
nohup wget http://xxxx
</code></pre><h2 id="命令行软件"><a href="#命令行软件" class="headerlink" title="命令行软件"></a>命令行软件</h2><ul>
<li>htop 进程管理</li>
<li>range 文件浏览器</li>
</ul>
<h1 id="配置文件-etc"><a href="#配置文件-etc" class="headerlink" title="配置文件/etc"></a>配置文件/etc</h1><p>/etc/passwd   　　用户数据库，每列的内容分别是用户名、是否需要密码、uid、组 id、家目录、登录的命令解释器（sbin/nologin 表示不能登录）<br>/etc/group   　　 组数据，每列的内容分别是组名、是否需要密码、组 id、组员</p>
<h2 id="给普通用户管理员权限"><a href="#给普通用户管理员权限" class="headerlink" title="给普通用户管理员权限"></a>给普通用户管理员权限</h2><pre><code>su root
visudo          //vim /etc/sudoers

//找到root All=(ALL) ALL 这一行
按yy复制行，回车按p粘贴行
命令模式 :wq!保存
</code></pre><h2 id="sudo-命令输入一次后，不关闭终端无需再输入密码"><a href="#sudo-命令输入一次后，不关闭终端无需再输入密码" class="headerlink" title="sudo 命令输入一次后，不关闭终端无需再输入密码"></a>sudo 命令输入一次后，不关闭终端无需再输入密码</h2><pre><code>sudo vim /etc/sudoers
//找到Defaults env_reset，改成下面的：
Defaults env_reset , timestamp_timeout=-1
</code></pre><h1 id="文件权限-root-用户不受限制"><a href="#文件权限-root-用户不受限制" class="headerlink" title="文件权限(root 用户不受限制)"></a>文件权限(root 用户不受限制)</h1><p>目录：r 是可查看文件，w 是修改文件，x 是进入文件夹<br>用户和组权限不同时，以用户权限为准<br>chmod u g o a +/-/= r/w/x，给用户、组、其他用户添加、删除、设置权限<br>chmod 744 设置权限，r 代表 4，w 代表 2，x 代表 1，相加设置一个用户权限</p>
<h2 id="boot-空间不足"><a href="#boot-空间不足" class="headerlink" title="boot 空间不足"></a>boot 空间不足</h2><p>一般是系统升级了之后，旧的内核文件还在，多了就满了。可以删除不需要的旧内核文件。</p>
<pre><code>su
uname -r                                             //查看当前内核版本
rpm -q kernel                                       //列出所有内核文件
rpm -e kernel-3.10.0-957.el7.x86_64          //删除旧版本
yum remove kernel-3.10.0-957.el7.x86_64   //移除旧版本的相关包
df -lh                                                  //查看磁盘占用
</code></pre><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="网卡名称"><a href="#网卡名称" class="headerlink" title="网卡名称"></a>网卡名称</h2><ul>
<li>eno1 板载网卡</li>
<li>ens33 PCI-E 网卡</li>
<li>enp0s3 无法获取物理信息的 PCI-E 网卡</li>
<li>eth0 以上都不匹配</li>
</ul>
<h3 id="网卡显示-eth0-的方法"><a href="#网卡显示-eth0-的方法" class="headerlink" title="网卡显示 eth0 的方法"></a>网卡显示 eth0 的方法</h3><p>修改/etc/default/grub，swap rhgb quiet 后面增加 biosdevname=0 net.ifnames=0<br>grub2-mkconfig -o /boot/grub2/grub.cfg<br>reboot</p>
<h2 id="网络相关命令"><a href="#网络相关命令" class="headerlink" title="网络相关命令"></a>网络相关命令</h2><pre><code>//修改ip地址
ifconfig eth0 &lt;ip&gt; netmask 255.255.255.0
//重启网卡（改ip要重启网卡才生效）
systemctl restart network


//查看防火墙所有开放的端口
firewall-cmd --zone=public --list-ports
//端口开关
firewall-cmd --zone=public --add-port=3306/tcp --permanent   // 开放3306端口
firewall-cmd --zone=public --remove-port=3306/tcp --permanent  //关闭3306端口
firewall-cmd --reload   // 配置立即生效

//查看网络连接状态
mii-tool eth0   //虚拟机看不了

//网络故障排除
ping &lt;ip&gt;
traceroute -w 1 //查看路由跳转，查询丢包原因，更详细可以使用mtr看
nslookup www.baidu.com  //查看域名对应的ip
telnet &lt;ip&gt; &lt;port&gt;  //查看服务端口是否启用
tcpdump -i any -n host &lt;ip&gt; -w /tmp/filename //捕获对应ip的tcp数据包
</code></pre><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h2><pre><code>ps                          //查看当前运行的进程
ps -e | more            //查看所有进程
ps -ef | grep xxx        //查找xxx进程，加了f参数第三列显示父进程ID
pstree | more           //树状显示进程
top                        //查看进程详细运行状态，类似windows资源管理器
kill -s 9 &lt;pid&gt;         //根据pid杀进程
</code></pre></the>]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux command </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 3.5.0 迁移到 Github Action 踩坑记录]]></title>
      <url>https://longxuan.ren/2023/05/22/HexoGithubAction/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>忘记写博客两年半，域名续费才想起来博客的存在哈哈哈哈，顺便吐槽下 Hexo 官方文档都不维护更新下内容坑啊 <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<p>在我昨天玩游戏心血来潮又想写点东西的时候，Clone 下来久违的博客仓库，提交完文章后，发现博客完全不更新的，这个时候就发现事情并不简单 Σ(っ °Д °;)っ</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/HexoGithubAction-2023-05-22-23-41-06.png" alt="HexoGithubAction-2023-05-22-23-41-06"></p>
<p>登录 travis-ci 一看，最近一次成功的自动构建记录都是 2 年 前的事情了，上方一行红色文字提示我信用额度为负，好家伙。。。许久不见，travis-ci 的构建已经变成收费功能了。莫得法子，只能换一家白嫖了，正好 Github 也有 Github Action 是可以用于自动构建的，于是挥泪告别 travis-ci (哭了，我装的(￣ ▽ ￣)”)</p>
<h1 id="workflows"><a href="#workflows" class="headerlink" title="workflows"></a>workflows</h1><p>网上看了一圈教程，workflows 写法五花八门，有用 SSH key 的，有用 GitHub Token 的，最后还是决定按照官方文档来了，<a href="https://hexo.io/zh-cn/docs/github-pages" target="_blank" rel="noopener">相关链接戳这里</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/HexoGithubAction-2023-05-22-23-50-33.png" alt="HexoGithubAction-2023-05-22-23-50-33"></p>
<h1 id="踩坑处理"><a href="#踩坑处理" class="headerlink" title="踩坑处理"></a>踩坑处理</h1><p>提交 <code>.github/workflows/pages.yml</code> 后，自动触发构建，发现 Action 报错:</p>
<h2 id="Invalid-workflow-file-github-workflows-pages-yml-L2"><a href="#Invalid-workflow-file-github-workflows-pages-yml-L2" class="headerlink" title="Invalid workflow file: .github/workflows/pages.yml#L2"></a>Invalid workflow file: .github/workflows/pages.yml#L2</h2><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/HexoGithubAction-2023-05-22-23-59-02.png" alt="HexoGithubAction-2023-05-22-23-59-02"></p>
<p>定睛一看，啊这…原来第一行是注释么，怎么不加 <strong>#号</strong>的，复制粘贴害人呀，改完又报错:</p>
<h2 id="Node-js-12-actions-are-deprecated-Please-update-the-following-actions-to-use-Node-js-16-actions-checkout-v2-actions-setup-node-v2-actions-cache-v2"><a href="#Node-js-12-actions-are-deprecated-Please-update-the-following-actions-to-use-Node-js-16-actions-checkout-v2-actions-setup-node-v2-actions-cache-v2" class="headerlink" title="Node.js 12 actions are deprecated. Please update the following actions to use Node.js 16: actions/checkout@v2, actions/setup-node@v2, actions/cache@v2"></a>Node.js 12 actions are deprecated. Please update the following actions to use Node.js 16: actions/checkout@v2, actions/setup-node@v2, actions/cache@v2</h2><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/HexoGithubAction-2023-05-23-00-04-41.png" alt="HexoGithubAction-2023-05-23-00-04-41"><br>搜索了下报错，找到相关 <a href="https://github.com/actions/checkout/issues/1047" target="_blank" rel="noopener">issue</a>, 看着意思是需要把文档中的 <code>actions/checkout@v2</code> 改成 <code>actions/checkout@v3</code>，<code>actions/setup-node@v2</code>、<code>actions/cache@v2</code> 也是同理。不过感觉以后可能还有升级…可以跳到仓库的主页看看目前最新的是哪个版本，比如 <a href="https://github.com/actions/checkout" target="_blank" rel="noopener">actions/checkout</a>:</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/HexoGithubAction-2023-05-23-00-07-55.png" alt="HexoGithubAction-2023-05-23-00-07-55"></p>
<p>改好提交，改完继续报错…</p>
<h2 id="npm-ERR-Missing-script-“build”"><a href="#npm-ERR-Missing-script-“build”" class="headerlink" title="npm ERR! Missing script: “build”"></a>npm ERR! Missing script: “build”</h2><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/HexoGithubAction-2023-05-23-00-10-42.png" alt="HexoGithubAction-2023-05-23-00-10-42"></p>
<p>我寻思我也没改过 npm 的配置，咋就报错了。于是又在本地初始化一个新的 Hexo 仓库对比下，看下有何不同之处，对比发现 <code>package.json</code> 确实不一样，新版除了依赖模块还加了 <code>scripts</code> 部分</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/HexoGithubAction-2023-05-23-00-25-55.png" alt="HexoGithubAction-2023-05-23-00-25-55"></p>
<p>加上 <code>scripts</code> 部分后构建不会报错了，但是构建完成 push 到仓库后，网站全白啥也没有，查看仓库文件 html 全是 0 kb，我文章跑哪去了 ？？</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/HexoGithubAction-2023-05-23-00-31-17.png" alt="HexoGithubAction-2023-05-23-00-31-17"></p>
<h2 id="生成-html-为空"><a href="#生成-html-为空" class="headerlink" title="生成 html 为空"></a>生成 html 为空</h2><p>搜索一番发现，其他人也碰到了这个问题，是由于 <strong>node 版本太高了，hexo 还不支持</strong><br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/HexoGithubAction-2023-05-23-00-34-45.png" alt="HexoGithubAction-2023-05-23-00-34-45"></p>
<p>将 <code>.github/workflows/pages.yml</code> 中的 node 版本改回 12 后，再次构建，我的博客终于又回来了</p>
<h1 id="github-workflows-pages-yml"><a href="#github-workflows-pages-yml" class="headerlink" title=".github/workflows/pages.yml"></a>.github/workflows/pages.yml</h1><p>附上修改后的配置文件，方便其他有需要升级老版本 Hexo 的朋友</p>
<pre><code class="yml">name: Pages

on:
  push:
    branches:
      - blog # 源码所在分支

jobs:
  pages:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v3 # 有报错的话可能需要升级到最新的脚本
      - name: Use Node.js 12.x
        uses: actions/setup-node@v3
        with:
          node-version: &#39;12&#39; # 改为 Hexo 所需的 node 版本
      - name: Cache NPM dependencies
        uses: actions/cache@v3
        with:
          path: node_modules
          key: ${{ runner.OS }}-npm-cache
          restore-keys: |
            ${{ runner.OS }}-npm-cache
      - name: Install Dependencies
        run: npm install
      - name: Build
        run: npm run build # 检查 package.json 中是否有相关的 scripts
      - name: Deploy
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./public
</code></pre>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://hexo.io/zh-cn/docs/github-pages" target="_blank" rel="noopener">在 GitHub Pages 上部署 Hexo</a></li>
<li><a href="https://alanlee.fun/2021/02/28/hexo-empty-html/" target="_blank" rel="noopener">hexo 生成的 html 文件为空的问题</a></li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> workflows </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PS5 远程玩游戏]]></title>
      <url>https://longxuan.ren/2023/05/21/Game_PS5_Remote_Play/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>解决下回家躺床上 PS5 吃灰的问题，在公司远程玩 PS5 <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<p>下班回家觉得游戏索然无味，中午在公司又有点无聊，懒得把机器搬到公司去的话，可以试试 PS 的 remote play 功能 (也适用于电视被抢的情况 23333)</p>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>PS5 主机一台<br>公网 ip，可以打电话给运营商，顺便还会上门给你光猫改桥接。</p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><p>首先是为了让公司的网络也能访问到家里的 PS5，需要将 remote play 涉及到的端口从路由器转发出去。直接路由器转发端口就可以的前提是你是公网的 ip，并且光猫是桥接模式用的路由器拨号上网。如果路由器没有公网 ip 的话，还要折腾下内网穿透、frp 这些，可以自行搜索处理<br>PS5 remote play 涉及到的端口有:</p>
<ul>
<li>TCP/UDP: 987 (for remote wakeup)</li>
<li>TCP/UDP: 9295, 9296, 9297, 9303, 9304 (for connection handshake, streaming, and other behavior)</li>
</ul>
<p>是在 <a href="https://www.reddit.com/r/PS5/comments/kx8mhy/remote_play_from_internet_firewall_ports/" target="_blank" rel="noopener">reddit 找到的端口信息</a>，当然也可以使用路由器的 DMZ 主机直接暴露 PS5 的 ip，但是感觉不安全，还是就转发下端口了</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Game_PS5_remote_play-2023-05-21-19-12-11.png" alt="Game_PS5_remote_play-2023-05-21-19-12-11"></p>
<h2 id="PS5-设定"><a href="#PS5-设定" class="headerlink" title="PS5 设定"></a>PS5 设定</h2><p>PS5 设定比较简单，就是开启下远程游玩的功能，为了方便截图我直接截图 remote play 的窗口了（在家里的 PC 远程到公司的 PC 上，开启 remote play 远程到家里的 PS5 上截图，感觉好蠢哈哈哈哈）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Game_PS5_remote_play-2023-05-21-19-30-12.png" alt="Game_PS5_remote_play-2023-05-21-19-30-12"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Game_PS5_remote_play-2023-05-21-19-30-44.png" alt="Game_PS5_remote_play-2023-05-21-19-30-44"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Game_PS5_remote_play-2023-05-21-19-31-11.png" alt="Game_PS5_remote_play-2023-05-21-19-31-11"></p>
<h2 id="remote-play-安装"><a href="#remote-play-安装" class="headerlink" title="remote play 安装"></a>remote play 安装</h2><p>直接去索尼官网下载就行了，<a href="https://remoteplay.dl.playstation.net/remoteplay/lang/en/ps5_win.html" target="_blank" rel="noopener">下载链接戳这里</a><br>安装好后需要先登录索尼账号，登录好之后就会搜索你账号下的 PS5 主机</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Game_PS5_remote_play-2023-05-21-19-37-12.png" alt="Game_PS5_remote_play-2023-05-21-19-37-12"></p>
<p>搜索到机器后选择你要连接的 PS5 主机，就可以看到画面了</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Game_PS5_remote_play-2023-05-21-19-40-11.png" alt="Game_PS5_remote_play-2023-05-21-19-40-11"></p>
<p>当然 remote play 也不止 PC 可以用，iOS、Android 也有对应的客户端可以用来远程</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://www.reddit.com/r/PS5/comments/kx8mhy/remote_play_from_internet_firewall_ports/" target="_blank" rel="noopener">Remote Play from Internet Firewall Ports</a></li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> Game </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PS5 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[windows平台编译CEF支持MP3、MP4]]></title>
      <url>https://longxuan.ren/2021/07/24/CEF-Build-On-Windows/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>CEF默认不支持mp3、mp4，需要的话得自己编译，记录在window下编译过程中遇到的各种坑 <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="CEF基础版"><a href="#CEF基础版" class="headerlink" title="CEF基础版"></a>CEF基础版</h2><p>如果不需要mp3、mp4的支持，可以直接下载构建好的版本，下载链接<a href="https://cef-builds.spotifycdn.com/index.html" target="_blank" rel="noopener">戳这里</a>。<br>新版本是cef和chromium在一个压缩包里，老版本是分开的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/CEF-Build-On-Windows-2021-07-24-22-31-09.png" alt="CEF-Build-On-Windows-2021-07-24-22-31-09"></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>google的项目，都要配置好代理，想直接下是不行的。找个路径放相关的文件，比如<code>E:\cef</code>。</p>
<h3 id="时区设置"><a href="#时区设置" class="headerlink" title="时区设置"></a>时区设置</h3><p>设置系统区域为英语（美国）。（控制面板-区域-管理-更改系统区域设置-英语（美国）），设置完需要重启。防止编译一些字符集的报错。</p>
<h3 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h3><p>不知道是啥的话后面也不用搞了，不过就算设置了也还是慢，最好还是云服务器编译。</p>
<h4 id="V2ray代理设置"><a href="#V2ray代理设置" class="headerlink" title="V2ray代理设置"></a>V2ray代理设置</h4><ol>
<li>路由设置-&gt;勾选启用高级功能</li>
<li>右下角小图标选择全局</li>
</ol>
<h4 id="git-clone-代理配置"><a href="#git-clone-代理配置" class="headerlink" title="git clone 代理配置"></a>git clone 代理配置</h4><pre><code class="bash">//加大buffer
git config --global http.postBuffer 524288000

//设置代理，ssr通常是1080，v2ray是10809，客户端底部有显示
git config --global http.proxy http://127.0.0.1:10809 &amp;&amp; git config --global https.proxy https://127.0.0.1:10809

//取消代理（上面端口设置错了的话）
git config --global --unset http.proxy &amp;&amp; git config --global --unset https.proxy
</code></pre>
<h4 id="windows设置CMD代理"><a href="#windows设置CMD代理" class="headerlink" title="windows设置CMD代理"></a>windows设置CMD代理</h4><pre><code class="bash">netsh
netsh&gt;winhttp
netsh winhttp&gt;
netsh winhttp&gt;set proxy 127.0.0.1:10809      //设置代理
netsh winhttp&gt;show proxy                     //查看代理
netsh winhttp&gt;reset proxy                    //重置代理，下载完了不想要代理才用
</code></pre>
<h4 id="设置Boto代理"><a href="#设置Boto代理" class="headerlink" title="设置Boto代理"></a>设置Boto代理</h4><pre><code>[Boto]
proxy = 127.0.0.1
proxy_port = 10809
</code></pre><p>创建.boto文件，在命令行设置环境变量，<code>set NO_AUTH_BOTO_CONFIG=E:\cef\.boto</code></p>
<h3 id="构建脚本"><a href="#构建脚本" class="headerlink" title="构建脚本"></a>构建脚本</h3><p>构建脚本会执行下载和编译，通过指定参数达到想要的编译效果，<a href="https://bitbucket.org/chromiumembedded/cef/raw/master/tools/automate/automate-git.py" target="_blank" rel="noopener">下载链接</a>。下载好后放到<code>E:\cef</code>目录下。这是个python脚本，python也需要装下，编译旧版本需要安装python2，新版本需要安装python3，在执行脚本的时候环境不对会给出提示。</p>
<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><p>automate-git.py 的参数可以手动执行 python automate-git.py –help 来查看，下面列举大部分情况都会用的。</p>
<ul>
<li>–branch 表示你要下载和编译哪个版本的代码，Chromium和CEF的版本对应关系<a href="https://bitbucket.org/chromiumembedded/cef/wiki/BranchesAndBuilding.md#markdown-header-automated-method" target="_blank" rel="noopener">可以看这个链接</a></li>
<li>–no-build 表示只下载代码而不编译</li>
<li>–no-distrib 不执行打包项目，这里只为下载代码，我们还要修改支持多媒体的参数，所以不进行打包</li>
<li>–force-clean 如果你曾经执行过这个脚本，可能会出错，则加上这个参数，它执行清理残留文件（你也可以手动在 chromium 源码目录执行 git clean -xdf 来清理目录中的多余内容）。</li>
<li>–download-dir 下载的源码目录</li>
<li>–checkout 如果你不想编译某个分支的最新版代码，可以指定具体的提交，只用设置CEF的提交就行，Chromium会跟着切换</li>
<li>–force-clean-deps 编译老版本的时候会碰到下载第三方依赖库失败，碰到了可以加下这个</li>
<li>–no-depot-tools-update 如果工具包之前下载过了可以加上，就不升级工具包了，第一次下载不加</li>
<li>–no-update 编译时用，不更新直接编译</li>
<li>–no-debug-build 编译时用，不编译debug只要release</li>
<li>–build-log-file 生成编译的日志文件，出错可以看下</li>
<li>–x64-build 构建64位的版本 </li>
</ul>
<p>准备好后目录如下：<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/CEF-Build-On-Windows-2021-07-24-22-53-01.png" alt="CEF-Build-On-Windows-2021-07-24-22-53-01"></p>
<h2 id="CEF源码下载"><a href="#CEF源码下载" class="headerlink" title="CEF源码下载"></a>CEF源码下载</h2><p>下载前需要设置下环境变量，也可以直接在命令行输入就行。</p>
<pre><code class="bat">set CEF_USE_GN=1
set GN_DEFINES=is_official_build=true
set GYP_DEFINES=buildtype=Official
set GYP_MSVS_VERSION=2017
set CEF_ARCHIVE_FORMAT=tar.bz2

@REM 第一次源码下载不加--no-depot-tools-update，会先包工具包下下来
python automate-git.py --download-dir=e:\cef\source --branch=3626 --checkout=90eb8cc --no-build --no-distrib --force-clean --force-clean-deps --no-depot-tools-update 
</code></pre>
<p><strong>有一个注意点，depot-tools内部有一些bat和python脚本，需要把它的路径设置到环境变量的PATH里，不然下载会报错</strong></p>
<h3 id="下载错误处理"><a href="#下载错误处理" class="headerlink" title="下载错误处理"></a>下载错误处理</h3><h4 id="python缺库"><a href="#python缺库" class="headerlink" title="python缺库"></a>python缺库</h4><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/CEF-Build-On-Windows-2021-07-24-23-19-10.png" alt="CEF-Build-On-Windows-2021-07-24-23-19-10"><br>看到脚本自己去下了python库的.whl，但是安装没成功，我就手动装了下：</p>
<pre><code class="bash">pip install numpy=1.12.1
pip install opencv_python=3.2.0.7
pip install psutil=5.2.2
</code></pre>
<h3 id="No-module-named-win32file"><a href="#No-module-named-win32file" class="headerlink" title="No module named win32file"></a>No module named win32file</h3><p>Traceback (most recent call last):<br>  File “../../build/toolchain/win/tool_wrapper.py”, line 29, in <module><br>    import win32file    # pylint: disable=import-error<br>ImportError: No module named win32file</module></p>
<p>修改方法：在错误日志里指定的目录安装pywin32，<a href="https://magpcss.org/ceforum/viewtopic.php?f=6&amp;t=17258" target="_blank" rel="noopener">参考链接</a></p>
<pre><code class="bash">cd E:\cef\source\depot_tools\bootstrap-2@3_8_10_chromium_20_bin\python\bin
pip -m install pywin32
</code></pre>
<h4 id="提示subprocesss返回值非0"><a href="#提示subprocesss返回值非0" class="headerlink" title="提示subprocesss返回值非0"></a>提示subprocesss返回值非0</h4><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/CEF-Build-On-Windows-2021-07-24-23-23-12.png" alt="CEF-Build-On-Windows-2021-07-24-23-23-12"></p>
<p>把depot-tools的路径设置到环境变量的PATH里:</p>
<pre><code class="bat">set PATH=E:\cef\source\depot_tools;%PATH%;
</code></pre>
<h4 id="AttributeError-‘module’-object-has-no-attribute-‘CheckCallAndFilterAndHeader’"><a href="#AttributeError-‘module’-object-has-no-attribute-‘CheckCallAndFilterAndHeader’" class="headerlink" title="AttributeError: ‘module’ object has no attribute ‘CheckCallAndFilterAndHeader’"></a>AttributeError: ‘module’ object has no attribute ‘CheckCallAndFilterAndHeader’</h4><p>老版本编译才有的问题，需要修改代码，<code>E:\cef\source\cef\tools\gclient_util.py</code>，<a href="https://bitbucket.org/chromiumembedded/cef/issues/2736/gclient_hookpy-fails-because-of-missing" target="_blank" rel="noopener">参考链接</a></p>
<p>命令行出问题的话，脚本就给个提示返回值非0，没把错误打印出来就很坑…把显示的命令行在终端直接敲一下就能看到具体错误了。<br>踩完这一路的坑，就可以开始编译了…</p>
<h3 id="CEF源码编译"><a href="#CEF源码编译" class="headerlink" title="CEF源码编译"></a>CEF源码编译</h3><p>编译需要设置的参数最重要的就是添加MP3、MP4支持 使用此条指令，不加白折腾了。还有就是指定VS的路径，编译报错了提示少什么路径可以再加。</p>
<pre><code class="bat">set CEF_USE_GN=1
set GN_DEFINES=is_official_build=true
set GYP_DEFINES=buildtype=Official
set GYP_MSVS_VERSION=2017
set CEF_ARCHIVE_FORMAT=tar.bz2
@REM 添加MP3、MP4支持 使用此条指令
set GN_DEFINES=is_official_build=true proprietary_codecs=true ffmpeg_branding=Chrome

set GYP_GENERATORS=ninja,msvs-ninja
set GN_ARGUMENTS=--ide=vs2017 --sln=cef --filters=//cef/*
@REM VS2017安装在默认目录，但任然需要下面设置，可能是由于VS2015和VS2017同时安装，路径根据自己的安装目录和版本确定
set WIN_CUSTOM_TOOLCHAIN=1
set CEF_VCVARS=none
set GYP_MSVS_OVERRIDE_PATH=C:\Program Files (x86)\Microsoft Visual Studio\2017\Community
set SDK_ROOT=C:\Program Files (x86)\Windows Kits\10

@REM 编译64位调用VS的脚本有问题，环境变量还是去找的32位路径，下面改手动设置路径
@REM call &quot;C:/Program Files (x86)/Microsoft Visual Studio/2017/Community/VC/Auxiliary/Build/vcvarsall.bat&quot; x64

@REM set INCLUDE=C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\um;C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt;C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\shared;C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\include;C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\atlmfc\include;%INCLUDE%
@REM set PATH=C:\Program Files (x86)\Windows Kits\10\bin\10.0.17763.0\x86;C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\bin\HostX64\x86;C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\bin\HostX64\x64;C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Redist\MSVC\14.16.27012\x64\Microsoft.VC141.CRT;%PATH%
@REM set LIB=C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\um\x86;C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\ucrt\x86;C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\lib\x86;C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\atlmfc\lib\x86;%LIB%
@REM set VS_CRT_ROOT=C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\crt

set INCLUDE=C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\um;C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt;C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\shared;C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\include;C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\atlmfc\include;%INCLUDE%
set LIB=C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\um\x64;C:\Program Files (x86)\Windows Kits\10\Lib\10.0.17763.0\ucrt\x64;C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\lib\x64;C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\atlmfc\lib\x64;%LIB%
set VS_CRT_ROOT=C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\crt
set PATH=C:\Program Files (x86)\Windows Kits\10\bin\10.0.17763.0\x64;C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\bin\HostX64\x64;C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\bin\HostX64\x64;C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Redist\MSVC\14.16.27012\x64\Microsoft.VC141.CRT;%PATH%

python automate-git.py --download-dir=e:\cef\source --branch=3626 --checkout=90eb8cc --no-update --no-debug-build --build-log-file --verbose-build --force-distrib --force-build --x64-build
</code></pre>
<h3 id="输出文件"><a href="#输出文件" class="headerlink" title="输出文件"></a>输出文件</h3><p>在目录<code>E:\cef\source\chromium\src\cef\binary_distrib</code>下，还把压缩包也生成了。<br>生成的文件里没有libcef_dll_wrapper.lib，需要的话拿cmake生成一个vs工程再编译就行，什么配置都不用改，就略过了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/CEF-Build-On-Windows-2021-07-25-00-22-37.png" alt="CEF-Build-On-Windows-2021-07-25-00-22-37"></p>
<h2 id="编后感"><a href="#编后感" class="headerlink" title="编后感"></a>编后感</h2><p>下载和编译环节一定要把参数都搞好，下载搞了2天，编译也搞了2天，心累…一开始直接编译了一个32位的，后面才反应过来要编译一个64位的，编译的时候CPU直接100%，其他活都不用干了。<br>等搞完发现指定分支提交和项目中使用的版本还不一样，又要重新checkout再编译Orz<br>最后发现还是搞个windows云服务器省事，环境直接选美国，代理也不用设置，我本地代理也只能3M/S，服务器下载30M/S，服务器编译还不影响本地工作(￣▽￣)”</p>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><ul>
<li><a href="https://bitbucket.org/chromiumembedded/cef/wiki/AutomatedBuildSetup.md" target="_blank" rel="noopener">官方构建Wiki</a></li>
<li><a href="https://bitbucket.org/chromiumembedded/cef/wiki/BranchesAndBuilding.md#markdown-header-automated-method" target="_blank" rel="noopener">CEF版本号对应关系</a></li>
<li><a href="https://blog.csdn.net/baidu_32237719/article/details/79509819" target="_blank" rel="noopener">在Windows上编译 CEF3 且加入mp3/mp4的支持</a></li>
<li><a href="https://blog.csdn.net/pnhuangyu/article/details/103191466/" target="_blank" rel="noopener">CEF学习（一）：下载和构建chromium，增加mp4等多媒体支持</a></li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> CEF </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
            <tag> CEF </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt5.12.5 静态编译以及裁剪大小对比]]></title>
      <url>https://longxuan.ren/2020/07/11/Qt5-12-5-static-build/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>使用 VS2019 静态编译 Qt5.12.5 源码，并记录不同配置裁剪后生成的程序大小 <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<p>最近在研究用静态编译的 Qt 做个 Qt 的安装包程序，因为 nsis 在界面自定义还有多语言适配等问题上不太理想。做安装包程序基本上只需要有最基础的 Qt 界面模块即可，不过把除了 UI 的模块全部去掉又比较难用…这里记录下两种极端编译配置下生成的程序大小作为参考。</p>
<h1 id="编译环境搭建"><a href="#编译环境搭建" class="headerlink" title="编译环境搭建"></a>编译环境搭建</h1><h2 id="编译工具安装"><a href="#编译工具安装" class="headerlink" title="编译工具安装"></a>编译工具安装</h2><p>编译需要的环境可以看官方文档，<a href="https://doc.qt.io/qt-5/windows-requirements.html" target="_blank" rel="noopener">windows-requirements</a> 中的<code>Building from Source</code>有说明需要安装的工具，所有工具都记得要添加到环境变量。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt5-12-5-static-build-2020-07-11-22-37-34.png" alt="Qt5-12-5-static-build-2020-07-11-22-37-34"></p>
<ol>
<li>VS2019（其他版本仅作参考），下载地址：<a href="https://visualstudio.microsoft.com/zh-hans/vs/" target="_blank" rel="noopener">Visual Studio 2019</a></li>
<li>ActivePerl， 下载地址：<a href="https://www.activestate.com/products/perl/downloads/" target="_blank" rel="noopener">Download And Install Perl: ActivePerl</a></li>
<li>Python，下载地址：<a href="https://www.python.org/downloads/windows/" target="_blank" rel="noopener">Python Releases for Windows</a></li>
<li>Ruby（以前的官方文档是有的，如果有问题可以装下），下载地址：<a href="https://rubyinstaller.org/downloads/" target="_blank" rel="noopener">RubyInstaller for Windows</a></li>
<li>Jom，多核编译，下载地址：<a href="http://download.qt.io/official_releases/jom/jom.zip" target="_blank" rel="noopener">jom releases</a></li>
</ol>
<h2 id="编译准备"><a href="#编译准备" class="headerlink" title="编译准备"></a>编译准备</h2><ol>
<li>源码下载并解压，下载地址：<a href="https://download.qt.io/archive/qt/5.12/5.12.5/single/qt-everywhere-src-5.12.5.zip" target="_blank" rel="noopener">qt-everywhere-src-5.12.5.zip</a></li>
<li>在源码同级目录创建个 qt-build 目录来放生成的文件，也就是使用<code>shadow build</code>，方便修改配置后进行多配置编译。直接运行源码目录下的 configure.bat 会把生成文件生成到源码目录，修改配置后编译容易出错。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt5-12-5-static-build-2020-07-11-22-47-19.png" alt="Qt5-12-5-static-build-2020-07-11-22-47-19"></p>
<ol start="3">
<li>修改<code>qtbase\mkspecs\common\msvc-desktop.conf</code>文件，将 MD 改为 MT</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt5-12-5-static-build-2020-07-12-00-27-17.png" alt="Qt5-12-5-static-build-2020-07-12-00-27-17"></p>
<ol start="4">
<li>打开 VS 的命令行工具并切换到第 2 步创建的 qt-build 目录，后面就是输入命令编译了。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt5-12-5-static-build-2020-07-12-00-29-11.png" alt="Qt5-12-5-static-build-2020-07-12-00-29-11"></p>
<h1 id="编译步骤"><a href="#编译步骤" class="headerlink" title="编译步骤"></a>编译步骤</h1><pre><code class="shell">.\..\src\configure.bat xxx  # 根据指定配置生成makefile
nmake 或者 jom              # 编译
nmake install               # 安装到指定目录
</code></pre>
<h1 id="全模块配置"><a href="#全模块配置" class="headerlink" title="全模块配置"></a>全模块配置</h1><h2 id="编译配置命令"><a href="#编译配置命令" class="headerlink" title="编译配置命令"></a>编译配置命令</h2><p>最后的-mp 是多核编译的参数，多核编译用 jom 快得一匹，全模块也只要 20 分钟编译完成。</p>
<pre><code class="bat">.\..\src\configure.bat -static -release -platform win32-msvc -release -static -prefix &quot;D:\Qt\Qt5.12.5-msvc2019-x86-static-release-full&quot; -opensource -confirm-license -nomake examples -nomake tests -plugin-sql-sqlite -plugin-sql-odbc -qt-zlib -qt-libpng -qt-libjpeg -opengl desktop -mp
</code></pre>
<h2 id="Qt库大小"><a href="#Qt库大小" class="headerlink" title="Qt库大小"></a>Qt库大小</h2><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt5-12-5-static-build-2020-07-12-10-15-19.png" alt="Qt5-12-5-static-build-2020-07-12-10-15-19"></p>
<h2 id="Demo-程序大小"><a href="#Demo-程序大小" class="headerlink" title="Demo 程序大小"></a>Demo 程序大小</h2><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt5-12-5-static-build-2020-07-12-00-02-46.png" alt="Qt5-12-5-static-build-2020-07-12-00-02-46"></p>
<h1 id="超精简配置"><a href="#超精简配置" class="headerlink" title="超精简配置"></a>超精简配置</h1><p>这个配置把能删的模块都删了，编译出来后基本也就基础UI相关类能用…所以编译起来超快的。</p>
<h2 id="编译配置命令-1"><a href="#编译配置命令-1" class="headerlink" title="编译配置命令"></a>编译配置命令</h2><pre><code class="bat">.\..\src\configure.bat -static -release -platform win32-msvc -no-opengl -prefix &quot;D:\Qt\Qt5.12.5-msvc2019-x86-static-release-mini&quot; -opensource -confirm-license -make libs -nomake tools -nomake examples -nomake tests -skip qt3d -skip qtandroidextras -skip qtcanvas3d -skip qtconnectivity -skip qtdatavis3d -skip qtdeclarative -skip qtdoc -skip qtgamepad -skip qtcharts -skip qtgraphicaleffects -skip qtimageformats -skip qtlocation -skip qtmacextras -skip qtmultimedia -skip qtnetworkauth -skip qtpurchasing -skip qtquickcontrols -skip qtquickcontrols2 -skip qtscript -skip qtscxml -skip qtsensors -skip qtserialbus -skip qtspeech -skip qtsvg -skip qttools -skip qttranslations -skip qtvirtualkeyboard -skip qtwayland -skip qtwebchannel -skip qtwebengine -skip qtwebsockets -skip qtwebview -skip qtwinextras -skip qtx11extras -skip qtxmlpatterns -no-feature-texthtmlparser -no-feature-textodfwriter -no-feature-concurrent -no-feature-effects -no-feature-sharedmemory -no-feature-systemsemaphore -no-feature-im -no-feature-dom -no-feature-filesystemwatcher -no-feature-graphicsview -no-feature-graphicseffect -no-feature-sizegrip -no-feature-printpreviewwidget -no-feature-keysequenceedit -no-feature-colordialog -no-feature-fontdialog -no-feature-printpreviewdialog -no-feature-progressdialog -no-feature-errormessage -no-feature-wizard -no-feature-datawidgetmapper -no-feature-cups -no-feature-paint_debug -no-feature-codecs -no-feature-big_codecs -no-feature-iconv -no-feature-networkproxy -no-feature-socks5 -no-feature-networkdiskcache -no-feature-bearermanagement -no-feature-mimetype -no-feature-undocommand -no-feature-undostack -no-feature-undogroup -no-feature-undoview -no-feature-statemachine -no-feature-gestures -no-feature-dbus -no-feature-sessionmanager -no-feature-topleveldomain -no-feature-sha3-fast -no-feature-imageformat_ppm -no-feature-imageformat_xbm -no-feature-freetype -no-feature-appstore-compliant -no-feature-process -no-feature-lcdnumber -qt-zlib -qt-libpng -qt-libjpeg
</code></pre>
<h2 id="Qt库大小-1"><a href="#Qt库大小-1" class="headerlink" title="Qt库大小"></a>Qt库大小</h2><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt5-12-5-static-build-2020-07-12-10-16-54.png" alt="Qt5-12-5-static-build-2020-07-12-10-16-54"></p>
<h2 id="Demo-程序大小-1"><a href="#Demo-程序大小-1" class="headerlink" title="Demo 程序大小"></a>Demo 程序大小</h2><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt5-12-5-static-build-2020-07-12-00-05-11.png" alt="Qt5-12-5-static-build-2020-07-12-00-05-11"></p>
<p>比全模块配置生成的exe减少了 30%的大小，不过 30%也就 3M，在 windows 平台的话倒是没必要追求这种极致了=-=</p>
<h1 id="使用编译后的静态库"><a href="#使用编译后的静态库" class="headerlink" title="使用编译后的静态库"></a>使用编译后的静态库</h1><ol>
<li>新建一个 Qt Version，并添加编译后的 qmake.exe 的路径。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt5-12-5-static-build-2020-07-12-00-12-39.png" alt="Qt5-12-5-static-build-2020-07-12-00-12-39"></p>
<p>此时如果是移动了编译后的路径，可能报错<em>Qt version is not properly installed,please run make install</em>。在 qmake.exe 所在目录新建一个 qt.conf 文件，并添加下面的内容即可：</p>
<pre><code class="conf">[paths]
Prefix = ..
</code></pre>
<ol start="2">
<li>新建一个构建套件，选好编译器和上一步新建的 Qt version 即可：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt5-12-5-static-build-2020-07-12-00-24-17.png" alt="Qt5-12-5-static-build-2020-07-12-00-24-17"></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://blog.csdn.net/wsj18808050/article/details/55808104" target="_blank" rel="noopener">QtLite 使用方法，以及缩减应用体积的效果</a></li>
<li><a href="https://blog.csdn.net/zhangpeterx/article/details/86529231" target="_blank" rel="noopener">Qt 最新版 5.12 在 Windows 环境静态编译安装和部署的完整过程(VS2017)</a></li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> static build </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[YUV图像旋转]]></title>
      <url>https://longxuan.ren/2020/06/16/YUV-Rotate/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>手机竖屏录制的视频，PC 播放时需要对解码后的数据做下旋转。<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h1 id="视频旋转角度获取"><a href="#视频旋转角度获取" class="headerlink" title="视频旋转角度获取"></a>视频旋转角度获取</h1><h2 id="命令行获取"><a href="#命令行获取" class="headerlink" title="命令行获取"></a>命令行获取</h2><p>使用 ffprobe.exe，<code>ffprobe video.mp4</code>，会输出视频的详细信息。在视频的 Metadata 的 rotate 属性如果有值的话就是旋转的角度了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/YUV-Rotate-2020-06-16-14-04-03.png" alt="YUV-Rotate-2020-06-16-14-04-03"></p>
<h2 id="代码中获取"><a href="#代码中获取" class="headerlink" title="代码中获取"></a>代码中获取</h2><p>在获取 video 的 AVStream 时调用：</p>
<pre><code class="C++">int getVideoRotation(AVStream *st)
{
    AVDictionaryEntry *rotate_tag = av_dict_get(st-&gt;metadata, &quot;rotate&quot;, nullptr, 0);
    int rotation = 0;

    if (rotate_tag) {
        rotation = QString(rotate_tag-&gt;value).toInt();
    }

    while (rotation &lt; 0) {
        rotation += 360;
    }

    while (rotation &gt; 360) {
        rotation -= 360;
    }

    LOG-&gt;info(&quot;vodeo rotation: {}&quot;, rotation);

    return rotation;
}
</code></pre>
<h1 id="旋转-YUV"><a href="#旋转-YUV" class="headerlink" title="旋转 YUV"></a>旋转 YUV</h1><p>旋转可以使用 libyuv 这个库，<a href="https://github.com/lemenkov/libyuv" target="_blank" rel="noopener">github 地址</a>。旋转相关函数可以看<code>libyuv\include\libyuv\rotate.h</code>。比如将 I420（ffmpeg 里的 YUV420P）旋转 270 度只需要调用：</p>
<pre><code class="C++">uchar * i420_y = _pBuffer;
uchar * i420_u = i420_y + (width * height);
uchar * i420_v = i420_y + (width * height) * 5 / 4;

uchar * rotated_y = _pRotateBuffer;
uchar * rotated_u = rotated_y + (width * height);
uchar * rotated_v = rotated_y + (width * height) * 5 / 4;

libyuv::I420Rotate(
        i420_y, width,
        i420_u, (width &gt;&gt; 1),
        i420_v, (width &gt;&gt; 1),
        rotated_y, height,
        rotated_u, (height &gt;&gt; 1),  //90度和270度宽高会互换，步长需要注意
        rotated_v, (height &gt;&gt; 1),
        width, height, libyuv::kRotate270);
</code></pre>
<p>libyuv 旋转的同时还能把格式也转换了，比如<code>NV12ToI420Rotate</code>，有需要可以翻头文件看看。</p>
</the>]]></content>
      
        <categories>
            
            <category> 音视频 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> libyuv </tag>
            
            <tag> yuv </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt Widget与原生窗口的对比]]></title>
      <url>https://longxuan.ren/2020/06/08/Qt-Widget-NativeWindow/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>QWidget 和原生窗口的一些对比<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h1 id="原生窗口的从属关系"><a href="#原生窗口的从属关系" class="headerlink" title="原生窗口的从属关系"></a>原生窗口的从属关系</h1><p>包括父/子（parent-child）关系、拥有/被拥有（owner-owned）关系及兄弟（siblings）关系。</p>
<h2 id="父子关系"><a href="#父子关系" class="headerlink" title="父子关系"></a>父子关系</h2><ol>
<li>子窗口的位置坐标都是相对于父窗口客户区的左上角（upper-left corner）计算的。</li>
<li>子窗口会把它的 notify 消息发送到父窗口。</li>
<li>子窗口只能显示在它的父窗口的客户区中，超出父窗口客户区的部分将被裁减掉；父窗口被隐藏时，它的所有子窗口也被隐藏；</li>
<li>最小化父窗口不影响子窗口的可见状态，子窗口会随着父窗口被最小化，但是它的 WS_VISIBLE 属性不变。</li>
<li>父窗口被销毁的时候，它的所有子窗口都会被销毁。</li>
</ol>
<h2 id="拥有-被拥有关系"><a href="#拥有-被拥有关系" class="headerlink" title="拥有/被拥有关系"></a>拥有/被拥有关系</h2><p>顶层窗口之间可以存在 owner-owned 关系。owner-owned 关系对窗口可见性的影响为：owned 窗口永远显示在 owner 窗口的前面；当 owner 窗口最小化的时候，它所拥有的窗口都会被隐藏；隐藏 owner 窗口不影响它所拥有的窗口的可见状态。根据最后这一点，如果窗口 A 拥有窗口 B,窗口 B 拥有窗口 C,则当窗口 A 最小化的时候，窗口 B 被隐藏，但是窗口 C 还是可见的。当 owner 窗口被销毁的时候，它所拥有的窗口都会被销毁。</p>
<h2 id="兄弟关系"><a href="#兄弟关系" class="headerlink" title="兄弟关系"></a>兄弟关系</h2><p>同一个父窗口的所有直属子窗口之间是兄弟关系，也就是相互平等，没有主从之分。窗口管理器用链表（linked list）来管理每个父窗口的直属子窗口，这个链表叫子窗口链（child window list）。<br>调用 GetWindow 函数时使用 GW_HWNDPREV 或 GW_HWNDNEXT 标志可访问子窗口链中的前一个或后一个窗口；使用 GW_HWNDFIRST 或 GW_HWNDLAST 标志可访问子窗口链中的第一个或最后一个窗口。</p>
<h1 id="QWidget-的丛属关系"><a href="#QWidget-的丛属关系" class="headerlink" title="QWidget 的丛属关系"></a>QWidget 的丛属关系</h1><h2 id="父子关系-1"><a href="#父子关系-1" class="headerlink" title="父子关系"></a>父子关系</h2><p>在创建 Qt 对象的时候，一般都会指定一个 parent。指定了 parent 后，当父对象删除的时候会将其子对象也一并删除，所以在 Qt 中经常是看到 new 却没有对应的 delete。不过指定了 parent 之后的 widget 默认就不是原生的 native widget 了，通过 spy++是看不到对应的窗口的，创建的是 Qt 的 Alien Widget，只能看到顶层的 MainWindow:</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Widget-NativeWindow-2020-06-08-12-12-08.png" alt="Qt-Widget-NativeWindow-2020-06-08-12-12-08"></p>
<p>但是在父子关系下，特性和原生窗口差不多：</p>
<ol>
<li>子 Widget 的位置坐标是相对于父窗口的左上角计算的。</li>
<li>子 Widget 的事件默认不会再往父 Widget 传递</li>
<li>子 Widget 只能显示在它的父窗口的客户区中，超出父窗口客户区的部分将被裁减掉；父窗口被隐藏时，它的所有子 Widget 也被隐藏。</li>
<li>父 Widget 被销毁时，子 Widget 也会被销毁。</li>
</ol>
<p>在某些使用第三方库的情况下，可能需要一个子 Widget 的句柄，可以调用子 Widget 的<code>winId()</code>方法，不过调用之后同一个 parent 下的 widget 都会变成原生窗口。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Widget-NativeWindow-2020-06-08-13-46-37.png" alt="Qt-Widget-NativeWindow-2020-06-08-13-46-37"></p>
<h2 id="兄弟关系-1"><a href="#兄弟关系-1" class="headerlink" title="兄弟关系"></a>兄弟关系</h2><p>同一个 parent 下的子 widget，创建后会放在父 Widget 的创建栈 （widget’s stack） 中。后创建的显示在最前面，如果需要把之前创建的 widget 显示在前面可以调用<code>raise()</code>方法。</p>
<p>如果创建 widget 时没有指定 parent，那么创建的就是 native 的顶层窗口，直接就有句柄。此时调用<code>raise()</code>方法也有效。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Widget-NativeWindow-2020-06-08-13-58-02.png" alt="Qt-Widget-NativeWindow-2020-06-08-13-58-02"></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://blog.csdn.net/dbzhang800/article/details/7006270" target="_blank" rel="noopener">QWidget 之 Alien 与 Native 小记</a></li>
<li><a href="https://blog.csdn.net/dbzhang800/article/details/7010114" target="_blank" rel="noopener">从 QWindow 到 QWidget(Qt5)</a></li>
<li><a href="https://www.cnblogs.com/dhatbj/p/3288152.html" target="_blank" rel="noopener">窗口之间的主从关系与 Z-Order</a></li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QWidget </tag>
            
            <tag> parent </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt全局热键实现]]></title>
      <url>https://longxuan.ren/2020/06/06/Qt-Global-Shortcut/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>Qt 中没有实现好的跨平台全局热键，需要自己调用系统 API 来实现。<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h1 id="监听系统原生事件"><a href="#监听系统原生事件" class="headerlink" title="监听系统原生事件"></a>监听系统原生事件</h1><p>Qt 作为跨平台的框架，实现的功能是在每个平台都共有的部分，而有的功能可能由于某些原因不能跨平台就没有，这时候就需要调用系统原生的 API，比如全局热键的功能、电池休眠事件监听等。</p>
<h2 id="窗口的原生事件"><a href="#窗口的原生事件" class="headerlink" title="窗口的原生事件"></a>窗口的原生事件</h2><p>窗口的原生事件可以通过重载<code>QWidget::nativeEvent(const QByteArray &amp;eventType, void *message, long *result)</code>来实现。在函数中返回 true 会停止传递，如果返回 false 会继续由 Qt 处理事件。当窗口有句柄的时候，触发了平台原生的事件就会调用此函数。由 eventType 标识本机平台事件，这些事件的参数在 message 中传递。不同平台的 eventType 、message 如下：</p>
<table>
<thead>
<tr>
<th>Platform</th>
<th>Event Type Identifier</th>
<th>Message Type</th>
<th>Result Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>Windows</td>
<td>“windows_generic_MSG”</td>
<td>MSG *</td>
<td>LRESULT</td>
</tr>
<tr>
<td>macOS</td>
<td>“NSEvent”</td>
<td>NSEvent *</td>
<td></td>
</tr>
<tr>
<td>XCB</td>
<td>“xcb_generic_event_t”</td>
<td>xcb_generic_event_t *</td>
</tr>
</tbody>
</table>
<p>下面举个例子，比如当前窗口在做一些操作，笔记本合上盖子进入休眠，要监听电池相关的事件：</p>
<pre><code class="C++">bool MainWidget::nativeEvent(const QByteArray &amp;eventType, void *message, long *result)
{
    if (eventType == &quot;windows_generic_MSG&quot; || eventType == &quot;windows_dispatcher_MSG&quot;) {
        MSG* msg = static_cast&lt;MSG*&gt;(message);
        if (msg-&gt;message == WM_POWERBROADCAST) {
            if(msg-&gt;wParam == PBT_APMSUSPEND) {
                qDebug(&quot;系统休眠&quot;);
            }
            else if(msg-&gt;wParam == PBT_APMRESUMESUSPEND || msg-&gt;wParam == PBT_APMRESUMEAUTOMATIC) {
                qDebug(&quot;系统唤醒&quot;);
            }
        }
    }

    return QWidget::nativeEvent(eventType, message, result);
}
</code></pre>
<h2 id="应用级原生事件"><a href="#应用级原生事件" class="headerlink" title="应用级原生事件"></a>应用级原生事件</h2><p>像全局热键这样的事件是应用级别的，事件的监听就要放在 app 上。通过继承<code>QAbstractNativeEventFilter</code>来实现自己的原生事件过滤器并安装到 app 上即可。当有原生事件触发后就会调用事件过滤器的<code>virtual bool nativeEventFilter(const QByteArray &amp;eventType, void *message, long *)</code>函数。<br>要处理热键的话重写函数如下：</p>
<pre><code class="C++">bool MyWinEventFilter::nativeEventFilter(const QByteArray &amp;eventType, void *message, long *)
{
   if(eventType == &quot;windows_generic_MSG&quot;) {
        MSG *msg = static_cast&lt;MSG *&gt;(message);
        if(msg-&gt;message == WM_HOTKEY) {
            //判断是否为指定热键按下
        }

    }
    return false;
}
</code></pre>
<h1 id="热键的注册"><a href="#热键的注册" class="headerlink" title="热键的注册"></a>热键的注册</h1><p>上面处理好了事件发生后的步骤，还需要告诉系统哪些算是热键。注册用到的原生 API 有：</p>
<pre><code class="C++">BOOL   RegisterHotKey(
HWND   hWnd,         //响应该热键的窗口句柄, 由于是应用级的，可以不传
Int   id,            //该热键的唯一标识
UINT   fsModifiers,  //该热键的辅助按键，Ctrl、Alt、Shift
UINT   vk            //该热键的键值
);

BOOL UnregisterHotKey(
HWND hWnd,           //响应该热键的窗口句柄,同不传
Int id               //该热键的唯一标识
);

</code></pre>
<p>注册时按键的虚拟码可以去<a href="https://docs.microsoft.com/zh-cn/windows/win32/inputdev/virtual-key-codes" target="_blank" rel="noopener">官网查询</a>。<br>注册按键的函数一般都是字符串的形式，可以自己写个转换函数，也可以使用 Qt 的<code>QKeySequence</code>先得到热键的 Qt 的键盘码，再映射到 windwos 的虚拟码。</p>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>具体代码就不贴了，在 Github 上有个封装好各个平台的全局热键的仓库，<a href="https://github.com/Skycoder42/QHotkey" target="_blank" rel="noopener">QHotkey</a></p>
<p>windows 相关实现在<code>QHotkey/QHotkey/qhotkey_win.cpp</code>中，里面就是调用 <code>RegisterHotKey</code> 来实现的。</p>
</the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Shortcut </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[H264码流分析]]></title>
      <url>https://longxuan.ren/2020/05/28/H264-Analyze/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>H264 是属于视频的编码层的标准格式，平时用 ffmpeg 只是指定下参数就完事了，并没有仔细了解，今天来分析下 H264 码流具体的内容。<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h1 id="ffmpeg-中使用-H264-编码"><a href="#ffmpeg-中使用-H264-编码" class="headerlink" title="ffmpeg 中使用 H264 编码"></a>ffmpeg 中使用 H264 编码</h1><p>ffmpeg 已经有实现好了编码器，调用的时候指定<code>AV_CODEC_ID_H264</code>，会使用 x264 的软编码；如果需要硬编码将查找编码器改为<code>avcodec_find_encoder_by_name(&quot;h264_qsv&quot;)</code>。</p>
<pre><code class="C++">int size;
int in_w = mWidth;
int in_h = mHeight;

//x264软编码初始化
pCodec = avcodec_find_encoder(AV_CODEC_ID_H264);
if(!pCodec) {
  fprintf(stderr, &quot;h264 codec not found&quot;);
  return false;
}

//qsv硬编码
// pCodec = avcodec_find_encoder_by_name(&quot;h264_qsv&quot;);
// if(Q_NULLPTR == pCodec){
//     qDebug(&quot;avcodec_find_encoder failed!&quot;);
//     return false;
// }

pCodecCtx = avcodec_alloc_context3(pCodec);
pCodecCtx-&gt;codec_id = AV_CODEC_ID_H264;
pCodecCtx-&gt;codec_type = AVMEDIA_TYPE_VIDEO;
pCodecCtx-&gt;pix_fmt = PIX_FMT_YUV420P;
pCodecCtx-&gt;width = in_w;
pCodecCtx-&gt;height = in_h;
pCodecCtx-&gt;time_base.num = 1;
pCodecCtx-&gt;time_base.den = 25;//帧率
pCodecCtx-&gt;bit_rate = mBitRate; //比特率
pCodecCtx-&gt;gop_size=25;

···

//读取编码后数据，在AVPacket中
if(0 != avcodec_send_frame(m_pEncodeContext, m_pSwsFrame)) {
    qDebug(&quot;avcodec_send_frame failed&quot;);
    return false;
}
while(0 == avcodec_receive_packet(m_pEncodeContext, m_pDstPacket)) {
    if(m_pCallback) {
        if (m_pDstPacket-&gt;flags &amp; AV_PKT_FLAG_KEY) {
            qDebug(&quot;encode a key frame&quot;);
        }

        m_pCallback-&gt;onVideoEncodeFinished(m_pDstPacket-&gt;data, m_pDstPacket-&gt;size);

    }

    av_packet_unref(m_pDstPacket);
}
</code></pre>
<h1 id="H264-原始码流结构"><a href="#H264-原始码流结构" class="headerlink" title="H264 原始码流结构"></a>H264 原始码流结构</h1><p>在 H.264/AVC 视频编码标准中，整个系统框架被分为两层，VCL(视频编码层 video coding layer) 和 NAL(网络提取层 network abstraction layer)：</p>
<ol>
<li>VCL：核心算法引擎，块，宏块及片的语法级别的定义，负责高效的视频内容表示，通俗的讲就是编码器直接编码之后的数据，这部分数据还不能直接用于保存和网络传输，否则在解析上存在困难。</li>
<li>NAL：负责格式化数据并提供头信息，以保证数据适合各种信道和存储介质上的传输，通俗的讲 NAL 就是 VCL 加了一些头部信息封装了一下。</li>
</ol>
<p>H264 码流数据由 NALU 序列组成，相邻的 NALU 由起始码 StartCode 隔开，起始码 StartCode 的两种形式：3 字节的 0x000001 和 4 字节的 0x00000001。3 字节的 起始码只有在一个完整的帧被编为多个 slice（片）的时候，从第二个 slice 开始，使用 3 字节起始码。<br>NALU 是一个 NAL 单元，NALU = 字节的头信息（NALU Header） + 原始字节序列载荷（RBSP）（实际为扩展字节序列载荷（EBSP）的字节流）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/H264-Analyze-2020-06-07-11-19-46.jpg" alt="H264-Analyze-2020-06-07-11-19-46"></p>
<h2 id="NALU-Header"><a href="#NALU-Header" class="headerlink" title="NALU Header"></a>NALU Header</h2><p>NALU Header 由 3 部分组成，NALU Header = forbidden_bit(1bit) + nal_reference_bit(2bit) + nal_unit_type(5bit)，共占用 1 个字节</p>
<ol>
<li>forbidden_bit 禁止位：编码中默认值为 0，当网络识别此单元中存在比特错误时，可将其设为 1，以便接收方丢掉该单元，主要用于适应不同种类的网络环境</li>
<li>nal_reference_bit 重要性指示位：用于在重构过程中标记一个 NAL 单元的重要性，值越大，越重要。尤其是当前 NALU 为图像参数集、序列参数集或 IDR 图像时，或者为参考图像条带（片/Slice），或者为参考图像的条带数据分割时，nal_ref_idc 值肯定不为 0。</li>
<li>nal_unit_type：NALU 类型位: 可以表示 NALU 的 32 种不同类型特征，类型 1 ～ 12 是 H.264 定义的，类型 24 ～ 31 是用于 H.264 以外的，RTP 负荷规范使用这其中的一些值来定义包聚合和分裂，其他值为 H.264 保留。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/H264-Analyze-2020-06-07-11-31-18.png" alt="H264-Analyze-2020-06-07-11-31-18"></p>
<p>判断起始码后的第一个字节的后 5bit 就可以判断出这个 NALU 的类型，例如：<code>00 00 00 01 67: 0x67&amp;0x1f = 0x07 :SPS</code>。另外说下重要的类型：</p>
<ul>
<li>al_unit_type=5：表示当前 NAL 是 IDR 图像的一个片，在这种情况下，IDR 图像中的每个片的 nal_unit_type 都应该等于 5。注意，IDR 图像不能使用分区。</li>
<li>nal_unit_type=7：SPS，包括一个图像序列的所有信息，即两个IDR图像间的所有图像信息，如标识符 seq_parameter_set_id、帧数及 POC 的约束、参考帧数目、解码图像尺寸和帧场编码模式选择标识等等。</li>
<li>nal_unit_type=8：PPS，PPS对应的是一个序列中某一幅图像或者某几幅图像，包括一个图像的所有slice的所有相关信息，如图像类型、序列号、标识符 pic_parameter_set_id、可选的 seq_parameter_set_id、熵编码模式选择标识、片组数目、初始量化参数和去方块滤波系数调整标识等等，解码时某些序列号的丢失可用来校验信息包的丢失与否。</li>
</ul>
<h2 id="RBSP"><a href="#RBSP" class="headerlink" title="RBSP"></a>RBSP</h2><p>NALU 的主体部分需要先介绍下面 3 个名词。</p>
<ol>
<li>SODB: String Of Data Bits  原始数据比特流，编码后的原始数据，即VCL数据。</li>
<li>RBSP: 原始字节序列载荷。由于 SODB 长度不一定是 8 的倍数，为了字节对齐，在 SODB 的后面填加了结尾比特（rbsp_trailing_bits）就得到了 RBSP。rbsp_trailing_bits = rbsp_stop_one_bit（值为 1，1bit）+ rbsp_alignment_zero_bit(若干个 0，字节对齐填充)</li>
<li>EBSP: 扩展字节序列载荷。NALU 之间是通过 StartCode 来隔开的，如果编码后的原始数据含有 0x000001，就无法知道这个到底是不是 StartCode，因此为了使 NALU 主体中不包括与开始码相冲突的数据，在 RBSP 数据中每遇到两个字节连续为 0，就插入一个字节的 0x03，这样就得到了 EBSP。</li>
</ol>
<p>所以，SODB + 添加尾部字节对齐 ==&gt; RBSP + 碰到 0x0000 插入 0x03 ==&gt; EBSP。<br>VCL层是对核心算法引擎、块、宏块及片的语法级别的定义，最终输出压缩编码后的数据 SODB。VCL数据在传输或存储之前，先被映射或封装进NAL单元中。NAL层将SODB打包成RBSP然后加上NALU Header，组成一个NALU。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/H264-Analyze-2020-06-07-12-32-45.png" alt="H264-Analyze-2020-06-07-12-32-45"></p>
<p>相应的 RBSP 数据类型描述如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/H264-Analyze-2020-06-07-12-57-26.png" alt="H264-Analyze-2020-06-07-12-57-26"></p>
<h2 id="视频帧"><a href="#视频帧" class="headerlink" title="视频帧"></a>视频帧</h2><p>从宏观上来说，SPS、PPS、IDR 帧（包含一个或多个 I-Slice）、P 帧（包含一个或多个 P-Slice ）、B 帧（包含一个或多个 B-Slice ）组成的视频序列构成了 H264 的码流。<br>包含具体视频数据的帧有：<br>| 类型 | 意义                                                                                                                    |<br>| —- | ———————————————————————————————————————– |<br>| I 帧 | I 帧通常是每个 GOP（MPEG 所使用的一种视频压缩技术）的第一个帧，经过适度地压缩，做为随机访问的参考点，可以当成图象。     |<br>| P 帧 | 通过充分将低于图像序列中前面已编码帧的时间冗余信息来压缩传输数据量的编码图像，也叫预测帧                                |<br>| B 帧 | 既考虑与源图像序列前面已编码帧，也顾及源图像序列后面已编码帧之间的时间冗余信息来压缩传输数据量的编码图像,也叫双向预测帧 |</p>
<p>一个视频序列的第一帧又叫 IDR 帧。IDR 帧的作用是立刻刷新，使错误不致传播，从 IDR 帧开始，重新算一个新的序列开始编码。<br>I 帧可以不依赖其他帧就解码出一幅完整的图像，而 P 帧、B 帧不行。P 帧需要依赖视频流中排在它前面的帧才能解码出图像，B 帧则需要依赖视频流中排在它前面或后面的帧才能解码出图像。在视频流中，先到来的 B 帧无法立即解码，需要等待它依赖的后面的 P 帧先解码，播放时间与解码时间不一致，这时就需要DTS和PTS了。</p>
<ul>
<li>DTS（Decoding Time Stamp）：解码时间戳，这个时间戳的意义在于告诉播放器该在什么时候解码这一帧的数据。</li>
<li>PTS（Presentation Time Stamp）：显示时间戳，这个时间戳用来告诉播放器该在什么时候显示这一帧的数据。</li>
</ul>
<p>在没有B帧的时候，DTS、PTS顺序是一致的，比如直播等延迟要求小的使用场景。音频也有PTS、DTS，但是音频没有类似视频的 B 帧，不需要双向预测，所以音频帧的 DTS、PTS 顺序是一致的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/H264-Analyze-2020-06-07-17-28-25.png" alt="H264-Analyze-2020-06-07-17-28-25"></p>
<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p>帧图像可编码成一个或者多个片（slice），分片的目的是为了限制误码的扩散和传输，使编码片相互间保持独立。<br>每一个 slice 总体来看都由两部分组成，一部分作为 slice header，用于保存 slice 的总体信息（如当前 slice 的类型等），另一部分为 slice body，通常是一组连续的宏块结构。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/H264-Analyze-2020-06-07-17-07-27.png" alt="H264-Analyze-2020-06-07-17-07-27"></p>
<p>slice 的类型如下：<br>| 类型     | 意义                                    |<br>| ——– | ————————————— |<br>| I slice  | 只包含 I 宏块                           |<br>| P slice  | 包含 P 和 I 宏块                        |<br>| B slice  | 包含 B 和 I 宏块                        |<br>| SP slice | 包含 P 或 I 宏块,用于不同码流之间的切换 |<br>| SI slice | 一种特殊类型的编码宏块                  |</p>
<h2 id="宏块"><a href="#宏块" class="headerlink" title="宏块"></a>宏块</h2><p>宏块是视频信息的主要承载者。一个编码图像通常划分为多个宏块组成.包含着每一个像素的亮度和色度信息。视频解码最主要的工作则是提供高效的方式从码流中获得宏块中像素阵列。<br>一个宏块由一个 16×16 亮度像素和附加的一个 8×8 Cb 和一个 8×8 Cr 彩色像素块组成。宏块分类如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>I 宏块</td>
<td>利用从当前片中已解码的像素作为参考进行帧内预测</td>
</tr>
<tr>
<td>P 宏块</td>
<td>利用前面已编码图像作为参考进行帧内预测</td>
</tr>
<tr>
<td>B 宏块</td>
<td>利用双向的参考图像（当前和未来的已编码图像帧）进行帧内预测</td>
</tr>
</tbody>
</table>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/H264-Analyze-2020-06-07-17-19-09.png" alt="H264-Analyze-2020-06-07-17-19-09"></p>
<h1 id="H264-解析流程"><a href="#H264-解析流程" class="headerlink" title="H264 解析流程"></a>H264 解析流程</h1><p>拿到 RBSP 或 SODB 之后，根据对应的 NALU Header 类型来解析编码的数据，解析流程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/H264-Analyze-2020-06-07-16-24-28.jpg" alt="H264-Analyze-2020-06-07-16-24-28"></p>
<p>使用 ffmpeg 的话一般是不会自己去解析的，因为数据都在对应的结构体变量中，比如判断一帧是否是 I 帧：</p>
<pre><code class="C++">if (m_pDstPacket-&gt;flags &amp; AV_PKT_FLAG_KEY) {
    qDebug(&quot;encode a key frame&quot;);
}
</code></pre>
<h1 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h1><ul>
<li><a href="https://www.itu.int/rec/T-REC-H.264-200503-S/en" target="_blank" rel="noopener">H264 协议文档</a></li>
<li><a href="https://www.bilibili.com/video/av37424012" target="_blank" rel="noopener">“视频”是怎么来的？H.264、码率这些词又是什么意思？</a></li>
<li><a href="https://www.jianshu.com/p/8edb448cf22e" target="_blank" rel="noopener">H264 基础简介</a></li>
<li><a href="https://www.jianshu.com/p/a2dc69c8bf70" target="_blank" rel="noopener">h264 码流格式与 NALU 详解一</a></li>
<li><a href="https://blog.csdn.net/qq214517703/article/details/80359911" target="_blank" rel="noopener">H.264 数据解析</a></li>
<li><a href="https://blog.csdn.net/qq_19923217/article/details/83348095" target="_blank" rel="noopener">H264 编解码协议详解</a></li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> Video </category>
            
        </categories>
        
        
        <tags>
            
            <tag> H264 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[windows桌面采集（GDI、DSHOW、DXGI对比）]]></title>
      <url>https://longxuan.ren/2020/05/26/Windows-ScreenCapture/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>windows 下 3 种桌面采集方式的对比<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<p>桌面采集就是定时截取桌面的画面，并且将截取后的 RGB 画面通过某种编码方式（比如 H264）压缩后再发送出去。采集的帧率达到 20 帧以上的时候，接收端再显示出来就有投屏的效果了。</p>
<h1 id="GDI"><a href="#GDI" class="headerlink" title="GDI"></a>GDI</h1><p>Windows 图形设备接口(GDI)是为与设备无关的图形设计的。基于 Windows 的应用程序不能直接访问图形硬件，应用程序通过 GDI 来与设备驱动程序进行交互。GDI 截图就是通过屏幕的设备环境（DC）获取到当前屏幕的位图数据。</p>
<h2 id="ffmpeg-调用"><a href="#ffmpeg-调用" class="headerlink" title="ffmpeg 调用"></a>ffmpeg 调用</h2><p>ffmpeg 封装了 GDI 截图的相关的函数，调用和文件的播放差不多，区别就是初始化时多调用了<code>av_find_input_format</code>。<br>获取到的每一帧数据通过<code>avcodec_receive_frame</code>拿到 AVFrame。</p>
<pre><code class="C++">//GDI截屏初始化
m_pFormatContext = avformat_alloc_context();
if(nullptr == m_pFormatContext) {
    qDebug(&quot;avformat_alloc_context failed&quot;);
    break;
}

AVInputFormat * pInputFormat = av_find_input_format(&quot;gdigrab&quot;);
if(nullptr == pInputFormat) {
    qDebug(&quot;av_find_input_format failed&quot;);
    break;
}

AVDictionary * options = nullptr;
if(0 != avformat_open_input(&amp;m_pFormatContext, &quot;desktop&quot;, pInputFormat, &amp;options)) {
    qDebug(&quot;avformat_open_input failed&quot;);
    break;
}
...

//文件播放初始化
m_pAVFormatContext = avformat_alloc_context();

int result = avformat_open_input(&amp;m_pAVFormatContext, m_filePath.toStdString().c_str(), nullptr, nullptr);
if (result &lt; 0) {
    char errbuf[64];
    av_strerror(result, errbuf, sizeof(errbuf));
    qDebug(&quot;open stream failed: %s&quot;, errbuf);
    return false;
}
</code></pre>
<h2 id="ffmpeg-实现"><a href="#ffmpeg-实现" class="headerlink" title="ffmpeg 实现"></a>ffmpeg 实现</h2><p>相关实现代码在<code>FFmpeg/libavcodec/gdigrab.c</code>。通过调用<code>gdigrab_read_header()</code>完成初始化，<code>gdigrab_read_packet()</code>完成实际的截图。</p>
<h3 id="gdigrab-read-header"><a href="#gdigrab-read-header" class="headerlink" title="gdigrab_read_header"></a>gdigrab_read_header</h3><ol>
<li>确定窗口的句柄 hwnd。如果指定了 title 的话，调用 FindWindow()获取 hwnd；如果指定了 desktop，则设定 hwnd 为 NULL</li>
<li>确定抓屏的矩形区域。如果抓取指定窗口，则通过 GetClientRect()函数；否则就抓取整个屏幕</li>
<li>调用 GDI 的 API 完成抓屏的一些初始化工作。包括：<br>a)通过 GetDC()获得某个窗口句柄的 HDC<br>b)通过 CreateCompatibleDC()创建一个与指定设备兼容的 HDC<br>c)通过 CreateDIBSection()创建一个设备无关位图 HBITMAP<br>d)通过 SelectObject()绑定 HBITMAP 和 HDC</li>
<li>通过 avformat_new_stream()创建一个 AVStream</li>
<li>将初始化时候的一些参数保存至 GDIGrab 的上下文结构体</li>
</ol>
<h3 id="gdigrab-read-packet"><a href="#gdigrab-read-packet" class="headerlink" title="gdigrab_read_packet"></a>gdigrab_read_packet</h3><ol>
<li>从 GDIGrab 上下文结构体读取初始化时候设定的参数</li>
<li>根据帧率参数进行延时</li>
<li>通过 av_new_packet()新建一个 AVPacket</li>
<li>通过 BitBlt()完成抓屏功能</li>
<li>如果需要画鼠标指针的话，调用 paint_mouse_pointer()</li>
<li>拷贝图像内容至 AVPacket 的 data</li>
</ol>
<h3 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h3><pre><code class="C++">/**
 * Initializes the gdi grab device demuxer (public device demuxer API).
 *
 * @param s1 Context from avformat core
 * @return AVERROR_IO error, 0 success
 */
static int
gdigrab_read_header(AVFormatContext *s1)
{
    struct gdigrab *gdigrab = s1-&gt;priv_data;

    HWND hwnd;
    HDC source_hdc = NULL;
    HDC dest_hdc   = NULL;
    BITMAPINFO bmi;
    HBITMAP hbmp   = NULL;
    void *buffer   = NULL;

    const char *filename = s1-&gt;url;
    const char *name     = NULL;
    AVStream   *st       = NULL;

    int bpp;
    int horzres;
    int vertres;
    int desktophorzres;
    int desktopvertres;
    RECT virtual_rect;
    RECT clip_rect;
    BITMAP bmp;
    int ret;

    if (!strncmp(filename, &quot;title=&quot;, 6)) {
        name = filename + 6;
        hwnd = FindWindow(NULL, name);
        if (!hwnd) {
            av_log(s1, AV_LOG_ERROR,
                   &quot;Can&#39;t find window &#39;%s&#39;, aborting.\n&quot;, name);
            ret = AVERROR(EIO);
            goto error;
        }
        if (gdigrab-&gt;show_region) {
            av_log(s1, AV_LOG_WARNING,
                    &quot;Can&#39;t show region when grabbing a window.\n&quot;);
            gdigrab-&gt;show_region = 0;
        }
    } else if (!strcmp(filename, &quot;desktop&quot;)) {
        hwnd = NULL;
    } else {
        av_log(s1, AV_LOG_ERROR,
               &quot;Please use \&quot;desktop\&quot; or \&quot;title=&lt;windowname&gt;\&quot; to specify your target.\n&quot;);
        ret = AVERROR(EIO);
        goto error;
    }

    /* This will get the device context for the selected window, or if
     * none, the primary screen */
    source_hdc = GetDC(hwnd);
    if (!source_hdc) {
        WIN32_API_ERROR(&quot;Couldn&#39;t get window device context&quot;);
        ret = AVERROR(EIO);
        goto error;
    }
    bpp = GetDeviceCaps(source_hdc, BITSPIXEL);

    horzres = GetDeviceCaps(source_hdc, HORZRES);
    vertres = GetDeviceCaps(source_hdc, VERTRES);
    desktophorzres = GetDeviceCaps(source_hdc, DESKTOPHORZRES);
    desktopvertres = GetDeviceCaps(source_hdc, DESKTOPVERTRES);

    if (hwnd) {
        GetClientRect(hwnd, &amp;virtual_rect);
        /* window -- get the right height and width for scaling DPI */
        virtual_rect.left   = virtual_rect.left   * desktophorzres / horzres;
        virtual_rect.right  = virtual_rect.right  * desktophorzres / horzres;
        virtual_rect.top    = virtual_rect.top    * desktopvertres / vertres;
        virtual_rect.bottom = virtual_rect.bottom * desktopvertres / vertres;
    } else {
        /* desktop -- get the right height and width for scaling DPI */
        virtual_rect.left = GetSystemMetrics(SM_XVIRTUALSCREEN);
        virtual_rect.top = GetSystemMetrics(SM_YVIRTUALSCREEN);
        virtual_rect.right = (virtual_rect.left + GetSystemMetrics(SM_CXVIRTUALSCREEN)) * desktophorzres / horzres;
        virtual_rect.bottom = (virtual_rect.top + GetSystemMetrics(SM_CYVIRTUALSCREEN)) * desktopvertres / vertres;
    }

    /* If no width or height set, use full screen/window area */
    if (!gdigrab-&gt;width || !gdigrab-&gt;height) {
        clip_rect.left = virtual_rect.left;
        clip_rect.top = virtual_rect.top;
        clip_rect.right = virtual_rect.right;
        clip_rect.bottom = virtual_rect.bottom;
    } else {
        clip_rect.left = gdigrab-&gt;offset_x;
        clip_rect.top = gdigrab-&gt;offset_y;
        clip_rect.right = gdigrab-&gt;width + gdigrab-&gt;offset_x;
        clip_rect.bottom = gdigrab-&gt;height + gdigrab-&gt;offset_y;
    }

    if (clip_rect.left &lt; virtual_rect.left ||
            clip_rect.top &lt; virtual_rect.top ||
            clip_rect.right &gt; virtual_rect.right ||
            clip_rect.bottom &gt; virtual_rect.bottom) {
            av_log(s1, AV_LOG_ERROR,
                    &quot;Capture area (%li,%li),(%li,%li) extends outside window area (%li,%li),(%li,%li)&quot;,
                    clip_rect.left, clip_rect.top,
                    clip_rect.right, clip_rect.bottom,
                    virtual_rect.left, virtual_rect.top,
                    virtual_rect.right, virtual_rect.bottom);
            ret = AVERROR(EIO);
            goto error;
    }


    if (name) {
        av_log(s1, AV_LOG_INFO,
               &quot;Found window %s, capturing %lix%lix%i at (%li,%li)\n&quot;,
               name,
               clip_rect.right - clip_rect.left,
               clip_rect.bottom - clip_rect.top,
               bpp, clip_rect.left, clip_rect.top);
    } else {
        av_log(s1, AV_LOG_INFO,
               &quot;Capturing whole desktop as %lix%lix%i at (%li,%li)\n&quot;,
               clip_rect.right - clip_rect.left,
               clip_rect.bottom - clip_rect.top,
               bpp, clip_rect.left, clip_rect.top);
    }

    if (clip_rect.right - clip_rect.left &lt;= 0 ||
            clip_rect.bottom - clip_rect.top &lt;= 0 || bpp%8) {
        av_log(s1, AV_LOG_ERROR, &quot;Invalid properties, aborting\n&quot;);
        ret = AVERROR(EIO);
        goto error;
    }

    dest_hdc = CreateCompatibleDC(source_hdc);
    if (!dest_hdc) {
        WIN32_API_ERROR(&quot;Screen DC CreateCompatibleDC&quot;);
        ret = AVERROR(EIO);
        goto error;
    }

    /* Create a DIB and select it into the dest_hdc */
    bmi.bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth         = clip_rect.right - clip_rect.left;
    bmi.bmiHeader.biHeight        = -(clip_rect.bottom - clip_rect.top);
    bmi.bmiHeader.biPlanes        = 1;
    bmi.bmiHeader.biBitCount      = bpp;
    bmi.bmiHeader.biCompression   = BI_RGB;
    bmi.bmiHeader.biSizeImage     = 0;
    bmi.bmiHeader.biXPelsPerMeter = 0;
    bmi.bmiHeader.biYPelsPerMeter = 0;
    bmi.bmiHeader.biClrUsed       = 0;
    bmi.bmiHeader.biClrImportant  = 0;
    hbmp = CreateDIBSection(dest_hdc, &amp;bmi, DIB_RGB_COLORS,
            &amp;buffer, NULL, 0);
    if (!hbmp) {
        WIN32_API_ERROR(&quot;Creating DIB Section&quot;);
        ret = AVERROR(EIO);
        goto error;
    }

    if (!SelectObject(dest_hdc, hbmp)) {
        WIN32_API_ERROR(&quot;SelectObject&quot;);
        ret = AVERROR(EIO);
        goto error;
    }

    /* Get info from the bitmap */
    GetObject(hbmp, sizeof(BITMAP), &amp;bmp);

    st = avformat_new_stream(s1, NULL);
    if (!st) {
        ret = AVERROR(ENOMEM);
        goto error;
    }
    avpriv_set_pts_info(st, 64, 1, 1000000); /* 64 bits pts in us */

    gdigrab-&gt;frame_size  = bmp.bmWidthBytes * bmp.bmHeight * bmp.bmPlanes;
    gdigrab-&gt;header_size = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) +
                           (bpp &lt;= 8 ? (1 &lt;&lt; bpp) : 0) * sizeof(RGBQUAD) /* palette size */;
    gdigrab-&gt;time_base   = av_inv_q(gdigrab-&gt;framerate);
    gdigrab-&gt;time_frame  = av_gettime() / av_q2d(gdigrab-&gt;time_base);

    gdigrab-&gt;hwnd       = hwnd;
    gdigrab-&gt;source_hdc = source_hdc;
    gdigrab-&gt;dest_hdc   = dest_hdc;
    gdigrab-&gt;hbmp       = hbmp;
    gdigrab-&gt;bmi        = bmi;
    gdigrab-&gt;buffer     = buffer;
    gdigrab-&gt;clip_rect  = clip_rect;

    gdigrab-&gt;cursor_error_printed = 0;

    if (gdigrab-&gt;show_region) {
        if (gdigrab_region_wnd_init(s1, gdigrab)) {
            ret = AVERROR(EIO);
            goto error;
        }
    }

    st-&gt;avg_frame_rate = av_inv_q(gdigrab-&gt;time_base);

    st-&gt;codecpar-&gt;codec_type = AVMEDIA_TYPE_VIDEO;
    st-&gt;codecpar-&gt;codec_id   = AV_CODEC_ID_BMP;
    st-&gt;codecpar-&gt;bit_rate   = (gdigrab-&gt;header_size + gdigrab-&gt;frame_size) * 1/av_q2d(gdigrab-&gt;time_base) * 8;

    return 0;

error:
    if (source_hdc)
        ReleaseDC(hwnd, source_hdc);
    if (dest_hdc)
        DeleteDC(dest_hdc);
    if (hbmp)
        DeleteObject(hbmp);
    if (source_hdc)
        DeleteDC(source_hdc);
    return ret;
}
...
/**
 * Grabs a frame from gdi (public device demuxer API).
 *
 * @param s1 Context from avformat core
 * @param pkt Packet holding the grabbed frame
 * @return frame size in bytes
 */
static int gdigrab_read_packet(AVFormatContext *s1, AVPacket *pkt)
{
    struct gdigrab *gdigrab = s1-&gt;priv_data;

    HDC        dest_hdc   = gdigrab-&gt;dest_hdc;
    HDC        source_hdc = gdigrab-&gt;source_hdc;
    RECT       clip_rect  = gdigrab-&gt;clip_rect;
    AVRational time_base  = gdigrab-&gt;time_base;
    int64_t    time_frame = gdigrab-&gt;time_frame;

    BITMAPFILEHEADER bfh;
    int file_size = gdigrab-&gt;header_size + gdigrab-&gt;frame_size;

    int64_t curtime, delay;

    /* Calculate the time of the next frame */
    time_frame += INT64_C(1000000);

    /* Run Window message processing queue */
    if (gdigrab-&gt;show_region)
        gdigrab_region_wnd_update(s1, gdigrab);

    /* wait based on the frame rate */
    for (;;) {
        curtime = av_gettime();
        delay = time_frame * av_q2d(time_base) - curtime;
        if (delay &lt;= 0) {
            if (delay &lt; INT64_C(-1000000) * av_q2d(time_base)) {
                time_frame += INT64_C(1000000);
            }
            break;
        }
        if (s1-&gt;flags &amp; AVFMT_FLAG_NONBLOCK) {
            return AVERROR(EAGAIN);
        } else {
            av_usleep(delay);
        }
    }

    if (av_new_packet(pkt, file_size) &lt; 0)
        return AVERROR(ENOMEM);
    pkt-&gt;pts = curtime;

    /* Blit screen grab */
    if (!BitBlt(dest_hdc, 0, 0,
                clip_rect.right - clip_rect.left,
                clip_rect.bottom - clip_rect.top,
                source_hdc,
                clip_rect.left, clip_rect.top, SRCCOPY | CAPTUREBLT)) {
        WIN32_API_ERROR(&quot;Failed to capture image&quot;);
        return AVERROR(EIO);
    }
    if (gdigrab-&gt;draw_mouse)
        paint_mouse_pointer(s1, gdigrab);

    /* Copy bits to packet data */

    bfh.bfType = 0x4d42; /* &quot;BM&quot; in little-endian */
    bfh.bfSize = file_size;
    bfh.bfReserved1 = 0;
    bfh.bfReserved2 = 0;
    bfh.bfOffBits = gdigrab-&gt;header_size;

    memcpy(pkt-&gt;data, &amp;bfh, sizeof(bfh));

    memcpy(pkt-&gt;data + sizeof(bfh), &amp;gdigrab-&gt;bmi.bmiHeader, sizeof(gdigrab-&gt;bmi.bmiHeader));

    if (gdigrab-&gt;bmi.bmiHeader.biBitCount &lt;= 8)
        GetDIBColorTable(dest_hdc, 0, 1 &lt;&lt; gdigrab-&gt;bmi.bmiHeader.biBitCount,
                (RGBQUAD *) (pkt-&gt;data + sizeof(bfh) + sizeof(gdigrab-&gt;bmi.bmiHeader)));

    memcpy(pkt-&gt;data + gdigrab-&gt;header_size, gdigrab-&gt;buffer, gdigrab-&gt;frame_size);

    gdigrab-&gt;time_frame = time_frame;

    return gdigrab-&gt;header_size + gdigrab-&gt;frame_size;
}
</code></pre>
<h1 id="DSHOW"><a href="#DSHOW" class="headerlink" title="DSHOW"></a>DSHOW</h1><p>DirectShow 是 windows 上基于 COM 的流媒体处理的开发包，与 DirectX 开发包一起发布。使用 DSHOW 在捕获的设备上有更多的选择，比如 USB 摄像机、声卡设备等注册了的设备都可以作为输入源</p>
<h2 id="ffmpeg-调用-1"><a href="#ffmpeg-调用-1" class="headerlink" title="ffmpeg 调用"></a>ffmpeg 调用</h2><p>ffmpeg 封装了 DSHOW 截图的相关的函数，调用和 GDI 截图的区别就是初始化的参数不同。</p>
<pre><code class="C++">//DSHOW截屏初始化
m_pFormatContext = avformat_alloc_context();
if(nullptr == m_pFormatContext) {
    qDebug(&quot;avformat_alloc_context failed&quot;);
    break;
}

AVInputFormat * pInputFormat = av_find_input_format(&quot;dshow&quot;);
if(nullptr == pInputFormat) {
    qDebug(&quot;av_find_input_format failed&quot;);
    break;
}

AVDictionary * options = nullptr;
if(0 != avformat_open_input(&amp;m_pFormatContext, &quot;video=screen-capture-recorder&quot;, pInputFormat, &amp;options)) {
    qDebug(&quot;avformat_open_input failed&quot;);
    break;
}
</code></pre>
<h2 id="ffmpeg-实现-1"><a href="#ffmpeg-实现-1" class="headerlink" title="ffmpeg 实现"></a>ffmpeg 实现</h2><p>相关实现代码在<code>FFmpeg/libavcodec/dshow.c</code>。通过调用<code>dshow_read_header()</code>完成初始化，<code>dshow_read_packet()</code>完成实际的截图。</p>
<h2 id="dshow-read-header"><a href="#dshow-read-header" class="headerlink" title="dshow_read_header"></a>dshow_read_header</h2><ol>
<li>判断输入参数、输入格式、帧率是否正确</li>
<li>通过 CoCreateInstance() 创建 IGraphBuilder 对应的 Com 对象</li>
<li>在设备列表中检索指定设备</li>
<li>根据音频、视频设备分别设置参数以及打开对应设备</li>
<li>创建 IGraphBuilder 的 Event、Mutex</li>
</ol>
<h2 id="dshow-read-packet"><a href="#dshow-read-packet" class="headerlink" title="dshow_read_packet"></a>dshow_read_packet</h2><ol>
<li>事件循环，Mutex 触发后开始解析</li>
<li>取出 priv_data 中的 packet 并处理数据</li>
<li>检查 DShow 的 media event</li>
</ol>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code class="C++">static int dshow_read_header(AVFormatContext *avctx)
{
    struct dshow_ctx *ctx = avctx-&gt;priv_data;
    IGraphBuilder *graph = NULL;
    ICreateDevEnum *devenum = NULL;
    IMediaControl *control = NULL;
    IMediaEvent *media_event = NULL;
    HANDLE media_event_handle;
    HANDLE proc;
    int ret = AVERROR(EIO);
    int r;

    CoInitialize(0);

    if (!ctx-&gt;list_devices &amp;&amp; !parse_device_name(avctx)) {
        av_log(avctx, AV_LOG_ERROR, &quot;Malformed dshow input string.\n&quot;);
        goto error;
    }

    ctx-&gt;video_codec_id = avctx-&gt;video_codec_id ? avctx-&gt;video_codec_id
                                                : AV_CODEC_ID_RAWVIDEO;
    if (ctx-&gt;pixel_format != AV_PIX_FMT_NONE) {
        if (ctx-&gt;video_codec_id != AV_CODEC_ID_RAWVIDEO) {
            av_log(avctx, AV_LOG_ERROR, &quot;Pixel format may only be set when &quot;
                              &quot;video codec is not set or set to rawvideo\n&quot;);
            ret = AVERROR(EINVAL);
            goto error;
        }
    }
    if (ctx-&gt;framerate) {
        r = av_parse_video_rate(&amp;ctx-&gt;requested_framerate, ctx-&gt;framerate);
        if (r &lt; 0) {
            av_log(avctx, AV_LOG_ERROR, &quot;Could not parse framerate &#39;%s&#39;.\n&quot;, ctx-&gt;framerate);
            goto error;
        }
    }

    r = CoCreateInstance(&amp;CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER,
                         &amp;IID_IGraphBuilder, (void **) &amp;graph);
    if (r != S_OK) {
        av_log(avctx, AV_LOG_ERROR, &quot;Could not create capture graph.\n&quot;);
        goto error;
    }
    ctx-&gt;graph = graph;

    r = CoCreateInstance(&amp;CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
                         &amp;IID_ICreateDevEnum, (void **) &amp;devenum);
    if (r != S_OK) {
        av_log(avctx, AV_LOG_ERROR, &quot;Could not enumerate system devices.\n&quot;);
        goto error;
    }

    if (ctx-&gt;list_devices) {
        av_log(avctx, AV_LOG_INFO, &quot;DirectShow video devices (some may be both video and audio devices)\n&quot;);
        dshow_cycle_devices(avctx, devenum, VideoDevice, VideoSourceDevice, NULL, NULL);
        av_log(avctx, AV_LOG_INFO, &quot;DirectShow audio devices\n&quot;);
        dshow_cycle_devices(avctx, devenum, AudioDevice, AudioSourceDevice, NULL, NULL);
        ret = AVERROR_EXIT;
        goto error;
    }
    if (ctx-&gt;list_options) {
        if (ctx-&gt;device_name[VideoDevice])
            if ((r = dshow_list_device_options(avctx, devenum, VideoDevice, VideoSourceDevice))) {
                ret = r;
                goto error;
            }
        if (ctx-&gt;device_name[AudioDevice]) {
            if (dshow_list_device_options(avctx, devenum, AudioDevice, AudioSourceDevice)) {
                /* show audio options from combined video+audio sources as fallback */
                if ((r = dshow_list_device_options(avctx, devenum, AudioDevice, VideoSourceDevice))) {
                    ret = r;
                    goto error;
                }
            }
        }
    }
    if (ctx-&gt;device_name[VideoDevice]) {
        if ((r = dshow_open_device(avctx, devenum, VideoDevice, VideoSourceDevice)) &lt; 0 ||
            (r = dshow_add_device(avctx, VideoDevice)) &lt; 0) {
            ret = r;
            goto error;
        }
    }
    if (ctx-&gt;device_name[AudioDevice]) {
        if ((r = dshow_open_device(avctx, devenum, AudioDevice, AudioSourceDevice)) &lt; 0 ||
            (r = dshow_add_device(avctx, AudioDevice)) &lt; 0) {
            av_log(avctx, AV_LOG_INFO, &quot;Searching for audio device within video devices for %s\n&quot;, ctx-&gt;device_name[AudioDevice]);
            /* see if there&#39;s a video source with an audio pin with the given audio name */
            if ((r = dshow_open_device(avctx, devenum, AudioDevice, VideoSourceDevice)) &lt; 0 ||
                (r = dshow_add_device(avctx, AudioDevice)) &lt; 0) {
                ret = r;
                goto error;
            }
        }
    }
    if (ctx-&gt;list_options) {
        /* allow it to list crossbar options in dshow_open_device */
        ret = AVERROR_EXIT;
        goto error;
    }
    ctx-&gt;curbufsize[0] = 0;
    ctx-&gt;curbufsize[1] = 0;
    ctx-&gt;mutex = CreateMutex(NULL, 0, NULL);
    if (!ctx-&gt;mutex) {
        av_log(avctx, AV_LOG_ERROR, &quot;Could not create Mutex\n&quot;);
        goto error;
    }
    ctx-&gt;event[1] = CreateEvent(NULL, 1, 0, NULL);
    if (!ctx-&gt;event[1]) {
        av_log(avctx, AV_LOG_ERROR, &quot;Could not create Event\n&quot;);
        goto error;
    }

    r = IGraphBuilder_QueryInterface(graph, &amp;IID_IMediaControl, (void **) &amp;control);
    if (r != S_OK) {
        av_log(avctx, AV_LOG_ERROR, &quot;Could not get media control.\n&quot;);
        goto error;
    }
    ctx-&gt;control = control;

    r = IGraphBuilder_QueryInterface(graph, &amp;IID_IMediaEvent, (void **) &amp;media_event);
    if (r != S_OK) {
        av_log(avctx, AV_LOG_ERROR, &quot;Could not get media event.\n&quot;);
        goto error;
    }
    ctx-&gt;media_event = media_event;

    r = IMediaEvent_GetEventHandle(media_event, (void *) &amp;media_event_handle);
    if (r != S_OK) {
        av_log(avctx, AV_LOG_ERROR, &quot;Could not get media event handle.\n&quot;);
        goto error;
    }
    proc = GetCurrentProcess();
    r = DuplicateHandle(proc, media_event_handle, proc, &amp;ctx-&gt;event[0],
                        0, 0, DUPLICATE_SAME_ACCESS);
    if (!r) {
        av_log(avctx, AV_LOG_ERROR, &quot;Could not duplicate media event handle.\n&quot;);
        goto error;
    }

    r = IMediaControl_Run(control);
    if (r == S_FALSE) {
        OAFilterState pfs;
        r = IMediaControl_GetState(control, 0, &amp;pfs);
    }
    if (r != S_OK) {
        av_log(avctx, AV_LOG_ERROR, &quot;Could not run graph (sometimes caused by a device already in use by other application)\n&quot;);
        goto error;
    }

    ret = 0;

error:

    if (devenum)
        ICreateDevEnum_Release(devenum);

    if (ret &lt; 0)
        dshow_read_close(avctx);

    return ret;
}
...

static int dshow_read_packet(AVFormatContext *s, AVPacket *pkt)
{
    struct dshow_ctx *ctx = s-&gt;priv_data;
    AVPacketList *pktl = NULL;

    while (!ctx-&gt;eof &amp;&amp; !pktl) {
        WaitForSingleObject(ctx-&gt;mutex, INFINITE);
        pktl = ctx-&gt;pktl;
        if (pktl) {
            *pkt = pktl-&gt;pkt;
            ctx-&gt;pktl = ctx-&gt;pktl-&gt;next;
            av_free(pktl);
            ctx-&gt;curbufsize[pkt-&gt;stream_index] -= pkt-&gt;size;
        }
        ResetEvent(ctx-&gt;event[1]);
        ReleaseMutex(ctx-&gt;mutex);
        if (!pktl) {
            if (dshow_check_event_queue(ctx-&gt;media_event) &lt; 0) {
                ctx-&gt;eof = 1;
            } else if (s-&gt;flags &amp; AVFMT_FLAG_NONBLOCK) {
                return AVERROR(EAGAIN);
            } else {
                WaitForMultipleObjects(2, ctx-&gt;event, 0, INFINITE);
            }
        }
    }

    return ctx-&gt;eof ? AVERROR(EIO) : pkt-&gt;size;
}
</code></pre>
<h1 id="DXGI"><a href="#DXGI" class="headerlink" title="DXGI"></a>DXGI</h1><p>windows 8.1 以上的系统，则实现了一个 DXGI，集成在 DirectX 之中，是 DirectX 的一个子功能。DXGI 效率最高，不过对系统要求高。初始化都是固定的格式就是比较麻烦，<a href="https://github.com/microsoftarchive/msdn-code-gallery-microsoft/tree/master/Official%20Windows%20Platform%20Sample/DXGI%20desktop%20duplication%20sample" target="_blank" rel="noopener">可以看看微软官方 demo</a>，创建和查询各种接口，最终获取到 IDXGIOutputDuplication 接口。截屏的时候，使用 AcquireNextFrame() 函数获取当前桌面图像， GetFrameDirtyRects() 用来获取发生了变化的矩形区域。</p>
<h2 id="ffmpeg-调用-2"><a href="#ffmpeg-调用-2" class="headerlink" title="ffmpeg 调用"></a>ffmpeg 调用</h2><p>ffmpeg 没有对应的接口，需要自己拿到 RGB 数据后封装成 AVFrame 给后续的编码环节使用。</p>
<pre><code class="C++">//初始化略
...

//创建对应的AVFrame
m_pFrame = av_frame_alloc();
if(nullptr == m_pFrame) return;
m_pFrame-&gt;width = m_srcWidth;
m_pFrame-&gt;height = m_srcHeight;
m_pFrame-&gt;format = AV_PIX_FMT_BGRA;
if(0 != av_frame_get_buffer(m_pFrame, 0)) return;

...
//将DXGI拿到的数据存到AVFrame
m_pFrame-&gt;data[0] = directx.buffer;
</code></pre>
</the>]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
            <tag> ffmpeg </tag>
            
            <tag> GDI </tag>
            
            <tag> DSHOW </tag>
            
            <tag> DXGI </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[golang 和 C++ 的内存对齐]]></title>
      <url>https://longxuan.ren/2020/05/20/Go-C-Memory-Align/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>golang 和 C++的内存对齐，基本一致，记住规则和对应类型的 size 即可 <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="内存对齐规则"><a href="#内存对齐规则" class="headerlink" title="内存对齐规则"></a>内存对齐规则</h2><ol>
<li>有效对齐值是固定值和结构体中最长数据类型长度中较小的那个。固定值系统默认为 32 位是 4, 64 位是 8，<code>#pragma pack(n)</code>设置了则是对应的 n。</li>
<li>结构体第一个成员的 offset 为 0，以后每个成员相对于结构体首地址的 offset 都是 <code>min{该成员大小, 有效对齐值}</code>的整数倍，如有需要编译器会在成员之间加上填充字节。</li>
<li>结构体的总大小为 有效对齐值 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。</li>
</ol>
<h2 id="C-内存对齐"><a href="#C-内存对齐" class="headerlink" title="C++内存对齐"></a>C++内存对齐</h2><h3 id="常见类型占用内存大小"><a href="#常见类型占用内存大小" class="headerlink" title="常见类型占用内存大小"></a>常见类型占用内存大小</h3><table>
<thead>
<tr>
<th>类型/编译器</th>
<th>16 位编译器</th>
<th>32 位编译器</th>
<th>64 位编译器</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>char</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>char*</td>
<td>2</td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td>int</td>
<td>2</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>long long</td>
<td>8</td>
<td>8</td>
<td>8</td>
</tr>
</tbody>
</table>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><pre><code class="C++">#include &lt;iostream&gt;
#include &lt;stdint.h&gt;
using namespace std;
// #pragma pack(4)
class Part1 {
    bool a;
    int32_t b;
    int8_t c;
    int64_t d;
    char e;
};

class Part2 {
    char e;
    int8_t c;
    bool a;
    int32_t b;
    int64_t d;
};

int main(void){
    Part1 part1;
    Part2 part2;

    printf(&quot;part1 size: %zu\n&quot;, sizeof(part1));
    printf(&quot;part2 size: %zu\n&quot;, sizeof(part2));
}
// output:
// part1 size: 32,   if pack(4): part1 size: 24
// part2 size: 16
</code></pre>
<h2 id="golang-内存对齐"><a href="#golang-内存对齐" class="headerlink" title="golang 内存对齐"></a>golang 内存对齐</h2><h3 id="常见类型占用内存大小-1"><a href="#常见类型占用内存大小-1" class="headerlink" title="常见类型占用内存大小"></a>常见类型占用内存大小</h3><table>
<thead>
<tr>
<th>类型/编译器</th>
<th>64 位编译器</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td>1</td>
</tr>
<tr>
<td>byte</td>
<td>1</td>
</tr>
<tr>
<td>uintptr</td>
<td>8</td>
</tr>
<tr>
<td>int</td>
<td>8</td>
</tr>
<tr>
<td>float64</td>
<td>8</td>
</tr>
<tr>
<td>string</td>
<td>16</td>
</tr>
</tbody>
</table>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><pre><code class="go">package main
import (
    &quot;fmt&quot;
    &quot;unsafe&quot;
)

type Part1 struct {
    a bool
    b int32
    c int8
    d int64
    e byte
}

type Part2 struct {
    e byte
    c int8
    a bool
    b int32
    d int64
}

func main() {
    part1 := Part1{}
    part2 := Part2{}

    fmt.Printf(&quot;part1 size: %d, align: %d\n&quot;, unsafe.Sizeof(part1), unsafe.Alignof(part1))
    fmt.Printf(&quot;part2 size: %d, align: %d\n&quot;, unsafe.Sizeof(part2), unsafe.Alignof(part2))
}
// part1 size: 32, align: 8
// part2 size: 16, align: 8
</code></pre>
<h2 id="例子分析"><a href="#例子分析" class="headerlink" title="例子分析"></a>例子分析</h2><p>仅讨对齐固定值为 8 时 Part1 的情况，例子中的 a,b,c,d,e 占用大小分别为 1,4,1,8,1。填充字节用 0 表示，|之间表示 8 字节空间：</p>
<ol>
<li>a 偏移为 0，|a…</li>
<li>b 偏移为 4 的整数倍，|a000b|…</li>
<li>c 偏移为 1 的整数倍，|a000b|c…</li>
<li>d 偏移为 8 的整数倍，|a000b|c0000000|d|…</li>
<li>e 偏移为 1 的整数倍，|a000b|c0000000|d|e…</li>
<li>整个结构体对齐，补齐为 8 的整数倍，|a000b|c0000000|d|e0000000|</li>
<li>得出总大小为 32</li>
</ol>
</the>]]></content>
      
        <categories>
            
            <category> go </category>
            
        </categories>
        
        
        <tags>
            
            <tag> go </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[golang学习--slice]]></title>
      <url>https://longxuan.ren/2020/05/12/Go-slice/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>针对切片的理解，通过几个例子来掌握切片相关内容<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="切片定义"><a href="#切片定义" class="headerlink" title="切片定义"></a>切片定义</h2><p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。切片是一个引用类型，它的内部结构包含地址、长度和容量。切片一般用于快速地操作一块数据集合。</p>
<h2 id="数组与切片"><a href="#数组与切片" class="headerlink" title="数组与切片"></a>数组与切片</h2><p>切片的数据实际是通过数组来保存的，每个切片都有三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。<br>举个栗子，底层数组 a := [8]int{0, 1, 2, 3, 4, 5, 6, 7}；</p>
<ul>
<li><p>切片 s1 := a[:5]，切片和数组对应关系：<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Go-slice-2020-05-12-15-23-13.png" alt="Go-slice-2020-05-12-15-23-13"></p>
</li>
<li><p>切片 s2 := a[3:6]，切片和数组对应关系：<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Go-slice-2020-05-12-15-44-43.png" alt="Go-slice-2020-05-12-15-44-43"></p>
</li>
</ul>
<h2 id="指向同一个底层数组的切片修改值"><a href="#指向同一个底层数组的切片修改值" class="headerlink" title="指向同一个底层数组的切片修改值"></a>指向同一个底层数组的切片修改值</h2><p>切片是指向底层数组的引用类型，指向同一个底层数组的切片底层数据存放都是在同一个位置，修改某个切片会影响到在同一个范围的切片</p>
<pre><code class="go">import (
    &quot;fmt&quot;
    &quot;testing&quot;
)

func TestSliceShareMemory(t *testing.T) {
    year := []string{&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;}
    Q2 := year[3:6]
    t.Log(Q2, len(Q2), cap(Q2))
    summer := year[5:8]
    t.Log(summer, len(summer), cap(summer))
    summer[0] = &quot;Unkonw&quot;
    t.Log(Q2)
    t.Log(year)
}
// === RUN   TestSliceShareMemory
//     TestSliceShareMemory: slice_test.go:36: [Apr May Jun] 3 9
//     TestSliceShareMemory: slice_test.go:38: [Jun Jul Aug] 3 7
//     TestSliceShareMemory: slice_test.go:40: [Apr May Unkonw]
//     TestSliceShareMemory: slice_test.go:41: [Jan Feb Mar Apr May Unkonw Jul Aug Sep Oct Nov Dec]
// --- PASS: TestSliceShareMemory (0.00s)
// PASS
</code></pre>
<h2 id="切片表达式"><a href="#切片表达式" class="headerlink" title="切片表达式"></a>切片表达式</h2><p>切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。它有两种变体：一种指定 low 和 high 两个索引界限值的简单的形式，另一种是除了 low 和 high 索引界限值外还指定容量的完整的形式：</p>
<ol>
<li>切片 len()是可访问长度，容量 cap()是总空间大小。通过数组生成的切片， len 为首尾索引之差，cap 为从切片首索引到数组末尾长度</li>
<li>切片 s[low:high:max]，从切片 s 的 low 处到 high 处所获得的切片，len=high-low，cap=max-low</li>
</ol>
<pre><code class="go">func TestSliceExpression(t *testing.T) {
    a := [5]int{1, 2, 3, 4, 5}
    // b := a[1:3:7]
    b := a[1:3:5]
    fmt.Printf(&quot;b:%v len(b):%v cap(b):%v\n&quot;, b, len(b), cap(b))
}
// === RUN   TestSliceExpression
// b:[2 3] len(b):2 cap(b):4
// --- PASS: TestSliceExpression (0.00s)
// PASS
</code></pre>
<h2 id="切片不能比较"><a href="#切片不能比较" class="headerlink" title="切片不能比较"></a>切片不能比较</h2><p>两个切片不能直接比较，会报错:</p>
<pre><code class="go">func TestSliceCompare(t *testing.T) {
    a := []int{1, 2, 3, 4}
    b := []int{1, 2, 3, 4}
    if a == b {
        t.Log(&quot;a==b&quot;)
    }
}
// invalid operation: a == b (slice can only be compared to nil)
// FAIL    go_learn/go_test/slice_test [build failed]
// FAIL
</code></pre>
<h2 id="切片的-append"><a href="#切片的-append" class="headerlink" title="切片的 append"></a>切片的 append</h2><p>切片通过 append()添加元素时，未超过 newcap 时底层数组地址不变，超过的话底层数组会申请新的内存地址。新申请的容量大小计算分成了两步，有关 append 的源码在<code>$GOROOT/src/runtime/slice.go</code>，可以自己去分析。</p>
<h3 id="计算逻辑-newcap"><a href="#计算逻辑-newcap" class="headerlink" title="计算逻辑 newcap"></a>计算逻辑 newcap</h3><ol>
<li>new cap &gt; old * 2 直接申请新容量大小;</li>
<li>小于 2 倍时，len<1024 翻倍，len>1024 加上 1/4</1024></li>
</ol>
<pre><code class="go">//$GOROOT/src/runtime/slice.go
newcap := old.cap
doublecap := newcap + newcap
if cap &gt; doublecap {
  newcap = cap
} else {
  if old.len &lt; 1024 {
    newcap = doublecap
  } else {
    // Check 0 &lt; newcap to detect overflow
    // and prevent an infinite loop.
    for 0 &lt; newcap &amp;&amp; newcap &lt; cap {
      newcap += newcap / 4
    }
    // Set newcap to the requested cap when
    // the newcap calculation overflowed.
    if newcap &lt;= 0 {
      newcap = cap
    }
  }
}

//...略
lenmem = uintptr(old.len)
newlenmem = uintptr(cap)
capmem = roundupsize(uintptr(newcap))
overflow = uintptr(newcap) &gt; maxAlloc
newcap = int(capmem)
//...略
</code></pre>
<h3 id="实际申请内存大小"><a href="#实际申请内存大小" class="headerlink" title="实际申请内存大小"></a>实际申请内存大小</h3><p>上面先算了个逻辑上的 newcap，实际申请内存的时候，由于内存对齐的关系不会直接就用 newcap。上面的代码就是在算好了 newcap 后会调用<code>roundupsize()</code>得到实际的大小。</p>
<pre><code class="go">//$GOROOT/src/runtime/msize.go
// Returns size of the memory block that mallocgc will allocate if you ask for the size.
func roundupsize(size uintptr) uintptr {
    if size &lt; _MaxSmallSize {
        if size &lt;= smallSizeMax-8 {
            return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
        } else {
            return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
        }
    }
    if size+_PageSize &lt; size {
        return size
    }
    return alignUp(size, _PageSize)
}
</code></pre>
<p>在<code>roundupsize()</code>中的 class_to_size、size_to_class8 是存了具体大小的数组，根据传入的 newcap 来算出下标，拿到对应的大小值。这些数组在<code>//$GOROOT/src/runtime/sizeclasses.go</code>，这个文件又是<code>//$GOROOT/src/runtime/mksizeclasses.go.go</code>生成的，生成规则就先不去看了。</p>
<pre><code class="go">//$GOROOT/src/runtime/sizeclasses.go
// Code generated by mksizeclasses.go; DO NOT EDIT.
//go:generate go run mksizeclasses.go
var class_to_size = [_NumSizeClasses]uint16{0, 8, 16, 32, 48, 64, 80, 96, 112, 128 ...}

var size_to_class8 = [smallSizeMax/smallSizeDiv + 1]uint8{0, 1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25 ...}
</code></pre>
<p>了解了上面的内容之后就可以理解下面的几个例子了：</p>
<pre><code class="go">func TestSliceAppend(t *testing.T) {
    var a = make([]int, 5, 10)
    for i := 0; i &lt; 10; i++ {
        a = append(a, i)
        fmt.Printf(&quot;a ptr: %p\n&quot;, a)
    }
    fmt.Println(a)
}
// === RUN   TestSliceAppend
// a ptr: 0xc00000c320
// a ptr: 0xc00000c320
// a ptr: 0xc00000c320
// a ptr: 0xc00000c320
// a ptr: 0xc00000c320
// a ptr: 0xc0000100a0
// a ptr: 0xc0000100a0
// a ptr: 0xc0000100a0
// a ptr: 0xc0000100a0
// a ptr: 0xc0000100a0
// [0 0 0 0 0 0 1 2 3 4 5 6 7 8 9]
// --- PASS: TestSliceAppend (0.00s)
// PASS

func TestSliceAppend2(t *testing.T) {
    s := []int{1, 2, 3, 4}
    a := make([]int, 3, 6)
    b := append(a, 10)
    a[0] = 50
    fmt.Printf(&quot;a: %v\tptr: %p\tfirst: %v\n&quot;, a, a, a[0])
    fmt.Printf(&quot;b: %v\tptr: %p\tfirst: %v\n&quot;, b, b, b[0])

    b = append(a, s...)
    a[0] = 100
    fmt.Printf(&quot;a: %v\tptr: %p\tfirst: %v\n&quot;, a, a, a[0])
    fmt.Printf(&quot;b: %v\tptr: %p\tfirst: %v\n&quot;, b, b, b[0])
}
// === RUN   TestSliceAppend2
// a: [50 0 0]    ptr: 0xc00000a330    first: 50
// b: [50 0 0 10]    ptr: 0xc00000a330    first: 50
// a: [100 0 0]    ptr: 0xc00000a330    first: 100
// b: [50 0 0 1 2 3 4]    ptr: 0xc00001a4e0    first: 50
// --- PASS: TestSliceAppend2 (0.00s)
// PASS

func TestSliceAppend3(t *testing.T) {
    a1 := make([]int, 20)
    b1 := make([]int, 40)
    a1 = append(a1, b1...)
    fmt.Println(len(a1), cap(a1))

    a2 := make([]int, 20)
    b2 := make([]int, 42)
    a2 = append(a2, b2...)
    fmt.Println(len(a2), cap(a2))
}
// === RUN   TestSliceAppend3
// 60 60
// 62 64
// --- PASS: TestSliceAppend3 (0.00s)
// PASS
</code></pre>
<h2 id="切片元素删除"><a href="#切片元素删除" class="headerlink" title="切片元素删除"></a>切片元素删除</h2><p>在要删除的元素左右切两下：a1 = append(a1[:1], a1[2:]…)，删除其实是将所删元素后面的往前挪。</p>
<pre><code class="go">func TestSliceDelete(t *testing.T) {
    a := []int{30, 31, 32, 33, 34, 35, 36, 37}
    // 要删除索引为2的元素
    a = append(a[:2], a[3:]...)
    t.Log(a)
}
// === RUN   TestSliceDelete
//     TestSliceDelete: slice_test.go:98: [30 31 33 34 35 36 37]
// --- PASS: TestSliceDelete (0.00s)
// PASS
</code></pre>
<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><ul>
<li><a href="https://www.liwenzhou.com/posts/Go/06_slice/" target="_blank" rel="noopener">Go 语言基础之切片</a></li>
<li>golang 源码</li>
<li><a href="https://github.com/Longxr/go_learn/blob/master/go_test/slice_test/slice_test.go" target="_blank" rel="noopener">测试的几个例子</a></li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> go </category>
            
        </categories>
        
        
        <tags>
            
            <tag> go </tag>
            
            <tag> slice </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Go语言使用Qt开发界面]]></title>
      <url>https://longxuan.ren/2020/04/19/Go-Use-Qt/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>Go 语言跨平台，Qt 也跨平台，两个跨平台的框架/语言愉快地交织在了一起。我本应该获得了这种如梦一般的幸福时光才对。可是，为什么，会变成现在这样呢……（白学家梗） <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="Go-的-UI-库"><a href="#Go-的-UI-库" class="headerlink" title="Go 的 UI 库"></a>Go 的 UI 库</h2><p>Go 语言本身是没有 UI 库的，不过有许多第三方的库支持将 Go 语言绑定到其他 UI 库，比如 Qt、GTK。本文就介绍使用这个 Qt 绑定的库，<a href="https://github.com/therecipe/qt" target="_blank" rel="noopener">therecipe/qt</a>。</p>
<h2 id="环境搭建（windows）"><a href="#环境搭建（windows）" class="headerlink" title="环境搭建（windows）"></a>环境搭建（windows）</h2><p>非 windows 或者需要参数说明的可以参考官方的<a href="https://github.com/therecipe/qt/wiki" target="_blank" rel="noopener">wiki</a>、<a href="https://github.com/therecipe/qt/wiki/Installation-on-Windows" target="_blank" rel="noopener">windows 安装</a></p>
<h3 id="Qt-安装"><a href="#Qt-安装" class="headerlink" title="Qt 安装"></a>Qt 安装</h3><p>下载你需要的版本，<a href="http://download.qt.io/archive/qt/" target="_blank" rel="noopener">下载地址</a>。如果需要安装 VS 编译器什么的也可以参考下我之前的文章，<a href="https://longxuan.ren/2018/12/30/Qt5-12-0-VS2017-environment/">Qt5.12.0 + VS2017 环境搭建</a>。</p>
<h3 id="therecipe-qt-安装"><a href="#therecipe-qt-安装" class="headerlink" title="therecipe/qt 安装"></a>therecipe/qt 安装</h3><p>终端执行下面的命令:</p>
<pre><code class="shell"># Go的环境变量配置，配置过一次就不用在设置了
go env -w GO111MODULE=on
go env -w GOPROXY=https://goproxy.cn

# 下载therecipe/qt库
go get -v -tags=no_env github.com/therecipe/qt/cmd/...
</code></pre>
<h3 id="执行-qtsetup"><a href="#执行-qtsetup" class="headerlink" title="执行 qtsetup"></a>执行 qtsetup</h3><p>下载好库后会在<code>%GOPATH%/bin</code>目录下出现几个帮助执行绑定工作的可执行文件<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Go-Use-Qt-2020-04-19-20-06-08.png" alt="Go-Use-Qt-2020-04-19-20-06-08"></p>
<p>现在还需要根据你本地的 Qt 再配置下编译环境，就是执行上面目录中的 qtsetup，但是直接执行是会有问题的：<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Go-Use-Qt-2020-04-19-20-23-26.png" alt="Go-Use-Qt-2020-04-19-20-23-26"></p>
<p>需要配置几个环境变量，<code>qtsetup</code>只需要执行一次。如果你有多个环境要切换，需要注意和编译时的环境变量保持一致，可以用 bat 临时设置下环境变量方便切换，下面就是 bat 的内容：</p>
<pre><code class="bat">SET PATH=%PATH%;%GOPATH%\bin;

REM 配置Qt目录和Qt版本
SET QT_DIR=C:\Qt\Qt5.12.5
SET QT_VERSION_MAJOR=5.12.5

REM 编译32位程序，前提是你的Qt有Mingw32套件
SET GOARCH=386

REM 默认使用Mingw编译，使用MSVC编译的话开启下面的选项，qtsetup可以运行，但是后面qtdeploy会报cgo相关错误
REM SET QT_MSVC=true
REM SET PATH=%PATH%;C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Auxiliary\Build;
REM call vcvarsall.bat amd64_x86

REM 语言绑定安装，只需执行一次
qtsetup.exe
</code></pre>
<h2 id="demo-运行"><a href="#demo-运行" class="headerlink" title="demo 运行"></a>demo 运行</h2><h3 id="创建一个-Go-项目目录"><a href="#创建一个-Go-项目目录" class="headerlink" title="创建一个 Go 项目目录"></a>创建一个 Go 项目目录</h3><p>终端运行:</p>
<pre><code class="shell">mkdir qtwidget &amp;&amp; cd qtwidget
go mod init
</code></pre>
<h3 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h3><p>在项目目录新建一个 main.go 文件，复制下面的内容:</p>
<pre><code class="go">package main

import (
    &quot;os&quot;

    &quot;github.com/therecipe/qt/widgets&quot;
)

func main() {

    // needs to be called once before you can start using the QWidgets
    app := widgets.NewQApplication(len(os.Args), os.Args)

    // create a window
    // with a minimum size of 250*200
    // and sets the title to &quot;Hello Widgets Example&quot;
    window := widgets.NewQMainWindow(nil, 0)
    window.SetMinimumSize2(250, 200)
    window.SetWindowTitle(&quot;Hello Widgets Example&quot;)

    // create a regular widget
    // give it a QVBoxLayout
    // and make it the central widget of the window
    widget := widgets.NewQWidget(nil, 0)
    widget.SetLayout(widgets.NewQVBoxLayout())
    window.SetCentralWidget(widget)

    // create a line edit
    // with a custom placeholder text
    // and add it to the central widgets layout
    input := widgets.NewQLineEdit(nil)
    input.SetPlaceholderText(&quot;Write something ...&quot;)
    widget.Layout().AddWidget(input)

    // create a button
    // connect the clicked signal
    // and add it to the central widgets layout
    button := widgets.NewQPushButton2(&quot;and click me!&quot;, nil)
    button.ConnectClicked(func(bool) {
        widgets.QMessageBox_Information(nil, &quot;OK&quot;, input.Text(), widgets.QMessageBox__Ok, widgets.QMessageBox__Ok)
    })
    widget.Layout().AddWidget(button)

    // make the window visible
    window.Show()

    // start the main Qt event loop
    // and block until app.Exit() is called
    // or the window is closed by the user
    app.Exec()
}

</code></pre>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译就是执行 qtdeploy 命令，具体参数可以自己运行 qtdeploy -h 查看，这个终端文件也是在<code>%GOPATH%/bin</code>的，如果你的编译环境有多个也可以用 bat 配置下，与上面的类似，新建个 build.bat 拷贝下面的内容并运行：</p>
<pre><code class="bat">SET PATH=%PATH%;%GOPATH%\bin;

REM 配置Qt目录和Qt版本
SET QT_DIR=C:\Qt\Qt5.12.5
SET QT_VERSION_MAJOR=5.12.5

REM 编译32位程序
SET GOARCH=386

REM 默认使用Mingw编译，使用MSVC编译的话开启下面的选项，qtsetup可以运行，但是后面qtdeploy会报cgo相关错误
REM SET QT_MSVC=true
REM SET PATH=%PATH%;C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Auxiliary\Build;
REM call vcvarsall.bat amd64_x86

REM 语言绑定安装，只需执行一次
REM qtsetup.exe

REM 编译具体项目时运行
qtdeploy build desktop ./
</code></pre>
<p>生成的可执行文件在当前目录/deploy/windows，本体 exe 和相关的 dll 都在这个目录下</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Go-Use-Qt-2020-04-19-20-52-51.png" alt="Go-Use-Qt-2020-04-19-20-52-51"></p>
<p>注：我使用 Mingw 编译成功，但是 MSVC 编译会有 cgo 的错误，太难用了…</p>
<pre><code class="shell">main.go:6:2: G:\Go\src\go_learn\qtwidget\vendor\github.com\therecipe\qt\widgets\minimal_cgo_windows_windows_386.go: invalid #cgo verb: #cgo MSCFLAGS: -nologo -Zc:wchar_t -FS -Zc:strictStrings -O2 -MD -W3 -w44456 -w44457 -w44458 -D_ALLOW_KEYWORD_MACROS -DUNICODE -D_UNICODE -DWIN32 -D_ENABLE_EXTENDED_ALIGNED_STORAGE -DQT_NO_DEBUG -DQT_WIDGETS_LIB -DQT_GUI_LIB -DQT_CORE_LIB -DNDEBUG
</code></pre>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>demo 执行效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Go-Use-Qt-2020-04-19-20-53-54.png" alt="Go-Use-Qt-2020-04-19-20-53-54"></p>
<h3 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h3><p>虽然没几行，不过如果懒得复制的话也可以直接下载，<a href="https://github.com/Longxr/go_learn/tree/master/qtwidget" target="_blank" rel="noopener">Github 链接</a>，喜欢的话记得点个 Star~</p>
<h2 id="使用感受"><a href="#使用感受" class="headerlink" title="使用感受"></a>使用感受</h2><ul>
<li>编译的命令行配置中没有多核编译的选项，改个代码编译起码要几分钟，很难受</li>
<li>这个库没有官方文档，wiki 直接指向 Qt 的文档，所以调用都要在源码搜，看看转换函数咋写的，把 Qt 函数名大写、函数重载就名字后面加序号等，很蛋疼…</li>
<li>语法也不适应，Qt 的 connect 改成了类似方法回调的样子:<code>btn.ConnectClicked(func(){})</code></li>
<li>支持不完善，使用 MSVC 编译会有 cgo 的错误，还是直接通过 rpc 调用或者 http 调用来让 Go 和 Qt 通信比较好</li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> go </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[不同语言在函数内部定义函数]]></title>
      <url>https://longxuan.ren/2020/04/04/Languages-Define-Inner-Func/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>在 LeetCode 刷题的时候，题解有的大佬给出的答案很优秀，是 python 的，想抄作业发现有的功能函数都定义在答案函数的内部，主要是闭包操作外部变量方便。不同语言在函数内部定义函数稍有不同，于是记录下自己可能用到的语言在函数中定义函数的方式。<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>python 定义内部函数加个 def 就行，和使用变量差别不大，可以在参数列表后跟-&gt;指定返回值。</p>
<pre><code class="python">def outerFunc() -&gt; None:
    a: int = 1
    def innerFunc(b: int) -&gt; int:
        nonlocal a  #不加的话不会修改外部变量的值
        a = 2
        return a + b
    print(&quot;ans:{ans}, a:{a}&quot;.format(ans=innerFunc(3), a=a)) #不加nonlocal ans:5, a:1; 加上nonlocal ans:5, a:2

if __name__ == &#39;__main__&#39;:
    outerFunc()
</code></pre>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p>C++主要是使用 Lambda 函数来实现，可以在参数列表后跟-&gt;指定返回值。在函数前有个<code>[]</code>的引出符，不同符号对于外部变量的处理方式不同：</p>
<ul>
<li>[a]，表示以值传递方式捕捉变量 a</li>
<li>[=]，表示值传递捕捉所有父作用域变量，以值传递的形式捕获的变量如果要修改，需要在函数参数列表后面加上 mutable</li>
<li>[&amp;a]，表示以引用传递方式捕捉变量 a</li>
<li>[&amp;]，表示引用传递捕捉所有父作用域变量</li>
<li>[this]，表示值传递方式捕捉当前的 this 指针</li>
<li>[=,&amp;a]，表示以引用传递方式捕捉 a,值传递方式捕捉其他变量</li>
</ul>
<pre><code class="C++">#include &lt;iostream&gt;
using namespace std;

void outerFunc() {
    int a = 1;
    auto innerFunc = [&amp;a](int b)-&gt;int {
        a = 2;
        return a + b;
    };
    cout &lt;&lt; &quot;ans:&quot; &lt;&lt; innerFunc(3) &lt;&lt; &quot;, a:&quot; &lt;&lt; a;  //ans:5, a:2
}

int main(int argc, char* argv[]) {
    outerFunc();
    return 0;
}
</code></pre>
<h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><p>golang 和 python 差不多，函数返回值直接写在参数后边。不过内部定义不能写函数名，调用可以通过变量来使用。</p>
<pre><code class="go">package main
import &quot;fmt&quot;

func outerFunc() {
    a := 1
    // innerFunc := func innerFuncTest(b int) int { //error
    innerFunc := func (b int) int {
        a = 2
        return a + b
    }
    fmt.Printf(&quot;ans:%d, a:%d&quot;, innerFunc(3), a) //ans:5, a:2
}

func main(){
    outerFunc()
}
</code></pre>
<h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><p>js 参数和返回值不用指定，箭头函数连接参数和返回的对象。</p>
<pre><code class="js">function outerFunc() {
    a = 1;
    innerFunc = (b) =&gt; {
        a = 2;
        return a + b;
    };
    console.log(&#39;ans:&#39;, innerFunc(3), &#39;, a:&#39;, a); //ans: 5 , a: 2
}

outerFunc();
</code></pre>
<h2 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h2><ul>
<li>只有 python 需要加个 nonlocal 才能修改外部函数的变量，其他语言默认就是可以修改外部函数的变量的</li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> go </tag>
            
            <tag> C++ </tag>
            
            <tag> python </tag>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ffmpeg将多个flv文件合成为mp4（golang版）]]></title>
      <url>https://longxuan.ren/2020/03/22/flvs2mp4-go/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>视频文件归档，将flv合并为mp4，go语言版 <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>之前拿python写了个合并flv文件为mp4的脚本，运行感觉有点慢，用go重写下</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>flv文件直接合并生成mp4的话只有第一个flv的内容才能播放，需要先转换成ts再合成mp4</li>
<li>命令行调用ffmpeg，需要自己另外安装，并配置环境变量</li>
<li><code>-loglevel quiet</code>是调用ffmpeg不输出日志的选项，需要日志的话可以不加</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>package main

import (
    &quot;bytes&quot;
    &quot;flag&quot;
    &quot;fmt&quot;
    &quot;io/ioutil&quot;
    &quot;os&quot;
    &quot;os/exec&quot;
    &quot;path/filepath&quot;
    &quot;strings&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

var (
    wg     sync.WaitGroup
)

// 判断文件或目录是否存在
func pathExists(path string) (bool, error) {
    _, err := os.Stat(path)
    if err == nil {
        return true, nil
    }
    if os.IsNotExist(err) {
        return false, nil
    }
    return false, err
}

// 命令行调用
func Cmd(commandName string, params []string) (string, error) {
    cmd := exec.Command(commandName, params...)
    //fmt.Println(&quot;Cmd&quot;, cmd.Args)
    var out bytes.Buffer
    cmd.Stdout = &amp;out
    cmd.Stderr = os.Stderr
    err := cmd.Start()
    if err != nil {
        return &quot;&quot;, err
    }
    err = cmd.Wait()
    return out.String(), err
}

// 视频格式转换
func videoConvert(in string, out string) {
    defer wg.Done()
    //fmt.Println(in, out)
    cmdStr := fmt.Sprintf(&quot;ffmpeg -i %s -loglevel quiet -c copy -bsf:v h264_mp4toannexb -f mpegts %s&quot;, in, out)
    args := strings.Split(cmdStr, &quot; &quot;)
    msg, err := Cmd(args[0], args[1:])
    if err != nil {
        fmt.Printf(&quot;videoConvert failed, %v, output: %v\n&quot;, err, msg)
        return
    }
}

// 视频合成
func videoMerge(in []string, out string) {
    //fmt.Println(in, out)
    cmdStr := fmt.Sprintf(&quot;ffmpeg -i concat:%s -loglevel quiet -c copy -absf aac_adtstoasc -movflags faststart %s&quot;,
        strings.Join(in, &quot;|&quot;), out)
    args := strings.Split(cmdStr, &quot; &quot;)
    msg, err := Cmd(args[0], args[1:])
    if err != nil {
        fmt.Printf(&quot;videoMerge failed, %v, output: %v\n&quot;, err, msg)
        return
    }
}

func flvs2mp4(inDir string, outFile string)(err error) {
    tsFileDir := filepath.Join(inDir, &quot;tsfile&quot;)
    if err = os.RemoveAll(tsFileDir); err != nil {
        return
    }
    if err = os.RemoveAll(outFile); err != nil {
        return
    }
    if err = os.Mkdir(tsFileDir,0666); err!=nil {
        return
    }

    infiles, _ := ioutil.ReadDir(inDir)
    for _, f := range infiles {
        if filepath.Ext(f.Name()) == &quot;.flv&quot; {
            tsfileName := filepath.Join(tsFileDir, strings.TrimSuffix(f.Name(), &quot;.flv&quot;) + &quot;.ts&quot;)
            wg.Add(1)
            go videoConvert(filepath.Join(inDir, f.Name()), tsfileName)
        }
    }
    wg.Wait()

    tsfiles, _ := ioutil.ReadDir(tsFileDir)
    tsfileNames := make([]string, 0, len(tsfiles))
    for _, f := range tsfiles {
        if filepath.Ext(f.Name()) == &quot;.ts&quot; {
            tsfileNames = append(tsfileNames, filepath.Join(tsFileDir, f.Name()))
        }
    }
    videoMerge(tsfileNames, outFile)

    return
}

func main() {
    start := time.Now()
    var inputDir string
    var outputName string
    flag.StringVar(&amp;inputDir, &quot;i&quot;, &quot;./dvr-file/flv&quot;, &quot;input file dir&quot;)
    flag.StringVar(&amp;outputName, &quot;o&quot;, &quot;out.mp4&quot;, &quot;output file name&quot;)
    //解析命令行参数
    flag.Parse()

    exist, err := pathExists(inputDir)
    if err != nil {
        fmt.Printf(&quot;get dir error!: %v&quot;, err)
        return
    }
    if !exist {
        inputDir = os.Args[0]
    }
    inputDir, _  = filepath.Abs(inputDir)
    fmt.Println(&quot;argv: &quot;, inputDir, outputName)
    if err = flvs2mp4(inputDir, outputName); err != nil {
        fmt.Printf(&quot;flv to mp4 error!: %v&quot;, err)
    }

    elapsed := time.Since(start)
    fmt.Println(&quot;Running time:&quot;, elapsed)
}

</code></pre><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/flvs2mp4-go-2020-3-22-22-55-44.png" alt="flvs2mp4-go-2020-3-22-22-55-44.png"></p>
<p>11个30s左右的flv合成mp4不用groutine需要时间5.74秒，开启groutine只要3.2秒，确实快了不少</p>
</the>]]></content>
      
        <categories>
            
            <category> 音视频 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> go </tag>
            
            <tag> ffmpeg </tag>
            
            <tag> flv </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[远程办公内网搭建]]></title>
      <url>https://longxuan.ren/2020/03/21/Remote-Access-Server/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>通过 zerotier 搭建远程办公的内网，操作简单，关键不花钱 2333 <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>平时如果需要在公司访问家里的电脑一般都是用的 teamviewer，免费版一般都够用，没啥问题。可是最近也不知道是不是因为远程办公的人太多了，teamviewer 经常显示我要连的计算机离线，没关机的电脑要怎么离线嘛<em>(:з)∠)</em>于是我就重新找了下有没有其他好用的内网穿透的工具。</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>内网穿透说白了就是内网机器没有对外的 IP，从外部不能直接访问，就需要有个站在外面的中间人转发下消息。看了下现有的工具，应该是分为两类：</p>
<ol>
<li>有第三方中心服务器的，teamviewer、向日葵、zerotier…</li>
<li>需要有公网 IP 的服务器的，frp、SoftEther…</li>
</ol>
<p>我的需求是自己能访问就行，也不需要像服务一样暴露给其他人，懒得再另外搞个服务器了，果断选择了第一类。teamviewer 由于会抽风跳过; 向日葵搜了下收费版风评好像也没比 teamviewer 的免费版好，也跳过; 所以选择了 zerotier。</p>
<h2 id="zerotier-原理"><a href="#zerotier-原理" class="headerlink" title="zerotier 原理"></a>zerotier 原理</h2><p>zerotier 使用时会创建一个虚拟局域网（VLAN），所有加入这个网络的机器可以像是在一个局域网一样互相访问。只需要管理员去官网注册一个账号并创建网络，其他人<a href="https://www.zerotier.com/download/" target="_blank" rel="noopener">安装 zerotier 的客户端</a>并加入对应 VLAN 即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Remote-Access-Server-2020-3-20-22-19-51.png" alt="Remote-Access-Server-2020-3-20-22-19-51.png"></p>
<h2 id="创建-VLAN"><a href="#创建-VLAN" class="headerlink" title="创建 VLAN"></a>创建 VLAN</h2><h3 id="注册一个账号"><a href="#注册一个账号" class="headerlink" title="注册一个账号"></a>注册一个账号</h3><p><a href="https://my.zerotier.com/" target="_blank" rel="noopener">官网链接</a>，注册略过</p>
<h3 id="创建一个新的网络"><a href="#创建一个新的网络" class="headerlink" title="创建一个新的网络"></a>创建一个新的网络</h3><p>点击网站上方的 NETWORK，然后再点击蓝色的<code>Create a Network</code>，就会自动创建一个网络，网络会显示个网络 ID 在蓝色按钮下面</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Remote-Access-Server-2020-3-20-22-35-10.png" alt="Remote-Access-Server-2020-3-20-22-35-10.png"></p>
<h3 id="网络具体配置"><a href="#网络具体配置" class="headerlink" title="网络具体配置"></a>网络具体配置</h3><p>点击上一步创建的网络，可以进入网络配置。</p>
<ol>
<li>下图的权限控制，<code>PRIVATE</code>表示加入网络的客户端需要你在下面的设备列表勾选了才能进入这个 VLAN；<code>PUBLIC</code>表示任何加入的客户端都能直接进入。</li>
<li><code>IPv4 Auto-Assign</code>中随便选一个你想要的 VLAN 的网段</li>
<li>底下的那个显示设备 MAC 地址、VLAN IP 和公网 IP 的列表是加入这个网络的设备，<code>AUTH</code>勾选了表示允许加入了这个网络，<code>Managed IPs</code> 可以给每个设备一个想要的 IP</li>
<li>点击设备名称旁边的小扳手，<code>Allow Ethernet Bridging</code>网络中的设备需要互相通信的话要勾选; <code>Do Not Auto-Assign IPs</code>我是勾选了不自动分配，自己给每个设备固定设置 IP</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Remote-Access-Server-2020-3-20-22-32-45.png" alt="Remote-Access-Server-2020-3-20-22-32-45.png"><br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Remote-Access-Server-2020-3-20-22-43-38.png" alt="Remote-Access-Server-2020-3-20-22-43-38.png"></p>
<h2 id="客户端安装"><a href="#客户端安装" class="headerlink" title="客户端安装"></a>客户端安装</h2><p><a href="https://www.zerotier.com/download/" target="_blank" rel="noopener">安装 zerotier 的客户端</a>，各个平台按照说明安装即可，加入网络后如果网络设置的 PRIVATE，需要管理员在配置页面允许加入下，配置说明可以看上面的说明</p>
<h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>window 最简单，下载 msi 直接安装就行了。装好后在通知栏有个小图标，右键 Join Network，填上上面创建的网络的 ID 就加入了<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Remote-Access-Server-2020-3-20-22-58-58.png" alt="Remote-Access-Server-2020-3-20-22-58-58.png"></p>
<h3 id="centos"><a href="#centos" class="headerlink" title="centos"></a>centos</h3><h4 id="添加-yum-源"><a href="#添加-yum-源" class="headerlink" title="添加 yum 源"></a>添加 yum 源</h4><p><code>vim /etc/yum.repos.d/zerotier.repo</code></p>
<pre><code>[zerotier]
name=ZeroTier, Inc. RPM Release Repository
baseurl=http://download.zerotier.com/redhat/el/$releasever
enabled=1
gpgcheck=0
</code></pre><h4 id="命令行操作（root"><a href="#命令行操作（root" class="headerlink" title="命令行操作（root)"></a>命令行操作（root)</h4><pre><code>yum clean all
yum install zerotier-one                     #安装
zerotier-one -d                              #启动
zerotier-cli status                          #查看状态
zerotier-cli join &lt;Network ID&gt;               #加入网络
systemctl start zerotier-one.service
systemctl enable zerotier-one.service        #开机自启
</code></pre><h2 id="VSCode-Remote-SSH"><a href="#VSCode-Remote-SSH" class="headerlink" title="VSCode Remote SSH"></a>VSCode Remote SSH</h2><p>同一个局域网的 windows 直接远程桌面就可以愉快的玩耍了， windows 用 xshell 等工具连接 linux 服务器操作的话还是有点蛋疼，尤其是需要修改代码啥的。<br><code>Remote SSH</code>是 VSCode 远程开发包中的一个扩展，在目标 linux 服务器配置好 ssh 后，可以在本地直接用 VSCode 远程连接写代码，用起来超方便。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Remote-Access-Server-2020-3-20-23-33-51.png" alt="Remote-Access-Server-2020-3-20-23-33-51.png"></p>
<h3 id="ssh-配置"><a href="#ssh-配置" class="headerlink" title="ssh 配置"></a>ssh 配置</h3><h4 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h4><ol>
<li>生成 ssh 密钥，<code>ssh-keygen -t rsa -C&quot;你的邮箱&quot;</code></li>
<li>编辑<code>~/.ssh/config</code>（windows 在 C:\Users\xxx.ssh），配置好服务器 User(用户名)、HostName（服务器 IP）、IdentityFile，</li>
<li>终端敲命令, <code>name@server-ip</code>根据你的服务器和用户名填写</li>
</ol>
<pre><code>SET REMOTEHOST=name@server-ip
scp %USERPROFILE%\.ssh\id_rsa.pub %REMOTEHOST%:~/tmp.pub
ssh %REMOTEHOST% &quot;mkdir -p ~/.ssh &amp;&amp; chmod 700 ~/.ssh &amp;&amp; cat ~/tmp.pub &gt;&gt; ~/.ssh/authorized_keys &amp;&amp; chmod 600 ~/.ssh/authorized_keys &amp;&amp; rm -f ~/tmp.pub&quot;
</code></pre><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>有时候直接用 VSCode 连接 linux 服务器会报错，如果错误是 wget 下载文件错误的话，在 VSCode 输出日志上面应该有一串哈希值的 commit-id，对应 vscode 某个 release 版本。直接用本地电脑访问  <a href="https://update.code.visualstudio.com/commit" target="_blank" rel="noopener">https://update.code.visualstudio.com/commit</a>:<commit-id>/server-linux-x64/stable 先下载下来，下载后将<code>vscode-server-linux-x64.tar.gz</code>文件解压到<code>~/.vscode-server/bin/&lt;commit-id&gt;</code>，后面再用 VSCode 远程应该就可以了</commit-id></p>
<h2 id="用后感"><a href="#用后感" class="headerlink" title="用后感"></a>用后感</h2><ul>
<li><p>访问同一个 VLAN 的机器速度还是很快的，windows 的话直接远程桌面和 teamviewer 比基本上是没区别了，而且还稳定。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Remote-Access-Server-2020-3-20-23-9-36.png" alt="Remote-Access-Server-2020-3-20-23-9-36.png"></p>
</li>
<li><p>传输文件比较弱，通过 ssh 的 scp 传输文件的时候，最开始 10 秒还可以 2M/s,后面就缩水成 kb/s 了，不过只要网连着，找个网盘中转下就行</p>
</li>
<li>对于一些不方便安装客户端的设备，可以通过已经加入网络的客户端，做一下端口映射，相关工具比如<a href="https://github.com/ginuerzh/gost" target="_blank" rel="noopener">gost</a>，有需要的自己去看看吧</li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> 环境搭建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> zerotier </tag>
            
            <tag> vscode </tag>
            
            <tag> 内网穿透 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ffmpeg将多个flv文件合成为mp4（python版）]]></title>
      <url>https://longxuan.ren/2020/03/20/flvs2mp4-python/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>视频文件归档，将flv合并为mp4 <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>直播生成的flv片段需要做个归档，把指定的文件夹中的flv合并成一个mp4，简单的转码合并操作直接用命令行调用来实现即可。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>flv文件直接合并生成mp4的话只有第一个flv的内容才能播放，需要先转换成ts再合成mp4</li>
<li>使用的第三方库ffmpy，只是简单封装了命令行参数，ffmpeg还是需要自己另外安装，并配置环境变量的</li>
<li><code>-loglevel quiet</code>是调用ffmpeg不输出日志的选项，需要日志的话可以不加</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code># coding=utf-8
import logging
import os
import shutil
import sys
from time import perf_counter

from ffmpy import FFmpeg
from natsort import natsorted

logger = logging.getLogger(__name__)


def video_convert(in_path, out_path):
    FFmpeg(inputs={in_path: None}, outputs={
           out_path: &#39;-loglevel quiet -c copy -bsf:v h264_mp4toannexb -f mpegts&#39;}).run()


def del_path(path):
    if not os.path.exists(path):
        return

    if os.path.isdir(path):
        shutil.rmtree(path)
    elif os.path.isfile(path):
        os.remove(path)


def flv_dir_to_mp4(in_path_dir, out_path_file):
    &quot;&quot;&quot;
    将flv文件转换为mp4
    法一:(只显示第一段，有问题)
    ffmpeg -safe 0 -f concat -i filelist.txt -c copy out.mp4
    法二:
    ffmpeg -i input1.mp4 -c copy -bsf:v h264_mp4toannexb -f mpegts intermediate1.ts
    ffmpeg -i &quot;concat:1.ts|2.ts|...n.ts&quot; -c copy -absf aac_adtstoasc out.mp4
    &quot;&quot;&quot;

    tsfile_dir = os.path.join(in_path_dir, &#39;tsfile&#39;)
    del_path(out_path_file)
    del_path(tsfile_dir)

    os.mkdir(tsfile_dir)

    out_files = []

    # 生成中间文件ts
    for root, dirs, files in os.walk(in_path_dir):
        files = natsorted(files)
        for file in files:
            if os.path.splitext(file)[1] == &#39;.flv&#39;:
                file_path = os.path.join(root, file)
                video_convert(os.path.join(root, file), os.path.join(
                    tsfile_dir, os.path.splitext(file)[0] + &#39;.ts&#39;))

    # 获取列表参数
    for root, dirs, files in os.walk(tsfile_dir):
        files = natsorted(files)
        for file in files:
            if os.path.splitext(file)[1] == &#39;.ts&#39;:
                file_path = os.path.join(root, file)
                out_files.append(file_path)

    ff = FFmpeg(inputs={&#39;concat:&#39; + &#39;|&#39;.join(out_files): None},
                outputs={out_path_file: &#39;-loglevel quiet -c copy -absf aac_adtstoasc -movflags faststart&#39;})
    ff.run()
    # cmd = &#39;|&#39;.join(out_files)
    # print(out_files)
    # cmd = &#39;concat:&#39; + &quot;\&quot;&quot; + cmd + &quot;\&quot;&quot;
    # cmd = &#39;ffmpeg -i &#39; + cmd + &#39; -loglevel quiet -c copy -absf aac_adtstoasc -movflags faststart &#39; + out_path_file
    # cmd = &#39;ffmpeg -i &#39; + cmd + &#39; -safe 0 -segment_time_metadata 1 -vf select=concatdec_select -af aselect=concatdec_select,aresample=async=1 &#39; + out_path_file
    # print(cmd)


if __name__ == &#39;__main__&#39;:
    start = perf_counter()

    print(&#39;sys argv&#39;, sys.argv)
    if len(sys.argv) == 3:
        flv_dir_to_mp4(sys.argv[1], sys.argv[2])
    elif len(sys.argv) == 2:
        flv_dir_to_mp4(sys.argv[1], os.path.join(sys.argv[1], &#39;out.mp4&#39;))
    else:
        root_dir = os.path.dirname(os.path.abspath(__file__))
        flv_dir_to_mp4(root_dir, os.path.join(root_dir, &#39;out.mp4&#39;))

    end = perf_counter()
    print(&#39;Running time: %s Seconds&#39; % (end-start))
</code></pre><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/flvs2mp4-python-2020-3-20-21-59-36.png" alt="flvs2mp4-python-2020-3-20-21-59-36.png"></p>
<p>11个30s左右的flv合成mp4需要时间7.74秒，多了的话可能会比较慢…</p>
</the>]]></content>
      
        <categories>
            
            <category> 音视频 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> ffmpeg </tag>
            
            <tag> flv </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[golang学习--defer]]></title>
      <url>https://longxuan.ren/2020/02/29/Go-defer/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>Go 语言中的 defer 语句，可以在函数结束或者是出现异常时保证执行相关释放资源的操作，和 C++中的析构函数有点类似。像是文件的关闭，socket 连接的关闭这些操作都可以使用 defer 语句来延迟执行。<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="执行时机"><a href="#执行时机" class="headerlink" title="执行时机"></a>执行时机</h3><ul>
<li>函数返回时（碰到的第一个 return 的位置）</li>
<li>函数执行完毕（没有 return）</li>
<li>函数碰到异常，抛出 panic 时</li>
<li>调用 os.Exit 时 defer 不会被执行</li>
</ul>
<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><ol>
<li>返回值赋值给返回值变量，函数没有写返回值变量名则赋值给匿名变量</li>
<li>声明了 defer 语句的话就执行，有多个 defer 语句则按照声明顺序反过来分别执行</li>
<li>函数返回返回值 ret</li>
</ol>
<h3 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h3><ul>
<li>defer 要先声明后才会延迟执行，如果函数已经走到 return，return 后面声明的 defer 语句是不会执行的</li>
<li>如果有参数传递给 defer，值传递是在声明 defer 语句时就已经传值了，并不是在执行函数时去获取值</li>
</ul>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="返回结果判断"><a href="#返回结果判断" class="headerlink" title="返回结果判断"></a>返回结果判断</h3><pre><code>func ret1() int {
    x := 1
    defer func() {
        x++     //后执行，修改的是局部变量x
    }()
    return x    //先执行，匿名变量赋值为1
}

func ret2() (x int) {
    x = 1
    defer func() {
        x++     //修改了返回值
    }()
    return x    //返回值就是x
}

func TestRet(t *testing.T) {
    t.Log(&quot;ret1(): &quot;, ret1())
    t.Log(&quot;ret2(): &quot;, ret2())
}

// 执行结果：
// ret1():  1
// ret2():  2
</code></pre><h3 id="defer-传入参数、多个-defer-执行顺序"><a href="#defer-传入参数、多个-defer-执行顺序" class="headerlink" title="defer 传入参数、多个 defer 执行顺序"></a>defer 传入参数、多个 defer 执行顺序</h3><pre><code>func calc(index, a, b int) int {
    ret := a + b
    fmt.Println(index, a, b, ret)
    return ret
}

func TestParam(t *testing.T) {
    a := 1
    b := 2
    defer calc(1, a, calc(2, a, b)) // defer calc(1, 1, 3)
    a = 0
    defer calc(3, b, calc(4, a, b)) // defer calc(3, 2, 2)
    b = 1
}

// 执行结果：
// 2 1 2 3
// 4 0 2 2
// 3 2 2 4
// 1 1 3 4
</code></pre><h3 id="执行时遇到-panic"><a href="#执行时遇到-panic" class="headerlink" title="执行时遇到 panic"></a>执行时遇到 panic</h3><pre><code>func TestPanic(t *testing.T) {
    defer func() {
        t.Log(&quot;Clear resources&quot;)
    }()
    t.Log(&quot;Started&quot;)
    panic(&quot;Fatal error&quot;)
    t.Log(&quot;End&quot;)            //panic后不会执行
}

// 执行结果：
// Started
// Clear resources
// panic: Fatal error [recovered]
</code></pre></the>]]></content>
      
        <categories>
            
            <category> go </category>
            
        </categories>
        
        
        <tags>
            
            <tag> go </tag>
            
            <tag> defer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[更换博客图床]]></title>
      <url>https://longxuan.ren/2020/01/10/Replace-Jianshu-Url/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>我最开始写博客的时候接触到的就是简书，简书的在线编辑文章对于markdown的支持在2年前就很好用了，而且上传图片也比较简单，直接拖到文章里就能生成链接了，也省了一个图床。于是我就先在简书写markdown，再把文章复制一份放到<a href="https://longxuan.ren/">自己的网站</a>上。平时比较多的情况是直接在文章里贴代码，图可能就在最后放个结果图的链接，最近去看自己网站上的博客的时候，发现图片全都看不了，找了下原因发现简书上传的图片在外站貌似是无法查看了，把简书当图床用的日子到头了<em>(:з)∠)</em><br><a id="more"></a><the rest of contents | 余下全文></the></excerpt></p>
<h2 id="寻找合适的图床"><a href="#寻找合适的图床" class="headerlink" title="寻找合适的图床"></a>寻找合适的图床</h2><p>有了简书的这个经历，发现通过某个网站当图床都有点不靠谱了，指不定哪天就禁止外链，所有图片就都gg了，所以图床还是自己搭一个比较好。<br>搜索引擎找了一圈，有三个比较常用的：</p>
<ol>
<li><del><a href="https://www.qiniu.com/" target="_blank" rel="noopener">七牛云</a></del></li>
<li><del><a href="https://www.aliyun.com/" target="_blank" rel="noopener">阿里云</a></del></li>
<li><a href="https://github.com/" target="_blank" rel="noopener">Github</a></li>
</ol>
<h3 id="七牛云"><a href="#七牛云" class="headerlink" title="七牛云"></a>七牛云</h3><p>七牛云有免费空间，不过必须要你的域名是备案过的才行，我本来域名是备案了的，备案了俩，上个月阿里客服给我打电话说我不用的另一个域名需要注销，不然会影响主体域名，我手滑把所有都注销了Orz…于是七牛这边就没法用了，除非我重新再备案一波。顺便翻了下别人用七牛云当图床的情况，https的图片外链好像不算免费的，不过我也懒得考证了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Replace-Jianshu-Url-2020-1-10-11-3-49.png" alt="域名不备案空间会被冻结"></p>
<h3 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h3><p>阿里云的OSS看着感觉挺便宜的，那个标准存储40G一年9块钱的样子，好像这是存储费用，如果发生了外网访问产生了流量要另外收费。不过钱不是重点，找了一下使用OSS是否要备案，客服问了也不吱声，直接叫我发工单emmmmm，我可能碰到了假客服。最后在一个叫<a href="https://www.aliyunbaike.com/oss/3198/" target="_blank" rel="noopener">阿鲤云百科</a>的地方翻到这个说明：<br><img src="https://upload-images.jianshu.io/upload_images/2756183-2a7cd8c888499d1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="香港的OSS也要备案"></p>
<p>香港的OSS都要备案的话，其他的应该也不用问了。查到这我想是不是国内的这些平台都要备案呢，要不还是备案一下？搜索了一下阿里云备案的相关说明，至少要开一个ECS服务器3个月以上。阿里云对老用户真的是一点优惠都木有，没个几百块是搞不定了，关键我还用不着，网站现在放在Github page好好的，这个方案也放弃。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Replace-Jianshu-Url-2020-1-10-11-29-31.png" alt="ECS需要购买3个月以上"></p>
<h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><p>这个方案放到最后是由于Github仓库平时不用代理clone都费劲，考虑到图片外链希望加载速度快些。不过解决方案却意外的简单，搜索使用Github当图床的时候发现了这个免费的CDN加速<a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">jsdelivr</a>，可以直接使用上传到Github仓库的文件做外链，只需要按要求改下图片链接即可。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Replace-Jianshu-Url-2020-1-10-12-11-31.png" alt="jsdelivr介绍"></p>
<p>这是官网说明的链接地址规则：<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Replace-Jianshu-Url-2020-1-10-12-16-45.png" alt="转换地址规则"></p>
<p>下面是我自己的仓库链接转换前和转换后的链接：</p>
<pre><code>//图片上床到Github仓库的地址
https://github.com/Longxr/PicStored/tree/master/blog/xxx.png

//jsdelivr链接地址
https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/xxx.png
</code></pre><h2 id="现有文章链接转换"><a href="#现有文章链接转换" class="headerlink" title="现有文章链接转换"></a>现有文章链接转换</h2><p>现有的简书的链接有100多个，一个一个替换头都大了，还是用python大法好。在网上找了下<a href="https://juejin.im/post/5cf86bc9f265da1bb003aebe" target="_blank" rel="noopener">用Python替换简书链接的内容</a>，发现挺合适的就改了下博主的脚本，修改内容如下：</p>
<ol>
<li>原文是直接将简书链接转换成了Github仓库的链接，我是转换成jsdelivr链接。</li>
<li>原文是通过脚本直接上传到Github，我去掉了这部分，直接复制到本地仓库，方便检查是否有问题。</li>
<li>原文是使用图片的uuid作为图片名称，我是改成了当前md的文件名+index的命名方式。</li>
</ol>
<p>这是做了改动的脚本，如果需要原版可以点开上面的链接查看：</p>
<pre><code>import imghdr
import os
import re
import shutil

import requests

## 用户名
user_name = &#39;Longxr&#39;;
## 仓库名
github_repository = &#39;PicStored&#39;;
## 存放图片的git文件夹路径
git_images_folder = &#39;F:/workspace/GithubCode/PicStored/blog&#39;

# 设置用户代理头
headers = {
    &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36&#39;
}

# 获取当前目录下所有md文件
def get_md_files(md_dir):
    md_files = [];
    for root, dirs, files in sorted(os.walk(md_dir)):
        for file in files:
            # 获取.md结尾的文件
            if(file.endswith(&#39;.md&#39;)):
                file_path = os.path.join(root, file)
                print(file_path)
                #忽略排除目录
                need_append = 0
                for ignore_dir in ignore_dir_list:
                    if(ignore_dir in file_path.split(&#39;/&#39;) == True):
                        need_append = 1
                if(need_append == 0):
                    md_files.append(file_path)
    return md_files

# 获取网络图片
def get_http_image(image_url, file_new_name):
    image_info = {&#39;image_url&#39;: &#39;&#39;, &#39;new_image_url&#39;: &#39;&#39;}
    image_data = requests.get(image_url.split(&#39;?&#39;)[0], headers=headers).content
    # 创建临时文件
    tmp_new_image_path_and_name = os.path.join(git_images_folder, file_new_name)
    with open(tmp_new_image_path_and_name, &#39;wb+&#39;) as f:
        f.write(image_data)
    img_type = imghdr.what(tmp_new_image_path_and_name)
    if(img_type == None):
        img_type = &#39;&#39;
    else:
        img_type = &#39;.&#39;+img_type
    # 生成新的名字加后缀
    new_image_path_and_name = tmp_new_image_path_and_name+img_type
    # 重命名图片
    os.rename(tmp_new_image_path_and_name, new_image_path_and_name)
    new_image_url = &#39;https://cdn.jsdelivr.net/gh/&#39;+ user_name + &#39;/&#39; +github_repository+&#39;/blog/&#39;+ file_new_name + img_type
    image_info = {
        &#39;image_url&#39;: image_url,
        &#39;new_image_url&#39;: new_image_url
    }
    print(&#39;image_info&#39;, image_info)

    return image_info


# 获取本地图片
def get_local_image(image_url, file_new_name):
    image_info = {&#39;image_url&#39;: &#39;&#39;, &#39;new_image_url&#39;: &#39;&#39;}
    try:
        # 获取图片类型
        img_type = image_url.split(&#39;.&#39;)[-1]
        # 新的图片名和文件后缀
        image_name = file_new_name +&#39;.&#39;+ img_type
        # 新的图片路径和名字
        new_image_path_and_name = os.path.join(git_images_folder, image_name);
        shutil.copy(image_url, new_image_path_and_name)
        # 生成url
        new_image_url = &#39;https://cdn.jsdelivr.net/gh/&#39;+ user_name + &#39;/&#39; +github_repository+&#39;/blog/&#39;+ file_new_name + img_type
        # 图片信息
        image_info = {
            &#39;image_url&#39;: image_url,
            &#39;new_image_url&#39;: new_image_url
        }
        print(image_info)
        return image_info
    except Exception as e:
        print(e)

    return image_info

# 爬取单个md文件内的图片
def get_images_from_md_file(md_file):
    md_content = &#39;&#39;
    image_info_list = []
    md_file_name = os.path.splitext(os.path.basename(md_file))[0]
    url_index = 0

    with open(md_file, &#39;r&#39;, encoding=&#39;UTF-8&#39;) as f:
        md_content = f.read()
        image_urls = re.findall(r&#39;!\[.*?\]\((.*?)\)&#39;, md_content)
        for image_url in image_urls:
            url_index += 1
            image_new_name_without_type = md_file_name + &#39;_%02d&#39;%url_index

            # 处理本地图片
            if(image_url.startswith(&#39;http&#39;) == False):
                image_info = get_local_image(image_url, image_new_name_without_type)
                image_info_list.append(image_info)
            # 处理网络图片
            else:
                # 只爬取简书的
                if(image_url.startswith(&#39;https://upload-images.jianshu.io&#39;)):
                    try:
                        image_info = get_http_image(image_url, image_new_name_without_type)
                        image_info_list.append(image_info)
                    except Exception as e:
                        print(image_url, &#39;Unable to crawl, skip!&#39;)
                        pass
        for image_info in image_info_list:
            md_content = md_content.replace(image_info[&#39;image_url&#39;], image_info[&#39;new_image_url&#39;])

    with open(md_file, &#39;w+&#39;, encoding=&#39;UTF-8&#39;) as f:
        f.write(str(md_content.encode(&#39;utf-8&#39;).decode(&#39;utf-8&#39;)))

if __name__ == &#39;__main__&#39;:
    if(os.path.exists(git_images_folder)):
        pass
    else:
        os.mkdir(git_images_folder)
    # 获取本目录下所有md文件
    md_files = get_md_files(os.path.dirname(os.path.abspath(__file__)))

    # 将md文件依次爬取
    for md_file in md_files:
      # 爬取单个md文件内的图片
      get_images_from_md_file(md_file)

</code></pre><p>转换完后查看没什么问题，就可以提交到Github了，妥了O(∩_∩)O<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Replace-Jianshu-Url-2020-1-10-12-34-57.png" alt="转化图片结果"></p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="https://yq.aliyun.com/articles/720839?spm=a2c4e.11153940.0.0.4ea56b6c1GxVHQ&amp;accounttraceid=e62a502a514e41ed98ee18c3274fa7c9tajr" target="_blank" rel="noopener">阿里云备案相关说明</a></li>
<li><a href="https://juejin.im/post/5cf86bc9f265da1bb003aebe" target="_blank" rel="noopener">应对掘金CDN开启防盗链 记一次爬取markdown图片的经历</a></li>
<li><a href="https://www.itrhx.com/2019/08/01/A27-image-hosting/" target="_blank" rel="noopener">Github+jsDelivr+PicGo 打造稳定快速、高效免费图床</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 环境搭建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> blog </tag>
            
            <tag> python </tag>
            
            <tag> jsdelivr </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[QtCreator代码格式化]]></title>
      <url>https://longxuan.ren/2020/01/07/QtCreator-Code-Format/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>QtCreator支持多种格式化工具， 我使用的是clang-format，这个工具能够自动化格式C/C++/Obj-C代码，支持多种代码风格（Google, Chromium, LLVM, Mozilla, WebKit），同时也支持自定义风格 <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>如果使用其他插件想要看怎么设置的话可以看Qt的<a href="https://doc.qt.io/qtcreator/creator-beautifier.html" target="_blank" rel="noopener">官方文档</a>，我这里就说下clang-format需要做的步骤。</p>
<ol>
<li><a href="http://releases.llvm.org/download.html" target="_blank" rel="noopener">下载llvm并安装</a>，如果除了格式化以外不用的话，安装的时候最好不要加到环境变量</li>
<li>在Qt Creator的关于插件中启用Beautifier插件，启用插件需要重启下Creator。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/QtCreator-Code-Format_01.png" alt="启用Beautifier插件"></li>
</ol>
<h2 id="使用配置"><a href="#使用配置" class="headerlink" title="使用配置"></a>使用配置</h2><p>关于插件的配置在工具-&gt;选项-&gt;Beautifier中设置， 设置好clang-format的路径 <code>C:\Program Files\LLVM\bin\clang-format.exe</code>。</p>
<h3 id="通过-clang-format文件使用"><a href="#通过-clang-format文件使用" class="headerlink" title="通过.clang-format文件使用"></a>通过.clang-format文件使用</h3><ol>
<li>在插件的配置中<em>Options</em>选择<em>Use predefined style</em>，下拉选择File。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/QtCreator-Code-Format_02.png" alt="通过文件使用"></li>
<li>写一个.clang-format文件放到项目中和最外层的.pro同一级目录，下面是带中文注释的.code-format，也可以去<a href="http://clang.llvm.org/docs/ClangFormatStyleOptions.html" target="_blank" rel="noopener">clang-format官方说明</a>中查看。</li>
</ol>
<pre><code># 语言: None, Cpp, Java, JavaScript, ObjC, Proto, TableGen, TextProto
Language: Cpp
# 未在配置中专门设置的所有选项所使用的样式
BasedOnStyle:  Google
# 访问说明符(public、private等)的偏移
AccessModifierOffset: -4
# 开括号(开圆括号、开尖括号、开方括号)后的对齐: Align, DontAlign, AlwaysBreak(总是在开括号后换行)
AlignAfterOpenBracket: AlwaysBreak
# 连续赋值时，对齐所有等号
AlignConsecutiveAssignments: true
# 连续声明时，对齐所有声明的变量名
AlignConsecutiveDeclarations: true
# 左对齐逃脱换行(使用反斜杠换行)的反斜杠
AlignEscapedNewlines: Right
# 水平对齐二元和三元表达式的操作数
AlignOperands: true
# 对齐连续的尾随的注释
AlignTrailingComments: true
# 允许函数声明的所有参数在放在下一行
AllowAllParametersOfDeclarationOnNextLine: true
# 允许短的块放在同一行
AllowShortBlocksOnASingleLine: false
# 允许短的case标签放在同一行
AllowShortCaseLabelsOnASingleLine: false
# 允许短的函数放在同一行: None, InlineOnly(定义在类中), Empty(空函数), Inline(定义在类中，空函数), All
AllowShortFunctionsOnASingleLine: Empty
# 允许短的lambda放在同一行
AllowShortLambdasOnASingleLine: Empty
# 允许短的if语句保持在同一行
AllowShortIfStatementsOnASingleLine: true
# 允许短的循环保持在同一行
AllowShortLoopsOnASingleLine: false
# 总是在定义返回类型后换行(deprecated)
AlwaysBreakAfterDefinitionReturnType: None
# 总是在返回类型后换行: None, All, TopLevel(顶级函数，不包括在类中的函数),
#   AllDefinitions(所有的定义，不包括声明), TopLevelDefinitions(所有的顶级函数的定义)
AlwaysBreakAfterReturnType: None
# 总是在多行string字面量前换行
AlwaysBreakBeforeMultilineStrings: false
# 总是在template声明后换行
AlwaysBreakTemplateDeclarations: true
# false表示函数实参要么都在同一行，要么都各自一行
BinPackArguments: true
# false表示所有形参要么都在同一行，要么都各自一行
BinPackParameters: true
# 在二元运算符前换行: None(在操作符后换行), NonAssignment(在非赋值的操作符前换行), All(在操作符前换行)
BreakBeforeBinaryOperators: All
# 在大括号前换行: Attach(始终将大括号附加到周围的上下文), Linux(除函数、命名空间和类定义，与Attach类似),
#   Mozilla(除枚举、函数、记录定义，与Attach类似), Stroustrup(除函数定义、catch、else，与Attach类似),
#   Allman(总是在大括号前换行), GNU(总是在大括号前换行，并对于控制语句的大括号增加额外的缩进), WebKit(在函数前换行), Custom
#   注：这里认为语句块也属于函数
BreakBeforeBraces: Mozilla
# 继承列表的逗号前换行
BreakBeforeInheritanceComma: false
# 在三元运算符前换行
BreakBeforeTernaryOperators: true
# 在构造函数的初始化列表的逗号前换行
BreakConstructorInitializersBeforeComma: false
# 初始化列表前换行
BreakConstructorInitializers: BeforeComma
# Java注解后换行
BreakAfterJavaFieldAnnotations: false

BreakStringLiterals: true
# 每行字符的限制，0表示没有限制
ColumnLimit:     160
# 描述具有特殊意义的注释的正则表达式，它不应该被分割为多行或以其它方式改变
CommentPragmas:  &#39;^ IWYU pragma:&#39;
# 紧凑 命名空间
CompactNamespaces: false
# 构造函数的初始化列表要么都在同一行，要么都各自一行
ConstructorInitializerAllOnOneLineOrOnePerLine: true
# 构造函数的初始化列表的缩进宽度
ConstructorInitializerIndentWidth: 4
# 延续的行的缩进宽度
ContinuationIndentWidth: 4
# 去除C++11的列表初始化的大括号{后和}前的空格
Cpp11BracedListStyle: false
# 继承最常用的指针和引用的对齐方式
DerivePointerAlignment: false
# 关闭格式化
DisableFormat:   false
# 自动检测函数的调用和定义是否被格式为每行一个参数(Experimental)
ExperimentalAutoDetectBinPacking: false
# 固定命名空间注释
FixNamespaceComments: true
# 需要被解读为foreach循环而不是函数调用的宏
ForEachMacros:   
  - foreach
  - Q_FOREACH
  - BOOST_FOREACH

IncludeBlocks:   Preserve
# 对#include进行排序，匹配了某正则表达式的#include拥有对应的优先级，匹配不到的则默认优先级为INT_MAX(优先级越小排序越靠前)，
#   可以定义负数优先级从而保证某些#include永远在最前面
IncludeCategories: 
  - Regex:           &#39;^&quot;(llvm|llvm-c|clang|clang-c)/&#39;
    Priority:        2
  - Regex:           &#39;^(&lt;|&quot;(gtest|gmock|isl|json)/)&#39;
    Priority:        3
  - Regex:           &#39;.*&#39;
    Priority:        1
IncludeIsMainRegex: &#39;(Test)?$&#39;
# 缩进case标签
IndentCaseLabels: true

IndentPPDirectives: None
# 缩进宽度
IndentWidth:     4
# 函数返回类型换行时，缩进函数声明或函数定义的函数名
IndentWrappedFunctionNames: false

JavaScriptQuotes: Leave

JavaScriptWrapImports: true
# 保留在块开始处的空行
KeepEmptyLinesAtTheStartOfBlocks: true
# 开始一个块的宏的正则表达式
MacroBlockBegin: &#39;&#39;
# 结束一个块的宏的正则表达式
MacroBlockEnd:   &#39;&#39;
# 连续空行的最大数量
MaxEmptyLinesToKeep: 1

# 命名空间的缩进: None, Inner(缩进嵌套的命名空间中的内容), All
NamespaceIndentation: All
# 使用ObjC块时缩进宽度
ObjCBlockIndentWidth: 4
# 在ObjC的@property后添加一个空格
ObjCSpaceAfterProperty: true
# 在ObjC的protocol列表前添加一个空格
ObjCSpaceBeforeProtocolList: true

PenaltyBreakAssignment: 2

PenaltyBreakBeforeFirstCallParameter: 19
# 在一个注释中引入换行的penalty
PenaltyBreakComment: 300
# 第一次在&lt;&lt;前换行的penalty
PenaltyBreakFirstLessLess: 120
# 在一个字符串字面量中引入换行的penalty
PenaltyBreakString: 1000
# 对于每个在行字符数限制之外的字符的penalty
PenaltyExcessCharacter: 1000000
# 将函数的返回类型放到它自己的行的penalty
PenaltyReturnTypeOnItsOwnLine: 60
# 指针和引用的对齐: Left, Right, Middle
PointerAlignment: Left

#RawStringFormats: 
#  - Delimiter:       pb
#    Language:        TextProto
#    BasedOnStyle:    google
# 允许重新排版注释
ReflowComments:  true
# 允许排序#include
SortIncludes:    true

SortUsingDeclarations: true
# 在C风格类型转换后添加空格
SpaceAfterCStyleCast: false
# 模板关键字后面添加空格
SpaceAfterTemplateKeyword: true
# 在赋值运算符之前添加空格
SpaceBeforeAssignmentOperators: true
# 开圆括号之前添加一个空格: Never, ControlStatements, Always
SpaceBeforeParens: ControlStatements
# 在空的圆括号中添加空格
SpaceInEmptyParentheses: false
# 在尾随的评论前添加的空格数(只适用于//)
SpacesBeforeTrailingComments: 4
# 在尖括号的&lt;后和&gt;前添加空格
SpacesInAngles:  false
# 在容器(ObjC和JavaScript的数组和字典等)字面量中添加空格
SpacesInContainerLiterals: true
# 在C风格类型转换的括号中添加空格
SpacesInCStyleCastParentheses: false
# 在圆括号的(后和)前添加空格
SpacesInParentheses: false
# 在方括号的[后和]前添加空格，lamda表达式和未指明大小的数组的声明不受影响
SpacesInSquareBrackets: false
# 标准: Cpp03, Cpp11, Auto
Standard:        Cpp11
# tab宽度
TabWidth:        4
# 使用tab字符: Never, ForIndentation, ForContinuationAndIndentation, Always
UseTab:          Never
</code></pre><h3 id="通过在插件中添加代码使用"><a href="#通过在插件中添加代码使用" class="headerlink" title="通过在插件中添加代码使用"></a>通过在插件中添加代码使用</h3><p>使用上面配置文件的话每次都需要拷贝一个文件到对应的目录下，工程多了或者临时想格式化一部分代码不方便，可以直接将配置写到插件的配置中。在插件的配置中<em>Options</em>选择<em>Use customized style</em>，新建一个配置文件写入配置。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/QtCreator-Code-Format_03.png" alt="在配置中直接写"></p>
<p>由于不能在配置中写中文，并且配置文件中的<em>BasedOnStyle</em>可以设置默认样式，只需要写上和默认配置不同的部分，下面是相关配置:</p>
<pre><code># Defines the QtCreator style for automatic reformatting.
# http://clang.llvm.org/docs/ClangFormatStyleOptions.html

Language: Cpp
BasedOnStyle:  Google
Standard: Cpp11
AccessModifierOffset: -4
AlignConsecutiveAssignments: true
AlignConsecutiveDeclarations: true
AlwaysBreakTemplateDeclarations: true
BinPackArguments: true
BinPackParameters: true
BreakBeforeBinaryOperators: All
BreakBeforeBraces: Mozilla
ColumnLimit:     160
ContinuationIndentWidth: 4
ForEachMacros:   
  - foreach
  - Q_FOREACH
  - BOOST_FOREACH
IndentCaseLabels: true
IndentPPDirectives: None
IndentWidth:     4
</code></pre><h2 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h2><p>可以给格式化插件设置快捷键，我是给<code>Format at Cursor</code>设置了Alt+Shift+F (和VS Code的格式话相同)，使用的时候需要选中需要格式化的部分。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/QtCreator-Code-Format_04.png" alt="快捷键设置"></p>
<p>至于为啥没有设置<code>Format Current File</code>设置，是因为格式化的时候会把带lambda表达式的connect函数整成下图的样子，写成这个样子可能会被打<em>(:з)∠)</em>，所以我选择格式化选中的部分。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/QtCreator-Code-Format_05.png" alt="格式化之前"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/QtCreator-Code-Format_06.png" alt="格式化之后"></p>
<p><em>如果有什么办法可以改掉connect这种函数里带个lambda的格式的话记得评论和我说下呀</em></p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="https://blog.csdn.net/softimite_zifeng/article/details/78357898" target="_blank" rel="noopener">Clang-Format格式化选项介绍</a></li>
<li><a href="https://doc.qt.io/qtcreator/creator-beautifier.html" target="_blank" rel="noopener">Beautifying Source Code</a></li>
<li><a href="http://clang.llvm.org/docs/ClangFormatStyleOptions.html" target="_blank" rel="noopener">Clang-Format Style Options</a></li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> clang format </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt使用技巧]]></title>
      <url>https://longxuan.ren/2019/09/23/Qt-Use-Tips/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>记录下一些使用 Qt 的小技巧<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="快捷操作"><a href="#快捷操作" class="headerlink" title="快捷操作"></a>快捷操作</h2><ul>
<li>快速从函数声明创建函数定义，Alt+Enter</li>
<li>跳转到定义处，F2</li>
<li>搜索鼠标当前位置单词，F3</li>
<li>.h、.cpp 切换，F4</li>
<li>查找用过某个变量 or 函数的地方，单词上右键-&gt;Find Usages</li>
<li>定位器使用：过滤器前缀 + “空格” +   定位内容，e.g.查找名字为 save()的函数：m save</li>
<li>添加虚函数实现：类名上右键-&gt;Refactor-&gt;Insert Virtual Functions</li>
<li>查看类的继承：Ctrl+Shift+T</li>
</ul>
<h2 id="多线程编译加速（仅-Mingw）"><a href="#多线程编译加速（仅-Mingw）" class="headerlink" title="多线程编译加速（仅 Mingw）"></a>多线程编译加速（仅 Mingw）</h2><ul>
<li>对所有项目操作，在构建套件的环境中增加<code>MAKEFLAGS=-j8</code></li>
<li>对单个项目操作，项目-&gt;构建步骤-&gt;Make 详情-&gt;Make 参数，添加：-j8</li>
</ul>
<h2 id="qrc-文件不及时更新"><a href="#qrc-文件不及时更新" class="headerlink" title="qrc 文件不及时更新"></a>qrc 文件不及时更新</h2><p>qss 文件在 qrc 资源文件中，修改 qss 文件不重新构建不会更新。可以通过修改 qrc 文件的时间属性，让编译器能够检测到文件修改并重新编译，在 qrc 文件目录下：<code>touch xxx.qrc</code>即可。</p>
<h2 id="构建库时安装到指定目录"><a href="#构建库时安装到指定目录" class="headerlink" title="构建库时安装到指定目录"></a>构建库时安装到指定目录</h2><ol>
<li>在 pro 配置的相关文件</li>
</ol>
<pre><code>target.path = $$LIB_INSTALL_ROOT/XXX
headers.path = $$INCLUDE_INSTALL_ROOT/XXX
XXX.h

INSTALLS += target \
headers
</code></pre><ol start="2">
<li>构建-&gt;添加步骤-&gt;Make-&gt;参数加上 install</li>
</ol>
<h2 id="Qt-信号连接重载写法"><a href="#Qt-信号连接重载写法" class="headerlink" title="Qt 信号连接重载写法"></a>Qt 信号连接重载写法</h2><pre><code>connect(m_pBtn, QOverload&lt;bool&gt;::of(&amp;MyButton::sigClicked),this,&amp;Widget::onClicked);
</code></pre><h2 id="修改带-UI-的界面类继承的基类"><a href="#修改带-UI-的界面类继承的基类" class="headerlink" title="修改带 UI 的界面类继承的基类"></a>修改带 UI 的界面类继承的基类</h2><ol>
<li>.h、.cpp 将父类改成 QDialog</li>
<li>ui 文件用编辑器打开， “&lt;widget class=”QWidget”…” ，将 class 值改为 QDialog</li>
</ol>
<h2 id="语言家抽取-qml-中翻译字符串"><a href="#语言家抽取-qml-中翻译字符串" class="headerlink" title="语言家抽取 qml 中翻译字符串"></a>语言家抽取 qml 中翻译字符串</h2><pre><code>//pro文件需要添加下面内容，否则不会抽取qml中字符串
lupdate_only {
SOURCES += SignIn/qml/SignInQmlView.qml
}
</code></pre><h2 id="程序图标版本号设置"><a href="#程序图标版本号设置" class="headerlink" title="程序图标版本号设置"></a>程序图标版本号设置</h2><pre><code>//pro文件中写上标记版本号+ico图标
VERSION             = 2018.7.25
win32:RC_ICONS      = main0.ico
</code></pre><h2 id="管理员运行程序，限定在-MSVC-编译器"><a href="#管理员运行程序，限定在-MSVC-编译器" class="headerlink" title="管理员运行程序，限定在 MSVC 编译器"></a>管理员运行程序，限定在 MSVC 编译器</h2><pre><code>//pro文件添加
QMAKE_LFLAGS +=/MANIFESTUAC:\&quot;level=\&#39;requireAdministrator\&#39; uiAccess=\&#39;false\&#39;\&quot; #以管理员运行
QMAKE_LFLAGS +=/SUBSYSTEM:WINDOWS,\&quot;5.01\&quot; #VS2013 在XP运行
</code></pre><h2 id="移除旧的样式"><a href="#移除旧的样式" class="headerlink" title="移除旧的样式"></a>移除旧的样式</h2><pre><code>style()-&gt;unpolish(ui-&gt;btn);
//重新设置新的该控件的样式。
style()-&gt;polish(ui-&gt;btn);
</code></pre><h2 id="获取类的属性"><a href="#获取类的属性" class="headerlink" title="获取类的属性"></a>获取类的属性</h2><pre><code>const QMetaObject *metaobject =object-&gt;metaObject();
int count = metaobject-&gt;propertyCount();
for (int i = 0; i &lt; count; ++i) {
   QMetaProperty metaproperty = metaobject-&gt;property(i);
   const char *name = metaproperty.name();
   QVariant value = object-&gt;property(name);
   qDebug() &lt;&lt; name &lt;&lt; value;
}
</code></pre><h2 id="根据操作系统判断加载"><a href="#根据操作系统判断加载" class="headerlink" title="根据操作系统判断加载"></a>根据操作系统判断加载</h2><pre><code>macx {
    QMAKE_INFO_PLIST = resource/app/Info.plist
    ICON = resource/app/fstl.icns
}

win32 {
    RC_FILE = resource/exe/fstl.rc
}

linux {
    target.path = /usr/bin
    INSTALLS += target
}
</code></pre></the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt在视频画面上绘制动态矩形]]></title>
      <url>https://longxuan.ren/2019/08/23/Qt-Video-Drawbox/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>Qt可以通过QOpenGLWidget使用OpenGL渲染显示视频，在渲染的视频画面上，有可能需要绘制一些几何图案(识别之类的画个框框那种)。目前试了3种不同的方式在画面上绘制矩形，记录下使用过程。<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="通过QPainter绘制"><a href="#通过QPainter绘制" class="headerlink" title="通过QPainter绘制"></a>通过QPainter绘制</h2><p>Qt的绘制函数<code>paintEvent(QPaintEvent *event)</code>在QOpenGLWidget中可以绘制，并且和OpenGL的内容叠在一起，只需要在绘制之前先调用下基类的<code>paintEvent(QPaintEvent *event)</code>即可，可以理解为先在画布上画好视频，再在画布上画个矩形。这种方式灵活性最好。</p>
<pre><code>void RenderWidget::paintEvent(QPaintEvent *event)
{
    QOpenGLWidget::paintEvent(event);

    qreal offset = sin(m_nCount * 0.1); //m_nCount是渲染的帧数

    QPainter painter(this);
    painter.setRenderHints(QPainter::SmoothPixmapTransform);
    painter.save();
    painter.setPen(QPen(QColor(&quot;#4FE3C1&quot;), 1, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin));
    painter.drawRect(QRectF(width() * offset, height() * 0.7, width() * 0.25, height() * 0.25));
    painter.restore();
}
</code></pre><h2 id="通过OpenGL绘制"><a href="#通过OpenGL绘制" class="headerlink" title="通过OpenGL绘制"></a>通过OpenGL绘制</h2><p>通过不同的QOpenGLShaderProgram，可以指定不同的着色器程序来实现矩形的绘制。这种方式绘制的时候，偏移量这些变化参数要通过Uniform传递给OpenGL的顶点着色器，如果图形复杂或者带3D可以考虑。</p>
<pre><code>void RenderWidget::initializeGL()
{
    initializeOpenGLFunctions();
    const char *vsrc =
            &quot;attribute vec4 vertexIn; \
             attribute vec4 textureIn; \
             varying vec4 textureOut;  \
             void main(void)           \
             {                         \
                 gl_Position = vertexIn; \
                 textureOut = textureIn; \
             }&quot;;

    const char *fsrc =
            &quot;varying mediump vec4 textureOut;\
            uniform sampler2D tex_y; \
            uniform sampler2D tex_u; \
            uniform sampler2D tex_v; \
            void main(void) \
            { \
                vec3 yuv; \
                vec3 rgb; \
                yuv.x = texture2D(tex_y, textureOut.st).r; \
                yuv.y = texture2D(tex_u, textureOut.st).r - 0.5; \
                yuv.z = texture2D(tex_v, textureOut.st).r - 0.5; \
                rgb = mat3( 1,       1,         1, \
                            0,       -0.39465,  2.03211, \
                            1.13983, -0.58060,  0) * yuv; \
                gl_FragColor = vec4(rgb, 1); \
            }&quot;;


    const char *rcvsrc = &quot;#version 330 core\n \
            layout(location = 0) in vec3 aPos;\n \
            uniform vec2 offsetP; \
            void main(){\n \
                gl_Position = vec4(aPos.x + offsetP.x, aPos.y + offsetP.y, aPos.z, 1.0f);\n \
            }\n &quot;;

    const char *rcfsrc = &quot;#version 330 core\n \
            out vec4 FragColor;\n \
            void main(){\n \
                FragColor = vec4(1.0f, 0.0f, 0.0f, 1.0f);\n \
            }\n &quot;;

    videoProgram.addCacheableShaderFromSourceCode(QOpenGLShader::Vertex,vsrc);
    videoProgram.addCacheableShaderFromSourceCode(QOpenGLShader::Fragment,fsrc);
    videoProgram.link();

    rcProgram.addShaderFromSourceCode(QOpenGLShader::Vertex,rcvsrc);
    rcProgram.addShaderFromSourceCode(QOpenGLShader::Fragment,rcfsrc);
    rcProgram.link();

    {
        QOpenGLVertexArrayObject::Binder vaoBind(&amp;rcvao);

        GLfloat rcPoints[]{
            0.25f,  0.25f, 0.0f,  // top right
             0.25f, -0.25f, 0.0f,  // bottom right
            -0.25f, -0.25f, 0.0f,  // bottom left
            -0.25f,  0.25f, 0.0f,   // top left
        };

        rcvbo.create();
        rcvbo.bind();
        rcvbo.allocate(rcPoints, sizeof(rcPoints));

        int attr = -1;
        attr = rcProgram.attributeLocation(&quot;aPos&quot;);
        rcProgram.setAttributeBuffer(attr, GL_FLOAT, 0, 3, sizeof(GLfloat) * 3);
        rcProgram.enableAttributeArray(attr);
        rcvbo.release();
    }

    {
        QOpenGLVertexArrayObject::Binder vaoBind(&amp;vao);

        GLfloat points[]{
            -1.0f, 1.0f,
             1.0f, 1.0f,
             1.0f, -1.0f,
            -1.0f, -1.0f,

            0.0f,0.0f,
            1.0f,0.0f,
            1.0f,1.0f,
            0.0f,1.0f
        };

        vbo.create();
        vbo.bind();
        vbo.allocate(points,sizeof(points));

        m_pTextureY = std::make_unique&lt;QOpenGLTexture&gt;(QOpenGLTexture::Target2D);
        m_pTextureU = std::make_unique&lt;QOpenGLTexture&gt;(QOpenGLTexture::Target2D);
        m_pTextureV = std::make_unique&lt;QOpenGLTexture&gt;(QOpenGLTexture::Target2D);
        m_pTextureY-&gt;create();
        m_pTextureU-&gt;create();
        m_pTextureV-&gt;create();

        int attr = -1;
        attr = videoProgram.attributeLocation(&quot;vertexIn&quot;);
        videoProgram.setAttributeBuffer(attr, GL_FLOAT, 0, 2, 2*sizeof(GLfloat));
        videoProgram.enableAttributeArray(attr);

        attr = videoProgram.attributeLocation(&quot;textureIn&quot;);
        videoProgram.setAttributeBuffer(attr, GL_FLOAT, 2 * 4 * sizeof(GLfloat),2,2*sizeof(GLfloat));
        videoProgram.enableAttributeArray(attr);

        vbo.release();
    }

    videoProgram.release();
    rcProgram.release();
}

void RenderWidget::render(uchar *yuvPtr, int w, int h)
{
    m_nCount++;
//    glDisable(GL_DEPTH_TEST);
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    if(nullptr == yuvPtr || 0 &gt;= w || 0 &gt;= h){
        return;
    }

    videoProgram.bind();
    {
        QOpenGLVertexArrayObject::Binder vaoBind(&amp;vao);

        //Y
        glActiveTexture(GL_TEXTURE2);
        glBindTexture(GL_TEXTURE_2D, m_pTextureY-&gt;textureId());
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RED, w, h, 0, GL_RED,GL_UNSIGNED_BYTE, yuvPtr);
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

        //U
        glActiveTexture(GL_TEXTURE1);
        glBindTexture(GL_TEXTURE_2D, m_pTextureU-&gt;textureId());
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RED, w &gt;&gt; 1, h &gt;&gt; 1, 0, GL_RED,GL_UNSIGNED_BYTE, yuvPtr + w * h);
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

        //V
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, m_pTextureV-&gt;textureId());
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RED, w &gt;&gt; 1, h &gt;&gt; 1, 0, GL_RED, GL_UNSIGNED_BYTE, yuvPtr + w * h * 5 / 4);
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

        videoProgram.setUniformValue(&quot;tex_y&quot;,2);
        videoProgram.setUniformValue(&quot;tex_u&quot;,1);
        videoProgram.setUniformValue(&quot;tex_v&quot;,0);
        glDrawArrays(GL_QUADS, 0, 4);
    }
    videoProgram.release();

    rcProgram.bind();
    {
        QOpenGLVertexArrayObject::Binder rcvaoBind(&amp;rcvao);
        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);

        float offset = sin(m_nCount * 0.1f);
        rcProgram.setUniformValue(&quot;offsetP&quot;, QVector2D(offset, 0.7f));
        glDrawArrays(GL_QUADS, 0, 4);
        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    }
    rcProgram.release();
}

void RenderWidget::resizeGL(int w, int h)
{
    glViewport(0, 0, w, h);
}
</code></pre><h2 id="通过AVFilter绘制"><a href="#通过AVFilter绘制" class="headerlink" title="通过AVFilter绘制"></a>通过AVFilter绘制</h2><p>ffmpeg的滤镜有很多强大的功能，这里就用了个最简单的drawbox, 使用滤镜的话初始化要做很多设置，另外我还没找到在哪设置可以改变绘制矩形的位置，<code>filter_descr</code>就在初始化的时候用了一次。这种方式会直接将绘制内容输出到最后的视频数据上，如果不是需要保留包含绘制内容的视频的话更倾向于上面两种方式。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre><code>  ...
    static const char *filter_descr = &quot;drawbox=x=200:y=400:w=200:h=200:color=blue&quot;;

    AVFilterContext* buffersrc_ctx = nullptr;
    AVFilterContext* buffersink_ctx = nullptr;
    AVFilterGraph* filter_graph = nullptr;
  ...

int InitFilters(const char *filters_descr)
{
    int ret;
    const AVFilter *buffersrc  = avfilter_get_by_name(&quot;buffer&quot;);
    const AVFilter *buffersink = avfilter_get_by_name(&quot;buffersink&quot;);
    AVFilterInOut *outputs = avfilter_inout_alloc();
    AVFilterInOut *inputs  = avfilter_inout_alloc();
    enum AVPixelFormat pix_fmts[] = { AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE };
    AVBufferSinkParams *buffersink_params;

    filter_graph = avfilter_graph_alloc();

    /* buffer video source: the decoded frames from the decoder will be inserted here. */
    QString args = QString(&quot;video_size=%1x%2:pix_fmt=%3:time_base=%4/%5:pixel_aspect=%6/%7&quot;)
            .arg(m_pCodecContext-&gt;width).arg(m_pCodecContext-&gt;height).arg(m_pCodecContext-&gt;pix_fmt)
            .arg(/*m_pCodecContext-&gt;time_base.num*/1).arg(30)
            .arg(/*m_pCodecContext-&gt;sample_aspect_ratio.num*/16).arg(/*m_pCodecContext-&gt;sample_aspect_ratio.den*/9);

    ret = avfilter_graph_create_filter(&amp;buffersrc_ctx, buffersrc, &quot;in&quot;,
                                       args.toStdString().c_str(), nullptr, filter_graph);
    if (ret &lt; 0) {
        qDebug() &lt;&lt; &quot;Cannot create buffer source &quot; &lt;&lt; AVErr2QString(ret);
        return ret;
    }

    /* buffer video sink: to terminate the filter chain. */
    buffersink_params = av_buffersink_params_alloc();
    buffersink_params-&gt;pixel_fmts = pix_fmts;
    ret = avfilter_graph_create_filter(&amp;buffersink_ctx, buffersink, &quot;out&quot;,
                                       nullptr, buffersink_params, filter_graph);
    av_free(buffersink_params);
    if (ret &lt; 0) {
        qDebug() &lt;&lt; &quot;Cannot create buffer sink &quot; &lt;&lt; AVErr2QString(ret);
        return ret;
    }

    /* Endpoints for the filter graph. */
    outputs-&gt;name       = av_strdup(&quot;in&quot;);
    outputs-&gt;filter_ctx = buffersrc_ctx;
    outputs-&gt;pad_idx    = 0;
    outputs-&gt;next       = nullptr;

    inputs-&gt;name       = av_strdup(&quot;out&quot;);
    inputs-&gt;filter_ctx = buffersink_ctx;
    inputs-&gt;pad_idx    = 0;
    inputs-&gt;next       = nullptr;

    if ((ret = avfilter_graph_parse_ptr(filter_graph, filters_descr,
                                    &amp;inputs, &amp;outputs, nullptr)) &lt; 0)
        return ret;

    if ((ret = avfilter_graph_config(filter_graph, nullptr)) &lt; 0)
        return ret;
    return 0;
} 

</code></pre><h3 id="解码后的AVFrame应用Filter"><a href="#解码后的AVFrame应用Filter" class="headerlink" title="解码后的AVFrame应用Filter"></a>解码后的AVFrame应用Filter</h3><pre><code>    if (av_buffersrc_add_frame(buffersrc_ctx, pFrame) &lt; 0) {
        qDebug(&quot;Error while add frame.\n&quot;);
        return;
    }

    /* pull filtered pictures from the filtergraph */
    int ret = av_buffersink_get_frame(buffersink_ctx, m_pFrameOut);//frameout中的数据就是加好滤镜的内容了
    if (ret &lt; 0)
        return;
</code></pre><h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><p>绿的QPainter绘制，红的OpenGL绘制，蓝色AVFilter绘制</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Video-Drawbox_01.png" alt="运行效果"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://blog.csdn.net/su_vast/article/details/52214642" target="_blank" rel="noopener">qt采用opengl显示yuv视频数据</a></li>
<li><a href="https://blog.csdn.net/leixiaohua1020/article/details/29368911" target="_blank" rel="noopener">最简单的基于FFmpeg的AVfilter例子（水印叠加）</a></li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> ffmpeg </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于Qt的OpenGL学习（9）—— 材质、光照贴图]]></title>
      <url>https://longxuan.ren/2019/08/15/Qt-OpenGL-LightingMaps/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>要学习OpenGL的话，强烈安利这个教程JoeyDeVries的<a href="https://learnopengl-cn.github.io/" target="_blank" rel="noopener">learnopengl</a>，这里是中文翻译好的版本。教程中使用OpenGL是通过<a href="http://www.glfw.org/download.html" target="_blank" rel="noopener">GLFW</a>这个库，而在Qt中对OpenGL封装得很好，并且和GUI以及IO相关的处理Qt更便捷，学习起来更轻松。这里就对每篇教程，在Qt在分别直接使用OpenGL的函数和Qt封装好的类以作对比。<br>教程中使用的OpenGL版本为3.3，在Qt中需要使用此版本的OpenGL只需要继承类<code>QOpenGLFunctions_3_3_Core</code>即可。如果为了在不同设备上都能用OpenGL的话，Qt提供了类<code>QOpenGLFunctions</code>，这个类包含了大部分公共的函数，可能会有个别函数不能用。 <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="对比说明"><a href="#对比说明" class="headerlink" title="对比说明"></a>对比说明</h2><h3 id="教程地址"><a href="#教程地址" class="headerlink" title="教程地址"></a>教程地址</h3><p><a href="https://learnopengl-cn.github.io/02%20Lighting/03%20Materials/" target="_blank" rel="noopener">原教程-材质</a>，<a href="https://learnopengl-cn.github.io/02%20Lighting/04%20Lighting%20maps/" target="_blank" rel="noopener">原教程-光照贴图</a>，相关知识可以点击链接学习。<br><a href="https://github.com/Longxr/LearnopenglQt" target="_blank" rel="noopener">我的工程地址</a>，每篇教程一个commit，教程-材质代码 <code>git checkout v2.3</code>，教程-光照贴图代码 <code>git checkout v2.4</code>，喜欢就点个Star吧~</p>
<h3 id="不同点-仅列出新增"><a href="#不同点-仅列出新增" class="headerlink" title="不同点 (仅列出新增)"></a>不同点 (仅列出新增)</h3><ol>
<li>之后对于增量型的教程可能就多篇合成一篇了，可自行切换commit查看，修改文件只贴出最后版。</li>
</ol>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-OpenGL-LightingMaps_01.gif" alt="材质运行结果"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-OpenGL-LightingMaps_02.png" alt="光照贴图结果"></p>
<h2 id="修改的文件"><a href="#修改的文件" class="headerlink" title="修改的文件"></a>修改的文件</h2><h3 id="QtFunctionWidget-h"><a href="#QtFunctionWidget-h" class="headerlink" title="QtFunctionWidget.h"></a>QtFunctionWidget.h</h3><pre><code>#ifndef QTFUNCTIONWIDGET_H
#define QTFUNCTIONWIDGET_H

#include &lt;QOpenGLWidget&gt;
#include &lt;QOpenGLShaderProgram&gt;
#include &lt;QOpenGLFunctions&gt;
#include &lt;QOpenGLVertexArrayObject&gt;
#include &lt;QOpenGLBuffer&gt;
#include &lt;QOpenGLTexture&gt;

#include &quot;Camera.h&quot;

class QtFunctionWidget : public QOpenGLWidget, protected QOpenGLFunctions
{
public:
    QtFunctionWidget(QWidget *parent = nullptr);
    ~QtFunctionWidget() Q_DECL_OVERRIDE;

protected:
    virtual void initializeGL() Q_DECL_OVERRIDE;
    virtual void resizeGL(int w, int h) Q_DECL_OVERRIDE;
    virtual void paintGL() Q_DECL_OVERRIDE;

    void keyPressEvent(QKeyEvent *event) Q_DECL_OVERRIDE;
    void keyReleaseEvent(QKeyEvent *event) Q_DECL_OVERRIDE;
    void mousePressEvent(QMouseEvent *event) Q_DECL_OVERRIDE;
    void mouseReleaseEvent(QMouseEvent *event) Q_DECL_OVERRIDE;
    void mouseMoveEvent(QMouseEvent *event) Q_DECL_OVERRIDE;
    void wheelEvent(QWheelEvent *event) Q_DECL_OVERRIDE;

private:
    bool createShader();
    QOpenGLTexture* loadTexture(const QString&amp; path);

private:
    QOpenGLShaderProgram lightingShader, lampShader;
    QOpenGLBuffer vbo;
    QOpenGLVertexArrayObject cubeVAO, lightVAO;
    QOpenGLTexture* m_pDiffuseMap = nullptr;
    QOpenGLTexture* m_pSpecularMap = nullptr;

    QTimer* m_pTimer = nullptr;
    int     m_nTimeValue = 0;

    // camera
    std::unique_ptr&lt;Camera&gt; camera;
    bool m_bLeftPressed;
    QPoint m_lastPos;
};

#endif // QTFUNCTIONWIDGET_H
</code></pre><h3 id="QtFunctionWidget-cpp"><a href="#QtFunctionWidget-cpp" class="headerlink" title="QtFunctionWidget.cpp"></a>QtFunctionWidget.cpp</h3><pre><code>#include &quot;QtFunctionWidget.h&quot;
#include &lt;QDebug&gt;
#include &lt;QTimer&gt;

// lighting
static QVector3D lightPos(1.2f, 1.0f, 2.0f);

QtFunctionWidget::QtFunctionWidget(QWidget *parent) : QOpenGLWidget (parent),
    vbo(QOpenGLBuffer::VertexBuffer)
{
    camera = std::make_unique&lt;Camera&gt;(QVector3D(0.0f, 0.0f, 3.0f));
    m_bLeftPressed = false;

    m_pTimer = new QTimer(this);
    connect(m_pTimer, &amp;QTimer::timeout, this, [=]{
        m_nTimeValue += 1;
        update();
    });
    m_pTimer-&gt;start(40);//25 fps
}

QtFunctionWidget::~QtFunctionWidget(){
    makeCurrent();

    lightVAO.destroy();
    cubeVAO.destroy();
    vbo.destroy();

    if (m_pDiffuseMap) {
        delete m_pDiffuseMap;
    }

    if (m_pSpecularMap) {
        delete m_pSpecularMap;
    }

    doneCurrent();
}

void QtFunctionWidget::initializeGL(){
    this-&gt;initializeOpenGLFunctions();

    createShader();

    // set up vertex data (and buffer(s)) and configure vertex attributes
    // ------------------------------------------------------------------
    float vertices[] = {
        // positions          // normals           // texture coords
        -0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  0.0f, 0.0f,
         0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  1.0f, 0.0f,
         0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  1.0f, 1.0f,
         0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  1.0f, 1.0f,
        -0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  0.0f, 1.0f,
        -0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  0.0f, 0.0f,

        -0.5f, -0.5f,  0.5f,  0.0f,  0.0f, 1.0f,   0.0f, 0.0f,
         0.5f, -0.5f,  0.5f,  0.0f,  0.0f, 1.0f,   1.0f, 0.0f,
         0.5f,  0.5f,  0.5f,  0.0f,  0.0f, 1.0f,   1.0f, 1.0f,
         0.5f,  0.5f,  0.5f,  0.0f,  0.0f, 1.0f,   1.0f, 1.0f,
        -0.5f,  0.5f,  0.5f,  0.0f,  0.0f, 1.0f,   0.0f, 1.0f,
        -0.5f, -0.5f,  0.5f,  0.0f,  0.0f, 1.0f,   0.0f, 0.0f,

        -0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f,  1.0f, 0.0f,
        -0.5f,  0.5f, -0.5f, -1.0f,  0.0f,  0.0f,  1.0f, 1.0f,
        -0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f,  0.0f, 1.0f,
        -0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f,  0.0f, 1.0f,
        -0.5f, -0.5f,  0.5f, -1.0f,  0.0f,  0.0f,  0.0f, 0.0f,
        -0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f,  1.0f, 0.0f,

         0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f,  1.0f, 0.0f,
         0.5f,  0.5f, -0.5f,  1.0f,  0.0f,  0.0f,  1.0f, 1.0f,
         0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f,  0.0f, 1.0f,
         0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f,  0.0f, 1.0f,
         0.5f, -0.5f,  0.5f,  1.0f,  0.0f,  0.0f,  0.0f, 0.0f,
         0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f,  1.0f, 0.0f,

        -0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,  0.0f, 1.0f,
         0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,  1.0f, 1.0f,
         0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,  1.0f, 0.0f,
         0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,  1.0f, 0.0f,
        -0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,  0.0f, 0.0f,
        -0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,  0.0f, 1.0f,

        -0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,  0.0f, 1.0f,
         0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,  1.0f, 1.0f,
         0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,  1.0f, 0.0f,
         0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,  1.0f, 0.0f,
        -0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,  0.0f, 0.0f,
        -0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,  0.0f, 1.0f
    };

    vbo.create();
    vbo.bind();
    vbo.allocate(vertices, sizeof(vertices));

    {
        QOpenGLVertexArrayObject::Binder vaoBind(&amp;cubeVAO);

////        position attribute
//        int attr = -1;
//        attr = lightingShader.attributeLocation(&quot;aPos&quot;);
//        lightingShader.setAttributeBuffer(attr, GL_FLOAT, 0, 3, sizeof(GLfloat) * 6);
//        lightingShader.enableAttributeArray(attr);
//        attr = lightingShader.attributeLocation(&quot;aNormal&quot;);
//        lightingShader.setAttributeBuffer(attr, GL_FLOAT, sizeof(GLfloat) * 3, 3, sizeof(GLfloat) * 6);
//        lightingShader.enableAttributeArray(attr);

        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);
        glEnableVertexAttribArray(0);
        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));
        glEnableVertexAttribArray(1);
        glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));
        glEnableVertexAttribArray(2);
    }

    {
        QOpenGLVertexArrayObject::Binder vaoBind(&amp;lightVAO);

////        position attribute
//        int attr = -1;
//        attr = lightingShader.attributeLocation(&quot;aPos&quot;);
//        lightingShader.setAttributeBuffer(attr, GL_FLOAT, 0, 3, sizeof(GLfloat) * 6);
//        lightingShader.enableAttributeArray(attr);

        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);
        glEnableVertexAttribArray(0);
    }

    // load textures (we now use a utility function to keep the code more organized)
    // -----------------------------------------------------------------------------
    m_pDiffuseMap = loadTexture(&quot;:/container2.png&quot;);
    m_pSpecularMap = loadTexture(&quot;:/container2_specular.png&quot;);

    // shader configuration
    // --------------------
    lightingShader.bind();
    lightingShader.setUniformValue(&quot;material.diffuse&quot;, 0);
    lightingShader.setUniformValue(&quot;material.specular&quot;, 1);
    lightingShader.release();

    vbo.release();

    // configure global opengl state
    // -----------------------------
    glEnable(GL_DEPTH_TEST);
}

void QtFunctionWidget::resizeGL(int w, int h){
    glViewport(0, 0, w, h);
}

void QtFunctionWidget::paintGL(){
    // input
    // -----
    camera-&gt;processInput(0.5f);//speed

    // render
    // ------
    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // be sure to activate shader when setting uniforms/drawing objects
    lightingShader.bind();
    lightingShader.setUniformValue(&quot;light.position&quot;, lightPos);
    lightingShader.setUniformValue(&quot;viewPos&quot;, camera-&gt;position);

    // light properties
    lightingShader.setUniformValue(&quot;light.ambient&quot;, QVector3D(0.2f, 0.2f, 0.2f));
    lightingShader.setUniformValue(&quot;light.diffuse&quot;, QVector3D(0.5f, 0.5f, 0.5f));
    lightingShader.setUniformValue(&quot;light.specular&quot;, QVector3D(1.0f, 1.0f, 1.0f));

    // material properties
    lightingShader.setUniformValue(&quot;material.shininess&quot;, 64.0f);

    // view/projection transformations
    QMatrix4x4 projection;
    projection.perspective(camera-&gt;zoom, 1.0f * width() / height(), 0.1f, 100.0f);
    QMatrix4x4 view = camera-&gt;getViewMatrix();
    lightingShader.setUniformValue(&quot;projection&quot;, projection);
    lightingShader.setUniformValue(&quot;view&quot;, view);

    // world transformation
    QMatrix4x4 model;
    lightingShader.setUniformValue(&quot;model&quot;, model);

    // bind diffuse map
    glActiveTexture(GL_TEXTURE0);
    m_pDiffuseMap-&gt;bind();

    // bind specular map
    glActiveTexture(GL_TEXTURE1);
    m_pSpecularMap-&gt;bind();

    {// render the cube
        QOpenGLVertexArrayObject::Binder vaoBind(&amp;cubeVAO);
        glDrawArrays(GL_TRIANGLES, 0, 36);
    }
    lightingShader.release();


    // also draw the lamp object
    lampShader.bind();
    lampShader.setUniformValue(&quot;projection&quot;, projection);
    lampShader.setUniformValue(&quot;view&quot;, view);
    model = QMatrix4x4();
    model.translate(lightPos);
    model.scale(0.2f); // a smaller cube
    lampShader.setUniformValue(&quot;model&quot;, model);
    {
        QOpenGLVertexArrayObject::Binder vaoBind(&amp;lightVAO);
        glDrawArrays(GL_TRIANGLES, 0, 36);
    }
    lampShader.release();
}

void QtFunctionWidget::keyPressEvent(QKeyEvent *event)
{
    int key = event-&gt;key();
    if (key &gt;= 0 &amp;&amp; key &lt; 1024)
        camera-&gt;keys[key] = true;
}

void QtFunctionWidget::keyReleaseEvent(QKeyEvent *event)
{
    int key = event-&gt;key();
    if (key &gt;= 0 &amp;&amp; key &lt; 1024)
        camera-&gt;keys[key] = false;
}

void QtFunctionWidget::mousePressEvent(QMouseEvent *event)
{
    if(event-&gt;button() == Qt::LeftButton){
        m_bLeftPressed = true;
        m_lastPos = event-&gt;pos();
    }
}

void QtFunctionWidget::mouseReleaseEvent(QMouseEvent *event)
{
    Q_UNUSED(event);

    m_bLeftPressed = false;
}

void QtFunctionWidget::mouseMoveEvent(QMouseEvent *event)
{
    if (m_bLeftPressed) {
        int xpos = event-&gt;pos().x();
        int ypos = event-&gt;pos().y();

        int xoffset = xpos - m_lastPos.x();
        int yoffset = m_lastPos.y() - ypos;
        m_lastPos = event-&gt;pos();
        camera-&gt;processMouseMovement(xoffset, yoffset);
    }
}

void QtFunctionWidget::wheelEvent(QWheelEvent *event)
{
    QPoint offset = event-&gt;angleDelta();
    camera-&gt;processMouseScroll(offset.y()/20.0f);
}

bool QtFunctionWidget::createShader()
{
    bool success = lightingShader.addShaderFromSourceFile(QOpenGLShader::Vertex, &quot;:/lighting_maps.vert&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; lightingShader.log();
        return success;
    }

    success = lightingShader.addShaderFromSourceFile(QOpenGLShader::Fragment, &quot;:/lighting_maps.frag&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; lightingShader.log();
        return success;
    }

    success = lightingShader.link();
    if(!success) {
        qDebug() &lt;&lt; &quot;shaderProgram link failed!&quot; &lt;&lt; lightingShader.log();
    }

    success = lampShader.addShaderFromSourceFile(QOpenGLShader::Vertex, &quot;:/lamp.vert&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; lampShader.log();
        return success;
    }

    success = lampShader.addShaderFromSourceFile(QOpenGLShader::Fragment, &quot;:/lamp.frag&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; lampShader.log();
        return success;
    }

    success = lampShader.link();
    if(!success) {
        qDebug() &lt;&lt; &quot;shaderProgram link failed!&quot; &lt;&lt; lampShader.log();
    }

    return success;
}

QOpenGLTexture *QtFunctionWidget::loadTexture(const QString &amp;path)
{
    QOpenGLTexture* pTexture = new QOpenGLTexture(QImage(path), QOpenGLTexture::GenerateMipMaps);
    if(!pTexture-&gt;isCreated()){
        qDebug() &lt;&lt; &quot;Failed to load texture&quot;;
    }
    // set the texture wrapping parameters
    pTexture-&gt;setWrapMode(QOpenGLTexture::DirectionS, QOpenGLTexture::Repeat);  //glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    pTexture-&gt;setWrapMode(QOpenGLTexture::DirectionT, QOpenGLTexture::Repeat);  //glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    // set texture filtering parameters
    pTexture-&gt;setMinificationFilter(QOpenGLTexture::Linear);   //glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    pTexture-&gt;setMagnificationFilter(QOpenGLTexture::Linear);

    return pTexture;
}
</code></pre><h2 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h2><h3 id="lighting-maps-vert"><a href="#lighting-maps-vert" class="headerlink" title="lighting_maps.vert"></a>lighting_maps.vert</h3><pre><code>#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

out vec3 FragPos;
out vec3 Normal;
out vec2 TexCoords;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;  
    TexCoords = aTexCoords;

    gl_Position = projection * view * vec4(FragPos, 1.0);
}
</code></pre><h3 id="lighting-maps-frag"><a href="#lighting-maps-frag" class="headerlink" title="lighting_maps.frag"></a>lighting_maps.frag</h3><pre><code>#version 330 core
out vec4 FragColor;

struct Material {
    sampler2D diffuse;
    sampler2D specular;    
    float shininess;
}; 

struct Light {
    vec3 position;

    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};

in vec3 FragPos;  
in vec3 Normal;  
in vec2 TexCoords;

uniform vec3 viewPos;
uniform Material material;
uniform Light light;

void main()
{
    // ambient
    vec3 ambient = light.ambient * texture(material.diffuse, TexCoords).rgb;

    // diffuse 
    vec3 norm = normalize(Normal);
    vec3 lightDir = normalize(light.position - FragPos);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = light.diffuse * diff * texture(material.diffuse, TexCoords).rgb;  

    // specular
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 reflectDir = reflect(-lightDir, norm);  
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    vec3 specular = light.specular * spec * texture(material.specular, TexCoords).rgb;  

    vec3 result = ambient + diffuse + specular;
    FragColor = vec4(result, 1.0);
} 
</code></pre></the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于Qt的OpenGL学习（8）—— 基础光照]]></title>
      <url>https://longxuan.ren/2019/08/14/Qt-OpenGL-BasicLighting/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>要学习OpenGL的话，强烈安利这个教程JoeyDeVries的<a href="https://learnopengl-cn.github.io/" target="_blank" rel="noopener">learnopengl</a>，这里是中文翻译好的版本。教程中使用OpenGL是通过<a href="http://www.glfw.org/download.html" target="_blank" rel="noopener">GLFW</a>这个库，而在Qt中对OpenGL封装得很好，并且和GUI以及IO相关的处理Qt更便捷，学习起来更轻松。这里就对每篇教程，在Qt在分别直接使用OpenGL的函数和Qt封装好的类以作对比。<br>教程中使用的OpenGL版本为3.3，在Qt中需要使用此版本的OpenGL只需要继承类<code>QOpenGLFunctions_3_3_Core</code>即可。如果为了在不同设备上都能用OpenGL的话，Qt提供了类<code>QOpenGLFunctions</code>，这个类包含了大部分公共的函数，可能会有个别函数不能用。 <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="对比说明"><a href="#对比说明" class="headerlink" title="对比说明"></a>对比说明</h2><h3 id="教程地址"><a href="#教程地址" class="headerlink" title="教程地址"></a>教程地址</h3><p><a href="https://learnopengl-cn.github.io/02%20Lighting/02%20Basic%20Lighting/" target="_blank" rel="noopener">原教程地址</a>，相关知识可以点击链接学习。<br><a href="https://github.com/Longxr/LearnopenglQt" target="_blank" rel="noopener">我的工程地址</a>，每篇教程一个commit，可以切换着看，查看本篇代码 <code>git checkout v2.2</code>，喜欢就点个Star吧~</p>
<h3 id="不同点-仅列出新增"><a href="#不同点-仅列出新增" class="headerlink" title="不同点 (仅列出新增)"></a>不同点 (仅列出新增)</h3><ol>
<li>主要是着色器中光照的各种计算，看原教程慢慢理解。</li>
</ol>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-OpenGL-BasicLighting_01.png" alt="运行结果"></p>
<h2 id="修改的文件"><a href="#修改的文件" class="headerlink" title="修改的文件"></a>修改的文件</h2><h3 id="QtFunctionWidget-h"><a href="#QtFunctionWidget-h" class="headerlink" title="QtFunctionWidget.h"></a>QtFunctionWidget.h</h3><pre><code>#ifndef QTFUNCTIONWIDGET_H
#define QTFUNCTIONWIDGET_H

#include &lt;QOpenGLWidget&gt;
#include &lt;QOpenGLShaderProgram&gt;
#include &lt;QOpenGLFunctions&gt;
#include &lt;QOpenGLVertexArrayObject&gt;
#include &lt;QOpenGLBuffer&gt;
#include &lt;QOpenGLTexture&gt;

#include &quot;Camera.h&quot;

class QtFunctionWidget : public QOpenGLWidget, protected QOpenGLFunctions
{
public:
    QtFunctionWidget(QWidget *parent = nullptr);
    ~QtFunctionWidget() Q_DECL_OVERRIDE;

protected:
    virtual void initializeGL() Q_DECL_OVERRIDE;
    virtual void resizeGL(int w, int h) Q_DECL_OVERRIDE;
    virtual void paintGL() Q_DECL_OVERRIDE;

    void keyPressEvent(QKeyEvent *event) Q_DECL_OVERRIDE;
    void keyReleaseEvent(QKeyEvent *event) Q_DECL_OVERRIDE;
    void mousePressEvent(QMouseEvent *event) Q_DECL_OVERRIDE;
    void mouseReleaseEvent(QMouseEvent *event) Q_DECL_OVERRIDE;
    void mouseMoveEvent(QMouseEvent *event) Q_DECL_OVERRIDE;
    void wheelEvent(QWheelEvent *event) Q_DECL_OVERRIDE;

private:
    bool createShader();

private:
    QOpenGLShaderProgram lightingShader, lampShader;
    QOpenGLBuffer vbo;
    QOpenGLVertexArrayObject cubeVAO, lightVAO;

    QTimer* m_pTimer = nullptr;
    int     m_nTimeValue = 0;

    // camera
    std::unique_ptr&lt;Camera&gt; camera;
    bool m_bLeftPressed;
    QPoint m_lastPos;
};

#endif // QTFUNCTIONWIDGET_H
</code></pre><h3 id="QtFunctionWidget-cpp"><a href="#QtFunctionWidget-cpp" class="headerlink" title="QtFunctionWidget.cpp"></a>QtFunctionWidget.cpp</h3><pre><code>#include &quot;QtFunctionWidget.h&quot;
#include &lt;QDebug&gt;
#include &lt;QTimer&gt;

// lighting
static QVector3D lightPos(1.2f, 1.0f, 2.0f);

QtFunctionWidget::QtFunctionWidget(QWidget *parent) : QOpenGLWidget (parent),
    vbo(QOpenGLBuffer::VertexBuffer)
{
    camera = std::make_unique&lt;Camera&gt;(QVector3D(0.0f, 0.0f, 3.0f));
    m_bLeftPressed = false;

    m_pTimer = new QTimer(this);
    connect(m_pTimer, &amp;QTimer::timeout, this, [=]{
        m_nTimeValue += 1;
        update();
    });
    m_pTimer-&gt;start(40);//25 fps
}

QtFunctionWidget::~QtFunctionWidget(){
    makeCurrent();

    lightVAO.destroy();
    cubeVAO.destroy();
    vbo.destroy();

    doneCurrent();
}

void QtFunctionWidget::initializeGL(){
    this-&gt;initializeOpenGLFunctions();

    createShader();

    // set up vertex data (and buffer(s)) and configure vertex attributes
    // ------------------------------------------------------------------
    float vertices[] = {
        -0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,
        0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,
        0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,
        0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,
        -0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,
        -0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,

        -0.5f, -0.5f,  0.5f,  0.0f,  0.0f,  1.0f,
        0.5f, -0.5f,  0.5f,  0.0f,  0.0f,  1.0f,
        0.5f,  0.5f,  0.5f,  0.0f,  0.0f,  1.0f,
        0.5f,  0.5f,  0.5f,  0.0f,  0.0f,  1.0f,
        -0.5f,  0.5f,  0.5f,  0.0f,  0.0f,  1.0f,
        -0.5f, -0.5f,  0.5f,  0.0f,  0.0f,  1.0f,

        -0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f,
        -0.5f,  0.5f, -0.5f, -1.0f,  0.0f,  0.0f,
        -0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f,
        -0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f,
        -0.5f, -0.5f,  0.5f, -1.0f,  0.0f,  0.0f,
        -0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f,

        0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f,
        0.5f,  0.5f, -0.5f,  1.0f,  0.0f,  0.0f,
        0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f,
        0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f,
        0.5f, -0.5f,  0.5f,  1.0f,  0.0f,  0.0f,
        0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f,

        -0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,
        0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,
        0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,
        0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,
        -0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,
        -0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,

        -0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,
        0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,
        0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,
        0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,
        -0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,
        -0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f
    };

    vbo.create();
    vbo.bind();
    vbo.allocate(vertices, sizeof(vertices));

    {
        QOpenGLVertexArrayObject::Binder vaoBind(&amp;cubeVAO);

////        position attribute
//        int attr = -1;
//        attr = lightingShader.attributeLocation(&quot;aPos&quot;);
//        lightingShader.setAttributeBuffer(attr, GL_FLOAT, 0, 3, sizeof(GLfloat) * 6);
//        lightingShader.enableAttributeArray(attr);
//        attr = lightingShader.attributeLocation(&quot;aNormal&quot;);
//        lightingShader.setAttributeBuffer(attr, GL_FLOAT, sizeof(GLfloat) * 3, 3, sizeof(GLfloat) * 6);
//        lightingShader.enableAttributeArray(attr);

        // position attribute
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
        glEnableVertexAttribArray(0);
        // normal attribute
        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));
        glEnableVertexAttribArray(1);
    }

    {
        QOpenGLVertexArrayObject::Binder vaoBind(&amp;lightVAO);

////        position attribute
//        int attr = -1;
//        attr = lightingShader.attributeLocation(&quot;aPos&quot;);
//        lightingShader.setAttributeBuffer(attr, GL_FLOAT, 0, 3, sizeof(GLfloat) * 6);
//        lightingShader.enableAttributeArray(attr);

        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
        glEnableVertexAttribArray(0);
    }


    vbo.release();

    // configure global opengl state
    // -----------------------------
    glEnable(GL_DEPTH_TEST);
}

void QtFunctionWidget::resizeGL(int w, int h){
    glViewport(0, 0, w, h);
}

void QtFunctionWidget::paintGL(){
    // input
    // -----
    camera-&gt;processInput(0.5f);//speed

    // render
    // ------
    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // be sure to activate shader when setting uniforms/drawing objects
    lightingShader.bind();
    lightingShader.setUniformValue(&quot;objectColor&quot;, QVector3D(1.0f, 0.5f, 0.31f));
    lightingShader.setUniformValue(&quot;lightColor&quot;,  QVector3D(1.0f, 1.0f, 1.0f));
    lightingShader.setUniformValue(&quot;lightPos&quot;, lightPos);
    lightingShader.setUniformValue(&quot;viewPos&quot;, camera-&gt;position);

    // view/projection transformations
    QMatrix4x4 projection;
    projection.perspective(camera-&gt;zoom, 1.0f * width() / height(), 0.1f, 100.0f);
    QMatrix4x4 view = camera-&gt;getViewMatrix();
    lightingShader.setUniformValue(&quot;projection&quot;, projection);
    lightingShader.setUniformValue(&quot;view&quot;, view);

    // world transformation
    QMatrix4x4 model;
    lightingShader.setUniformValue(&quot;model&quot;, model);
    {// render the cube
        QOpenGLVertexArrayObject::Binder vaoBind(&amp;cubeVAO);
        glDrawArrays(GL_TRIANGLES, 0, 36);
    }
    lightingShader.release();


    // also draw the lamp object
    lampShader.bind();
    lampShader.setUniformValue(&quot;projection&quot;, projection);
    lampShader.setUniformValue(&quot;view&quot;, view);
    model = QMatrix4x4();
    model.translate(lightPos);
    model.scale(0.2f); // a smaller cube
    lampShader.setUniformValue(&quot;model&quot;, model);
    {
        QOpenGLVertexArrayObject::Binder vaoBind(&amp;lightVAO);
        glDrawArrays(GL_TRIANGLES, 0, 36);
    }
    lampShader.release();
}

void QtFunctionWidget::keyPressEvent(QKeyEvent *event)
{
    int key = event-&gt;key();
    if (key &gt;= 0 &amp;&amp; key &lt; 1024)
        camera-&gt;keys[key] = true;
}

void QtFunctionWidget::keyReleaseEvent(QKeyEvent *event)
{
    int key = event-&gt;key();
    if (key &gt;= 0 &amp;&amp; key &lt; 1024)
        camera-&gt;keys[key] = false;
}

void QtFunctionWidget::mousePressEvent(QMouseEvent *event)
{
    if(event-&gt;button() == Qt::LeftButton){
        m_bLeftPressed = true;
        m_lastPos = event-&gt;pos();
    }
}

void QtFunctionWidget::mouseReleaseEvent(QMouseEvent *event)
{
    Q_UNUSED(event);

    m_bLeftPressed = false;
}

void QtFunctionWidget::mouseMoveEvent(QMouseEvent *event)
{
    if (m_bLeftPressed) {
        int xpos = event-&gt;pos().x();
        int ypos = event-&gt;pos().y();

        int xoffset = xpos - m_lastPos.x();
        int yoffset = m_lastPos.y() - ypos;
        m_lastPos = event-&gt;pos();
        camera-&gt;processMouseMovement(xoffset, yoffset);
    }
}

void QtFunctionWidget::wheelEvent(QWheelEvent *event)
{
    QPoint offset = event-&gt;angleDelta();
    camera-&gt;processMouseScroll(offset.y()/20.0f);
}

bool QtFunctionWidget::createShader()
{
    bool success = lightingShader.addShaderFromSourceFile(QOpenGLShader::Vertex, &quot;:/basic_lighting.vert&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; lightingShader.log();
        return success;
    }

    success = lightingShader.addShaderFromSourceFile(QOpenGLShader::Fragment, &quot;:/basic_lighting.frag&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; lightingShader.log();
        return success;
    }

    success = lightingShader.link();
    if(!success) {
        qDebug() &lt;&lt; &quot;shaderProgram link failed!&quot; &lt;&lt; lightingShader.log();
    }

    success = lampShader.addShaderFromSourceFile(QOpenGLShader::Vertex, &quot;:/lamp.vert&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; lampShader.log();
        return success;
    }

    success = lampShader.addShaderFromSourceFile(QOpenGLShader::Fragment, &quot;:/lamp.frag&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; lampShader.log();
        return success;
    }

    success = lampShader.link();
    if(!success) {
        qDebug() &lt;&lt; &quot;shaderProgram link failed!&quot; &lt;&lt; lampShader.log();
    }

    return success;
}
</code></pre><h2 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h2><h3 id="basic-lighting-vert"><a href="#basic-lighting-vert" class="headerlink" title="basic_lighting.vert"></a>basic_lighting.vert</h3><pre><code>#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;

out vec3 FragPos;
out vec3 Normal;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;

    gl_Position = projection * view * vec4(FragPos, 1.0);
}
</code></pre><h3 id="basic-lighting-frag"><a href="#basic-lighting-frag" class="headerlink" title="basic_lighting.frag"></a>basic_lighting.frag</h3><pre><code>#version 330 core
out vec4 FragColor;

in vec3 Normal;  
in vec3 FragPos;  

uniform vec3 lightPos; 
uniform vec3 viewPos; 
uniform vec3 lightColor;
uniform vec3 objectColor;

void main()
{
    // ambient
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;

    // diffuse 
    vec3 norm = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = diff * lightColor;

    // specular
    float specularStrength = 0.5;
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 reflectDir = reflect(-lightDir, norm);  
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);
    vec3 specular = specularStrength * spec * lightColor;  

    vec3 result = (ambient + diffuse + specular) * objectColor;
    FragColor = vec4(result, 1.0);
} 
</code></pre></the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于Qt的OpenGL学习（7）—— 颜色]]></title>
      <url>https://longxuan.ren/2019/08/13/Qt-OpenGL-Colors/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>要学习OpenGL的话，强烈安利这个教程JoeyDeVries的<a href="https://learnopengl-cn.github.io/" target="_blank" rel="noopener">learnopengl</a>，这里是中文翻译好的版本。教程中使用OpenGL是通过<a href="http://www.glfw.org/download.html" target="_blank" rel="noopener">GLFW</a>这个库，而在Qt中对OpenGL封装得很好，并且和GUI以及IO相关的处理Qt更便捷，学习起来更轻松。这里就对每篇教程，在Qt在分别直接使用OpenGL的函数和Qt封装好的类以作对比。<br>教程中使用的OpenGL版本为3.3，在Qt中需要使用此版本的OpenGL只需要继承类<code>QOpenGLFunctions_3_3_Core</code>即可。如果为了在不同设备上都能用OpenGL的话，Qt提供了类<code>QOpenGLFunctions</code>，这个类包含了大部分公共的函数，可能会有个别函数不能用。 <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="对比说明"><a href="#对比说明" class="headerlink" title="对比说明"></a>对比说明</h2><h3 id="教程地址"><a href="#教程地址" class="headerlink" title="教程地址"></a>教程地址</h3><p><a href="https://learnopengl-cn.github.io/02%20Lighting/01%20Colors/" target="_blank" rel="noopener">原教程地址</a>，相关知识可以点击链接学习。<br><a href="https://github.com/Longxr/LearnopenglQt" target="_blank" rel="noopener">我的工程地址</a>，每篇教程一个commit，可以切换着看，查看本篇代码 <code>git checkout v2.1</code>，喜欢就点个Star吧~</p>
<h3 id="不同点-仅列出新增"><a href="#不同点-仅列出新增" class="headerlink" title="不同点 (仅列出新增)"></a>不同点 (仅列出新增)</h3><ol>
<li>之前程序只有一个shaderProgram、VAO，直接用的shaderProgram的<code>setAttributeBuffer()</code>函数绑定VBO数据；现在有两个shaderProgram、VAO，不确定后面shaderProgram和VAO还是不是一对一的关系，还是改成默认的<code>glVertexAttribPointer()</code>函数了，两个都能用。（感觉之前的好像VAO没啥用啊，shaderprogram可以直接去绑定VBO）</li>
</ol>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-OpenGL-Colors_01.png" alt="运行结果"></p>
<h2 id="修改的文件"><a href="#修改的文件" class="headerlink" title="修改的文件"></a>修改的文件</h2><h3 id="QtFunctionWidget-h"><a href="#QtFunctionWidget-h" class="headerlink" title="QtFunctionWidget.h"></a>QtFunctionWidget.h</h3><pre><code>#ifndef QTFUNCTIONWIDGET_H
#define QTFUNCTIONWIDGET_H

#include &lt;QOpenGLWidget&gt;
#include &lt;QOpenGLShaderProgram&gt;
#include &lt;QOpenGLFunctions&gt;
#include &lt;QOpenGLVertexArrayObject&gt;
#include &lt;QOpenGLBuffer&gt;
#include &lt;QOpenGLTexture&gt;

#include &quot;Camera.h&quot;

class QtFunctionWidget : public QOpenGLWidget, protected QOpenGLFunctions
{
public:
    QtFunctionWidget(QWidget *parent = nullptr);
    ~QtFunctionWidget() Q_DECL_OVERRIDE;

protected:
    virtual void initializeGL() Q_DECL_OVERRIDE;
    virtual void resizeGL(int w, int h) Q_DECL_OVERRIDE;
    virtual void paintGL() Q_DECL_OVERRIDE;

    void keyPressEvent(QKeyEvent *event) Q_DECL_OVERRIDE;
    void keyReleaseEvent(QKeyEvent *event) Q_DECL_OVERRIDE;
    void mousePressEvent(QMouseEvent *event) Q_DECL_OVERRIDE;
    void mouseReleaseEvent(QMouseEvent *event) Q_DECL_OVERRIDE;
    void mouseMoveEvent(QMouseEvent *event) Q_DECL_OVERRIDE;
    void wheelEvent(QWheelEvent *event) Q_DECL_OVERRIDE;

private:
    bool createShader();

private:
    QOpenGLShaderProgram lightingShader, lampShader;
    QOpenGLBuffer vbo;
    QOpenGLVertexArrayObject cubeVAO, lightVAO;

    QTimer* m_pTimer = nullptr;
    int     m_nTimeValue = 0;

    // camera
    std::unique_ptr&lt;Camera&gt; camera;
    bool m_bLeftPressed;
    QPoint m_lastPos;
};

#endif // QTFUNCTIONWIDGET_H
</code></pre><h3 id="QtFunctionWidget-cpp"><a href="#QtFunctionWidget-cpp" class="headerlink" title="QtFunctionWidget.cpp"></a>QtFunctionWidget.cpp</h3><pre><code>#include &quot;QtFunctionWidget.h&quot;
#include &lt;QDebug&gt;
#include &lt;QTimer&gt;

// lighting
static QVector3D lightPos(1.2f, 1.0f, 2.0f);

QtFunctionWidget::QtFunctionWidget(QWidget *parent) : QOpenGLWidget (parent),
    vbo(QOpenGLBuffer::VertexBuffer)
{
    camera = std::make_unique&lt;Camera&gt;(QVector3D(3.0f, 0.0f, 10.0f));
    m_bLeftPressed = false;

    m_pTimer = new QTimer(this);
    connect(m_pTimer, &amp;QTimer::timeout, this, [=]{
        m_nTimeValue += 1;
        update();
    });
    m_pTimer-&gt;start(40);
}

QtFunctionWidget::~QtFunctionWidget(){
    makeCurrent();

    lightVAO.destroy();
    cubeVAO.destroy();
    vbo.destroy();

    doneCurrent();
}

void QtFunctionWidget::initializeGL(){
    this-&gt;initializeOpenGLFunctions();

    createShader();

    //VAO，VBO data
    float vertices[] = {
        -0.5f, -0.5f, -0.5f,
         0.5f, -0.5f, -0.5f,
         0.5f,  0.5f, -0.5f,
         0.5f,  0.5f, -0.5f,
        -0.5f,  0.5f, -0.5f,
        -0.5f, -0.5f, -0.5f,

        -0.5f, -0.5f,  0.5f,
         0.5f, -0.5f,  0.5f,
         0.5f,  0.5f,  0.5f,
         0.5f,  0.5f,  0.5f,
        -0.5f,  0.5f,  0.5f,
        -0.5f, -0.5f,  0.5f,

        -0.5f,  0.5f,  0.5f,
        -0.5f,  0.5f, -0.5f,
        -0.5f, -0.5f, -0.5f,
        -0.5f, -0.5f, -0.5f,
        -0.5f, -0.5f,  0.5f,
        -0.5f,  0.5f,  0.5f,

         0.5f,  0.5f,  0.5f,
         0.5f,  0.5f, -0.5f,
         0.5f, -0.5f, -0.5f,
         0.5f, -0.5f, -0.5f,
         0.5f, -0.5f,  0.5f,
         0.5f,  0.5f,  0.5f,

        -0.5f, -0.5f, -0.5f,
         0.5f, -0.5f, -0.5f,
         0.5f, -0.5f,  0.5f,
         0.5f, -0.5f,  0.5f,
        -0.5f, -0.5f,  0.5f,
        -0.5f, -0.5f, -0.5f,

        -0.5f,  0.5f, -0.5f,
         0.5f,  0.5f, -0.5f,
         0.5f,  0.5f,  0.5f,
         0.5f,  0.5f,  0.5f,
        -0.5f,  0.5f,  0.5f,
        -0.5f,  0.5f, -0.5f,
    };

    vbo.create();
    vbo.bind();
    vbo.allocate(vertices, sizeof(vertices));

    {
        QOpenGLVertexArrayObject::Binder vaoBind(&amp;cubeVAO);

//        position attribute
//        int attr = -1;
//        attr = lightingShader.attributeLocation(&quot;aPos&quot;);
//        lightingShader.setAttributeBuffer(attr, GL_FLOAT, 0, 3, sizeof(GLfloat) * 3);
//        lightingShader.enableAttributeArray(attr);
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
        glEnableVertexAttribArray(0);
    }

    {
        QOpenGLVertexArrayObject::Binder vaoBind(&amp;lightVAO);

//        position attribute
//        int attr = -1;
//        attr = lampShader.attributeLocation(&quot;aPos&quot;);
//        lampShader.setAttributeBuffer(attr, GL_FLOAT, 0, 3, sizeof(GLfloat) * 3);
//        lampShader.enableAttributeArray(attr);
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
        glEnableVertexAttribArray(0);
    }


    vbo.release();

    // configure global opengl state
    // -----------------------------
    glEnable(GL_DEPTH_TEST);
}

void QtFunctionWidget::resizeGL(int w, int h){
    glViewport(0, 0, w, h);
}

void QtFunctionWidget::paintGL(){
    // input
    // -----
    camera-&gt;processInput(1.0f);

    // render
    // ------
    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // be sure to activate shader when setting uniforms/drawing objects
    lightingShader.bind();
    lightingShader.setUniformValue(&quot;objectColor&quot;, QVector3D(1.0f, 0.5f, 0.31f));
    lightingShader.setUniformValue(&quot;lightColor&quot;,  QVector3D(1.0f, 1.0f, 1.0f));

    // view/projection transformations
    QMatrix4x4 projection;
    projection.perspective(camera-&gt;zoom, 1.0f * width() / height(), 0.1f, 100.0f);
    QMatrix4x4 view = camera-&gt;getViewMatrix();
    lightingShader.setUniformValue(&quot;projection&quot;, projection);
    lightingShader.setUniformValue(&quot;view&quot;, view);

    // world transformation
    QMatrix4x4 model;
    lightingShader.setUniformValue(&quot;model&quot;, model);
    {// render the cube
        QOpenGLVertexArrayObject::Binder vaoBind(&amp;cubeVAO);
        glDrawArrays(GL_TRIANGLES, 0, 36);
    }
    lightingShader.release();


    // also draw the lamp object
    lampShader.bind();
    lampShader.setUniformValue(&quot;projection&quot;, projection);
    lampShader.setUniformValue(&quot;view&quot;, view);
    model = QMatrix4x4();
    model.translate(lightPos);
    model.scale(0.2f); // a smaller cube
    lampShader.setUniformValue(&quot;model&quot;, model);
    {
        QOpenGLVertexArrayObject::Binder vaoBind(&amp;lightVAO);
        glDrawArrays(GL_TRIANGLES, 0, 36);
    }
    lampShader.release();
}

void QtFunctionWidget::keyPressEvent(QKeyEvent *event)
{
    int key = event-&gt;key();
    if (key &gt;= 0 &amp;&amp; key &lt; 1024)
        camera-&gt;keys[key] = true;
}

void QtFunctionWidget::keyReleaseEvent(QKeyEvent *event)
{
    int key = event-&gt;key();
    if (key &gt;= 0 &amp;&amp; key &lt; 1024)
        camera-&gt;keys[key] = false;
}

void QtFunctionWidget::mousePressEvent(QMouseEvent *event)
{
    if(event-&gt;button() == Qt::LeftButton){
        m_bLeftPressed = true;
        m_lastPos = event-&gt;pos();
    }
}

void QtFunctionWidget::mouseReleaseEvent(QMouseEvent *event)
{
    Q_UNUSED(event);

    m_bLeftPressed = false;
}

void QtFunctionWidget::mouseMoveEvent(QMouseEvent *event)
{
    if (m_bLeftPressed) {
        int xpos = event-&gt;pos().x();
        int ypos = event-&gt;pos().y();

        int xoffset = xpos - m_lastPos.x();
        int yoffset = m_lastPos.y() - ypos;
        m_lastPos = event-&gt;pos();
        camera-&gt;processMouseMovement(xoffset, yoffset);
    }
}

void QtFunctionWidget::wheelEvent(QWheelEvent *event)
{
    QPoint offset = event-&gt;angleDelta();
    camera-&gt;processMouseScroll(offset.y()/20.0f);
}

bool QtFunctionWidget::createShader()
{
    bool success = lightingShader.addShaderFromSourceFile(QOpenGLShader::Vertex, &quot;:/colors.vert&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; lightingShader.log();
        return success;
    }

    success = lightingShader.addShaderFromSourceFile(QOpenGLShader::Fragment, &quot;:/colors.frag&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; lightingShader.log();
        return success;
    }

    success = lightingShader.link();
    if(!success) {
        qDebug() &lt;&lt; &quot;shaderProgram link failed!&quot; &lt;&lt; lightingShader.log();
    }

    success = lampShader.addShaderFromSourceFile(QOpenGLShader::Vertex, &quot;:/lamp.vert&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; lampShader.log();
        return success;
    }

    success = lampShader.addShaderFromSourceFile(QOpenGLShader::Fragment, &quot;:/lamp.frag&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; lampShader.log();
        return success;
    }

    success = lampShader.link();
    if(!success) {
        qDebug() &lt;&lt; &quot;shaderProgram link failed!&quot; &lt;&lt; lampShader.log();
    }

    return success;
}
</code></pre><h2 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h2><h3 id="colors-vert"><a href="#colors-vert" class="headerlink" title="colors.vert"></a>colors.vert</h3><pre><code>#version 330 core
layout (location = 0) in vec3 aPos;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main(){
  gl_Position = projection * view * model * vec4(aPos, 1.0f);
}
</code></pre><h3 id="colors-frag"><a href="#colors-frag" class="headerlink" title="colors.frag"></a>colors.frag</h3><pre><code>#version 330 core
out vec4 FragColor;

uniform vec3 objectColor;
uniform vec3 lightColor;

void main()
{
  FragColor = vec4(objectColor * lightColor, 1.0f);
}
</code></pre><h3 id="lamp-vert"><a href="#lamp-vert" class="headerlink" title="lamp.vert"></a>lamp.vert</h3><pre><code>#version 330 core
layout (location = 0) in vec3 aPos;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main(){
  gl_Position = projection * view * model * vec4(aPos, 1.0f);
}
</code></pre><h3 id="lamp-frag"><a href="#lamp-frag" class="headerlink" title="lamp.frag"></a>lamp.frag</h3><pre><code>#version 330 core
out vec4 FragColor;

void main()
{
  FragColor = vec4(1.0f);
}
</code></pre></the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于Qt的OpenGL学习（6）—— 摄像机]]></title>
      <url>https://longxuan.ren/2019/08/12/Qt-OpenGL-Camera/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>要学习OpenGL的话，强烈安利这个教程JoeyDeVries的<a href="https://learnopengl-cn.github.io/" target="_blank" rel="noopener">learnopengl</a>，这里是中文翻译好的版本。教程中使用OpenGL是通过<a href="http://www.glfw.org/download.html" target="_blank" rel="noopener">GLFW</a>这个库，而在Qt中对OpenGL封装得很好，并且和GUI以及IO相关的处理Qt更便捷，学习起来更轻松。这里就对每篇教程，在Qt在分别直接使用OpenGL的函数和Qt封装好的类以作对比。<br>教程中使用的OpenGL版本为3.3，在Qt中需要使用此版本的OpenGL只需要继承类<code>QOpenGLFunctions_3_3_Core</code>即可。如果为了在不同设备上都能用OpenGL的话，Qt提供了类<code>QOpenGLFunctions</code>，这个类包含了大部分公共的函数，可能会有个别函数不能用。 <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="对比说明"><a href="#对比说明" class="headerlink" title="对比说明"></a>对比说明</h2><h3 id="教程地址"><a href="#教程地址" class="headerlink" title="教程地址"></a>教程地址</h3><p><a href="https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera" target="_blank" rel="noopener">原教程地址</a>，相关知识可以点击链接学习。<br><a href="https://github.com/Longxr/LearnopenglQt" target="_blank" rel="noopener">我的工程地址</a>，每篇教程一个commit，可以切换着看，查看本篇代码 <code>git checkout v1.6</code>，喜欢就点个Star吧~</p>
<h3 id="不同点-仅列出新增"><a href="#不同点-仅列出新增" class="headerlink" title="不同点 (仅列出新增)"></a>不同点 (仅列出新增)</h3><ol>
<li>Qt中封装的OpenGL相关的类之前基本都对比完了，其余部分基本还是用glxxx()的函数，后面可能就只在QtFunctionWidget.cpp中修改了。</li>
<li>我的更新是通过QTimer调用update()实现的，就没有计算教程中的时间差了。</li>
</ol>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-OpenGL-Camera_01.gif" alt="运行结果"></p>
<h2 id="修改的文件"><a href="#修改的文件" class="headerlink" title="修改的文件"></a>修改的文件</h2><h3 id="QtFunctionWidget-h"><a href="#QtFunctionWidget-h" class="headerlink" title="QtFunctionWidget.h"></a>QtFunctionWidget.h</h3><pre><code>#ifndef QTFUNCTIONWIDGET_H
#define QTFUNCTIONWIDGET_H

#include &lt;QOpenGLWidget&gt;
#include &lt;QOpenGLShaderProgram&gt;
#include &lt;QOpenGLFunctions&gt;
#include &lt;QOpenGLVertexArrayObject&gt;
#include &lt;QOpenGLBuffer&gt;
#include &lt;QOpenGLTexture&gt;

#include &quot;Camera.h&quot;

class QtFunctionWidget : public QOpenGLWidget, protected QOpenGLFunctions
{
public:
    QtFunctionWidget(QWidget *parent = nullptr);
    ~QtFunctionWidget() Q_DECL_OVERRIDE;

protected:
    virtual void initializeGL() Q_DECL_OVERRIDE;
    virtual void resizeGL(int w, int h) Q_DECL_OVERRIDE;
    virtual void paintGL() Q_DECL_OVERRIDE;

    void keyPressEvent(QKeyEvent *event) Q_DECL_OVERRIDE;
    void keyReleaseEvent(QKeyEvent *event) Q_DECL_OVERRIDE;
    void mousePressEvent(QMouseEvent *event) Q_DECL_OVERRIDE;
    void mouseReleaseEvent(QMouseEvent *event) Q_DECL_OVERRIDE;
    void mouseMoveEvent(QMouseEvent *event) Q_DECL_OVERRIDE;
    void wheelEvent(QWheelEvent *event) Q_DECL_OVERRIDE;

private:
    QOpenGLShaderProgram shaderProgram;
    QOpenGLBuffer vbo;
    QOpenGLVertexArrayObject vao;
    QOpenGLTexture *texture1 = nullptr;
    QOpenGLTexture *texture2 = nullptr;

    QTimer* m_pTimer = nullptr;
    int     m_nTimeValue = 0;

    // camera
    std::unique_ptr&lt;Camera&gt; camera;
    bool m_bLeftPressed;
    QPoint m_lastPos;
};

#endif // QTFUNCTIONWIDGET_H
</code></pre><h3 id="QtFunctionWidget-cpp"><a href="#QtFunctionWidget-cpp" class="headerlink" title="QtFunctionWidget.cpp"></a>QtFunctionWidget.cpp</h3><pre><code>#include &quot;QtFunctionWidget.h&quot;
#include &lt;QDebug&gt;
#include &lt;QTimer&gt;

QtFunctionWidget::QtFunctionWidget(QWidget *parent) : QOpenGLWidget (parent),
    vbo(QOpenGLBuffer::VertexBuffer)
{
    camera = std::make_unique&lt;Camera&gt;(QVector3D(5.0f, 0.0f, 10.0f));
    m_bLeftPressed = false;

    m_pTimer = new QTimer(this);
    connect(m_pTimer, &amp;QTimer::timeout, this, [=]{
        m_nTimeValue += 1;
        update();
    });
    m_pTimer-&gt;start(40);
}

QtFunctionWidget::~QtFunctionWidget(){
    makeCurrent();

    vbo.destroy();
    vao.destroy();

    delete texture1;
    delete texture2;

    doneCurrent();
}

void QtFunctionWidget::initializeGL(){
    this-&gt;initializeOpenGLFunctions();

    bool success = shaderProgram.addShaderFromSourceFile(QOpenGLShader::Vertex, &quot;:/textures.vert&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; shaderProgram.log();
        return;
    }

    success = shaderProgram.addShaderFromSourceFile(QOpenGLShader::Fragment, &quot;:/textures.frag&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; shaderProgram.log();
        return;
    }

    success = shaderProgram.link();
    if(!success) {
        qDebug() &lt;&lt; &quot;shaderProgram link failed!&quot; &lt;&lt; shaderProgram.log();
    }

    //VAO，VBO data
    float vertices[] = {
        -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,
         0.5f, -0.5f, -0.5f,  1.0f, 0.0f,
         0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
         0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
        -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
        -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,

        -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
         0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
         0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
         0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
        -0.5f,  0.5f,  0.5f,  0.0f, 1.0f,
        -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,

        -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
        -0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
        -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
        -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
        -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
        -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

         0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
         0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
         0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
         0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
         0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
         0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

        -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
         0.5f, -0.5f, -0.5f,  1.0f, 1.0f,
         0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
         0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
        -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
        -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,

        -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
         0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
         0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
         0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
        -0.5f,  0.5f,  0.5f,  0.0f, 0.0f,
        -0.5f,  0.5f, -0.5f,  0.0f, 1.0f
    };

    QOpenGLVertexArrayObject::Binder vaoBind(&amp;vao);

    vbo.create();
    vbo.bind();
    vbo.allocate(vertices, sizeof(vertices));

    // position attribute
    int attr = -1;
    attr = shaderProgram.attributeLocation(&quot;aPos&quot;);
    shaderProgram.setAttributeBuffer(attr, GL_FLOAT, 0, 3, sizeof(GLfloat) * 5);
    shaderProgram.enableAttributeArray(attr);
    // texture coord attribute
    attr = shaderProgram.attributeLocation(&quot;aTexCoord&quot;);
    shaderProgram.setAttributeBuffer(attr, GL_FLOAT, sizeof(GLfloat) * 3, 2, sizeof(GLfloat) * 5);
    shaderProgram.enableAttributeArray(attr);

    // texture 1
    // ---------
    texture1 = new QOpenGLTexture(QImage(&quot;:/container.jpg&quot;), QOpenGLTexture::GenerateMipMaps);
    if(!texture1-&gt;isCreated()){
        qDebug() &lt;&lt; &quot;Failed to load texture&quot;;
    }
    // set the texture wrapping parameters
    texture1-&gt;setWrapMode(QOpenGLTexture::DirectionS, QOpenGLTexture::Repeat);
    texture1-&gt;setWrapMode(QOpenGLTexture::DirectionT, QOpenGLTexture::Repeat);
    // set texture filtering parameters
    texture1-&gt;setMinificationFilter(QOpenGLTexture::Linear);
    texture1-&gt;setMagnificationFilter(QOpenGLTexture::Linear);

    // texture 2
    // ---------
    texture2 = new QOpenGLTexture(QImage(&quot;:/awesomeface.png&quot;).mirrored(true, true), QOpenGLTexture::GenerateMipMaps);
    if(!texture2-&gt;isCreated()){
        qDebug() &lt;&lt; &quot;Failed to load texture&quot;;
    }
    // set the texture wrapping parameters
    texture2-&gt;setWrapMode(QOpenGLTexture::DirectionS, QOpenGLTexture::Repeat);
    texture2-&gt;setWrapMode(QOpenGLTexture::DirectionT, QOpenGLTexture::Repeat);
    // set texture filtering parameters
    texture2-&gt;setMinificationFilter(QOpenGLTexture::Linear);
    texture1-&gt;setMagnificationFilter(QOpenGLTexture::Linear);

    // tell opengl for each sampler to which texture unit it belongs to (only has to be done once)
    shaderProgram.bind();   // don&#39;t forget to activate/use the shader before setting uniforms!
    shaderProgram.setUniformValue(&quot;texture1&quot;, 0);
    shaderProgram.setUniformValue(&quot;texture2&quot;, 1);

    vbo.release();

    // configure global opengl state
    // -----------------------------
    glEnable(GL_DEPTH_TEST);
}

void QtFunctionWidget::resizeGL(int w, int h){
    glViewport(0, 0, w, h);
}

static QVector3D cubePositions[] = {
  QVector3D( 0.0f,  0.0f,  0.0f),
  QVector3D( 2.0f,  5.0f, -15.0f),
  QVector3D(-1.5f, -2.2f, -2.5f),
  QVector3D(-3.8f, -2.0f, -12.3f),
  QVector3D( 2.4f, -0.4f, -3.5f),
  QVector3D(-1.7f,  3.0f, -7.5f),
  QVector3D( 1.3f, -2.0f, -2.5f),
  QVector3D( 1.5f,  2.0f, -2.5f),
  QVector3D( 1.5f,  0.2f, -1.5f),
  QVector3D(-1.3f,  1.0f, -1.5f)
};

void QtFunctionWidget::paintGL(){
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // also clear the depth buffer now!

    camera-&gt;processInput(1.0f);

    // bind textures on corresponding texture units
    glActiveTexture(GL_TEXTURE0);
    texture1-&gt;bind();
    glActiveTexture(GL_TEXTURE1);
    texture2-&gt;bind();

    shaderProgram.bind();

    QMatrix4x4 projection;
    projection.perspective(camera-&gt;zoom, 1.0f * width() / height(), 0.1f, 100.f);
    shaderProgram.setUniformValue(&quot;projection&quot;, projection);

    // camera/view transformation
    shaderProgram.setUniformValue(&quot;view&quot;, camera-&gt;getViewMatrix());

    {// render box
        QOpenGLVertexArrayObject::Binder vaoBind(&amp;vao);

        for (unsigned int i = 0; i &lt; 10; i++) {
           // calculate the model matrix for each object and pass it to shader before drawing
           QMatrix4x4 model;
           model.translate(cubePositions[i]);
           float angle = (i + 1.0f) * m_nTimeValue;
           model.rotate(angle, QVector3D(1.0f, 0.3f, 0.5f));
           shaderProgram.setUniformValue(&quot;model&quot;, model);
           glDrawArrays(GL_TRIANGLES, 0, 36);
        }
    }

    texture1-&gt;release();
    texture2-&gt;release();
    shaderProgram.release();
}

void QtFunctionWidget::keyPressEvent(QKeyEvent *event)
{
    int key = event-&gt;key();
    if (key &gt;= 0 &amp;&amp; key &lt; 1024)
        camera-&gt;keys[key] = true;
}

void QtFunctionWidget::keyReleaseEvent(QKeyEvent *event)
{
    int key = event-&gt;key();
    if (key &gt;= 0 &amp;&amp; key &lt; 1024)
        camera-&gt;keys[key] = false;
}

void QtFunctionWidget::mousePressEvent(QMouseEvent *event)
{
    if(event-&gt;button() == Qt::LeftButton){
        m_bLeftPressed = true;
        m_lastPos = event-&gt;pos();
    }
}

void QtFunctionWidget::mouseReleaseEvent(QMouseEvent *event)
{
    Q_UNUSED(event);

    m_bLeftPressed = false;
}

void QtFunctionWidget::mouseMoveEvent(QMouseEvent *event)
{
    if (m_bLeftPressed) {
        int xpos = event-&gt;pos().x();
        int ypos = event-&gt;pos().y();

        int xoffset = xpos - m_lastPos.x();
        int yoffset = m_lastPos.y() - ypos;
        m_lastPos = event-&gt;pos();
        camera-&gt;processMouseMovement(xoffset, yoffset);
    }
}

void QtFunctionWidget::wheelEvent(QWheelEvent *event)
{
    QPoint offset = event-&gt;angleDelta();
    camera-&gt;processMouseScroll(offset.y()/20.0f);
}
</code></pre><h3 id="Camera-h"><a href="#Camera-h" class="headerlink" title="Camera.h"></a>Camera.h</h3><pre><code>#ifndef CAMERA_H
#define CAMERA_H

#include &lt;QVector3D&gt;
#include &lt;QMatrix4x4&gt;
#include &lt;QKeyEvent&gt;

// Defines several possible options for camera movement. Used as abstraction to stay away from window-system specific input methods
enum Camera_Movement {
  FORWARD,
  BACKWARD,
  LEFT,
  RIGHT,
  UP,
  DOWN
};

// Default camera values
const float YAW = -90.0f;
const float PITCH = 0.0f;
const float SPEED = 1.0f;
const float SENSITIVITY = 0.01f;
const float ZOOM = 45.0f;

class Camera {
public:
    Camera(QVector3D position = QVector3D(0.0f, 0.0f, 0.0f), QVector3D up = QVector3D(0.0f, 1.0f, 0.0f),
    float yaw = YAW, float pitch = PITCH);
    ~Camera();

    QMatrix4x4 getViewMatrix();
    void processMouseMovement(float xoffset, float yoffset, bool constraintPitch = true);
    void processMouseScroll(float yoffset);
    void processInput(float dt);

    QVector3D position;
    QVector3D worldUp;
    QVector3D front;

    QVector3D up;
    QVector3D right;

    //Eular Angles
    float picth;
    float yaw;

    //Camera options
    float movementSpeed;
    float mouseSensitivity;
    float zoom;

    //Keyboard multi-touch
    bool keys[1024];
private:
    void updateCameraVectors();
    void processKeyboard(Camera_Movement direction, float deltaTime);
};

#endif // CAMERA_H
</code></pre><h3 id="Camera-cpp"><a href="#Camera-cpp" class="headerlink" title="Camera.cpp"></a>Camera.cpp</h3><pre><code>#include &quot;Camera.h&quot;
#include &lt;QDebug&gt;

Camera::Camera(QVector3D position, QVector3D up, float yaw, float pitch) :
    position(position),
    worldUp(up),
    front(-position),
    picth(pitch),
    yaw(yaw),
    movementSpeed(SPEED),
    mouseSensitivity(SENSITIVITY),
    zoom(ZOOM) {
    this-&gt;updateCameraVectors();

    for(uint i = 0; i != 1024; ++i)
        keys[i] = false;
}

Camera::~Camera()
{

}

// Returns the view matrix calculated using Euler Angles and the LookAt Matrix
QMatrix4x4 Camera::getViewMatrix()
{
    QMatrix4x4 view;
    view.lookAt(this-&gt;position, this-&gt;position + this-&gt;front, this-&gt;up);
    return view;
}

// Processes input received from any keyboard-like input system. Accepts input parameter in the form of camera defined ENUM (to abstract it from windowing systems)
void Camera::processKeyboard(Camera_Movement direction, float deltaTime)
{
    float velocity = this-&gt;movementSpeed * deltaTime;
    if (direction == FORWARD)
        this-&gt;position += this-&gt;front * velocity;
    if (direction == BACKWARD)
        this-&gt;position -= this-&gt;front * velocity;
  if (direction == LEFT)
    this-&gt;position -= this-&gt;right * velocity;
  if (direction == RIGHT)
    this-&gt;position += this-&gt;right * velocity;
  if (direction == UP)
    this-&gt;position += this-&gt;worldUp * velocity;
  if (direction == DOWN)
    this-&gt;position -= this-&gt;worldUp * velocity;
}

// Processes input received from a mouse input system. Expects the offset value in both the x and y direction.
void Camera::processMouseMovement(float xoffset, float yoffset, bool constraintPitch)
{
  xoffset *= this-&gt;mouseSensitivity;
  yoffset *= this-&gt;mouseSensitivity;

  this-&gt;yaw += xoffset;
  this-&gt;picth += yoffset;

  if (constraintPitch) {
    if (this-&gt;picth &gt; 89.0f)
      this-&gt;picth = 89.0f;
    if (this-&gt;picth &lt; -89.0f)
      this-&gt;picth = -89.0f;
  }

  this-&gt;updateCameraVectors();
}

// Processes input received from a mouse scroll-wheel event. Only requires input on the vertical wheel-axis
void Camera::processMouseScroll(float yoffset)
{
  if (this-&gt;zoom &gt;= 1.0f &amp;&amp; this-&gt;zoom &lt;= 45.0f)
    this-&gt;zoom -= yoffset;
  if (this-&gt;zoom &gt; 45.0f)
    this-&gt;zoom = 45.0f;
  if (this-&gt;zoom &lt; 1.0f)
      this-&gt;zoom = 1.0f;
}

void Camera::processInput(float dt)
{

    if (keys[Qt::Key_W])
      processKeyboard(FORWARD, dt);
    if (keys[Qt::Key_S])
      processKeyboard(BACKWARD, dt);
    if (keys[Qt::Key_A])
      processKeyboard(LEFT, dt);
    if (keys[Qt::Key_D])
      processKeyboard(RIGHT, dt);
    if (keys[Qt::Key_E])
      processKeyboard(UP, dt);
    if (keys[Qt::Key_Q])
      processKeyboard(DOWN, dt);
}

void Camera::updateCameraVectors()
{
    // Calculate the new Front vector
    QVector3D front;
    front.setX(cos(this-&gt;yaw) * cos(this-&gt;picth));
    front.setY(sin(this-&gt;picth));
    front.setZ(sin(this-&gt;yaw) * cos(this-&gt;picth));
    this-&gt;front = front.normalized();
    this-&gt;right = QVector3D::crossProduct(this-&gt;front, this-&gt;worldUp).normalized();
    this-&gt;up = QVector3D::crossProduct(this-&gt;right, this-&gt;front).normalized();
}
</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://blog.csdn.net/z136411501/article/details/79939695" target="_blank" rel="noopener">https://blog.csdn.net/z136411501/article/details/79939695</a></li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于Qt的OpenGL学习（5）—— 坐标系统]]></title>
      <url>https://longxuan.ren/2019/08/09/Qt-OpenGL-Coordinate-Systems/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>要学习OpenGL的话，强烈安利这个教程JoeyDeVries的<a href="https://learnopengl-cn.github.io/" target="_blank" rel="noopener">learnopengl</a>，这里是中文翻译好的版本。教程中使用OpenGL是通过<a href="http://www.glfw.org/download.html" target="_blank" rel="noopener">GLFW</a>这个库，而在Qt中对OpenGL封装得很好，并且和GUI以及IO相关的处理Qt更便捷，学习起来更轻松。这里就对每篇教程，在Qt在分别直接使用OpenGL的函数和Qt封装好的类以作对比。<br>教程中使用的OpenGL版本为3.3，在Qt中需要使用此版本的OpenGL只需要继承类<code>QOpenGLFunctions_3_3_Core</code>即可。如果为了在不同设备上都能用OpenGL的话，Qt提供了类<code>QOpenGLFunctions</code>，这个类包含了大部分公共的函数，可能会有个别函数不能用。 <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="对比说明"><a href="#对比说明" class="headerlink" title="对比说明"></a>对比说明</h2><h3 id="教程地址"><a href="#教程地址" class="headerlink" title="教程地址"></a>教程地址</h3><p><a href="https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/" target="_blank" rel="noopener">原教程地址</a>，相关知识可以点击链接学习。<br><a href="https://github.com/Longxr/LearnopenglQt" target="_blank" rel="noopener">我的工程地址</a>，每篇教程一个commit，可以切换着看，查看本篇代码 <code>git checkout v1.5</code>，喜欢就点个Star吧~</p>
<h3 id="不同点-仅列出新增"><a href="#不同点-仅列出新增" class="headerlink" title="不同点 (仅列出新增)"></a>不同点 (仅列出新增)</h3><ol>
<li>view、projection矩阵只需要初始化一次，就放到了<code>initializeGL()</code>中。</li>
<li>原教程最中间的矩形不转是因为教程里循环赋值角度第0个时：angle = 0 * value。</li>
</ol>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-OpenGL-Coordinate-Systems_01.gif" alt="运行结果"></p>
<h2 id="使用OpenGL函数版"><a href="#使用OpenGL函数版" class="headerlink" title="使用OpenGL函数版"></a>使用OpenGL函数版</h2><h3 id="CoreFunctionWidget-h"><a href="#CoreFunctionWidget-h" class="headerlink" title="CoreFunctionWidget.h"></a>CoreFunctionWidget.h</h3><pre><code>#ifndef COREFUNCTIONWIDGET_H
#define COREFUNCTIONWIDGET_H

#include &lt;QOpenGLWidget&gt;
#include &lt;QOpenGLExtraFunctions&gt;
#include &lt;QOpenGLFunctions_3_3_Core&gt;
#include &lt;QOpenGLShader&gt;
#include &lt;QOpenGLShaderProgram&gt;

class CoreFunctionWidget : public QOpenGLWidget
                           , protected /*QOpenGLExtraFunctions*/QOpenGLFunctions_3_3_Core
{
    Q_OBJECT
public:
    explicit CoreFunctionWidget(QWidget *parent = nullptr);
    ~CoreFunctionWidget();

protected:
    virtual void initializeGL();
    virtual void resizeGL(int w, int h);
    virtual void paintGL();

private:
    QOpenGLShaderProgram shaderProgram;

    QTimer* m_pTimer = nullptr;
    int     m_nTimeValue = 0;
};

#endif // COREFUNCTIONWIDGET_H
</code></pre><h3 id="CoreFunctionWidget-cpp"><a href="#CoreFunctionWidget-cpp" class="headerlink" title="CoreFunctionWidget.cpp"></a>CoreFunctionWidget.cpp</h3><pre><code>#include &quot;CoreFunctionWidget.h&quot;
#include &lt;QDebug&gt;
#include &lt;QTimer&gt;

static GLuint VBO, VAO, texture1, texture2;

CoreFunctionWidget::CoreFunctionWidget(QWidget *parent) : QOpenGLWidget(parent)
{
    m_pTimer = new QTimer(this);
    connect(m_pTimer, &amp;QTimer::timeout, this, [=]{
        m_nTimeValue += 1;
        update();
    });
    m_pTimer-&gt;start(40);
}

CoreFunctionWidget::~CoreFunctionWidget()
{
    glDeleteVertexArrays(1, &amp;VAO);
    glDeleteBuffers(1, &amp;VBO);
}

void CoreFunctionWidget::initializeGL(){
    this-&gt;initializeOpenGLFunctions();

    bool success = shaderProgram.addShaderFromSourceFile(QOpenGLShader::Vertex, &quot;:/textures.vert&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; shaderProgram.log();
        return;
    }

    success = shaderProgram.addShaderFromSourceFile(QOpenGLShader::Fragment, &quot;:/textures.frag&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; shaderProgram.log();
        return;
    }

    success = shaderProgram.link();
    if(!success) {
        qDebug() &lt;&lt; &quot;shaderProgram link failed!&quot; &lt;&lt; shaderProgram.log();
    }

    // configure global opengl state
    // -----------------------------
    glEnable(GL_DEPTH_TEST);

    //VAO，VBO data
    float vertices[] = {
        -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,
         0.5f, -0.5f, -0.5f,  1.0f, 0.0f,
         0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
         0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
        -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
        -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,

        -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
         0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
         0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
         0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
        -0.5f,  0.5f,  0.5f,  0.0f, 1.0f,
        -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,

        -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
        -0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
        -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
        -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
        -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
        -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

         0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
         0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
         0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
         0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
         0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
         0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

        -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
         0.5f, -0.5f, -0.5f,  1.0f, 1.0f,
         0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
         0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
        -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
        -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,

        -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
         0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
         0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
         0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
        -0.5f,  0.5f,  0.5f,  0.0f, 0.0f,
        -0.5f,  0.5f, -0.5f,  0.0f, 1.0f
    };

    glGenVertexArrays(1, &amp;VAO);
    glGenBuffers(1, &amp;VBO);
    // bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s).
    glBindVertexArray(VAO);

    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

    // position attribute
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);
    // texture coord attribute
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);

    // texture 1
    // ---------
    glGenTextures(1, &amp;texture1);
    glBindTexture(GL_TEXTURE_2D, texture1);
     // set the texture wrapping parameters
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   // set texture wrapping to GL_REPEAT (default wrapping method)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    // set texture filtering parameters
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    // load image, create texture and generate mipmaps
    QImage img1 = QImage(&quot;:/container.jpg&quot;).convertToFormat(QImage::Format_RGB888);
    if (!img1.isNull()) {
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, img1.width(), img1.height(), 0, GL_RGB, GL_UNSIGNED_BYTE, img1.bits());
        glGenerateMipmap(GL_TEXTURE_2D);
    }

    // texture 2
    // ---------
    glGenTextures(1, &amp;texture2);
    glBindTexture(GL_TEXTURE_2D, texture2);
    // set the texture wrapping parameters
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   // set texture wrapping to GL_REPEAT (default wrapping method)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    // set texture filtering parameters
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    // load image, create texture and generate mipmaps
    QImage img2 = QImage(&quot;:/awesomeface.png&quot;).convertToFormat(QImage::Format_RGBA8888).mirrored(true, true);
    if (!img2.isNull()) {
        // note that the awesomeface.png has transparency and thus an alpha channel, so make sure to tell OpenGL the data type is of GL_RGBA
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, img2.width(), img2.height(), 0, GL_RGBA, GL_UNSIGNED_BYTE, img2.bits());
        glGenerateMipmap(GL_TEXTURE_2D);
    }

    shaderProgram.bind();   // don&#39;t forget to activate/use the shader before setting uniforms!
    // tell opengl for each sampler to which texture unit it belongs to (only has to be done once)
    shaderProgram.setUniformValue(&quot;texture1&quot;, 0);
    shaderProgram.setUniformValue(&quot;texture2&quot;, 1);
    // note: currently we set the projection matrix each frame, but since the projection matrix rarely changes it&#39;s often best practice to set it outside the main loop only once.
    QMatrix4x4 view;
    view.translate(QVector3D(0.0f, 0.0f, -3.0f));
    shaderProgram.setUniformValue(&quot;view&quot;, view);
    QMatrix4x4 projection;
    projection.perspective(45.0f, 1.0f * width() / height(), 0.1f, 100.0f);
    shaderProgram.setUniformValue(&quot;projection&quot;, projection);
    shaderProgram.release();
}

void CoreFunctionWidget::resizeGL(int w, int h){
    glViewport(0, 0, w, h);
}


static QVector3D cubePositions[] = {
  QVector3D( 0.0f,  0.0f,  0.0f),
  QVector3D( 2.0f,  5.0f, -15.0f),
  QVector3D(-1.5f, -2.2f, -2.5f),
  QVector3D(-3.8f, -2.0f, -12.3f),
  QVector3D( 2.4f, -0.4f, -3.5f),
  QVector3D(-1.7f,  3.0f, -7.5f),
  QVector3D( 1.3f, -2.0f, -2.5f),
  QVector3D( 1.5f,  2.0f, -2.5f),
  QVector3D( 1.5f,  0.2f, -1.5f),
  QVector3D(-1.3f,  1.0f, -1.5f)
};

void CoreFunctionWidget::paintGL(){
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // also clear the depth buffer now!

    // bind textures on corresponding texture units
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, texture1);
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, texture2);

    shaderProgram.bind();
    // render boxes
    glBindVertexArray(VAO);
    for (unsigned int i = 0; i &lt; 10; i++) {
       // calculate the model matrix for each object and pass it to shader before drawing
       QMatrix4x4 model;
       model.translate(cubePositions[i]);
       float angle = (i + 1.0f) * m_nTimeValue;
       model.rotate(angle, QVector3D(1.0f, 0.3f, 0.5f));
       shaderProgram.setUniformValue(&quot;model&quot;, model);
       glDrawArrays(GL_TRIANGLES, 0, 36);
    }

    shaderProgram.release();
}
</code></pre><h2 id="使用Qt相关函数版"><a href="#使用Qt相关函数版" class="headerlink" title="使用Qt相关函数版"></a>使用Qt相关函数版</h2><h3 id="QtFunctionWidget-h"><a href="#QtFunctionWidget-h" class="headerlink" title="QtFunctionWidget.h"></a>QtFunctionWidget.h</h3><pre><code>#ifndef QTFUNCTIONWIDGET_H
#define QTFUNCTIONWIDGET_H

#include &lt;QOpenGLWidget&gt;


#include &lt;QOpenGLWidget&gt;
#include &lt;QOpenGLShader&gt;
#include &lt;QOpenGLShaderProgram&gt;
#include &lt;QOpenGLFunctions&gt;
#include &lt;QOpenGLVertexArrayObject&gt;
#include &lt;QOpenGLBuffer&gt;
#include &lt;QOpenGLTexture&gt;

class QtFunctionWidget : public QOpenGLWidget, protected QOpenGLFunctions
{
public:
    QtFunctionWidget(QWidget *parent = nullptr);
    ~QtFunctionWidget() Q_DECL_OVERRIDE;

protected:
    virtual void initializeGL() Q_DECL_OVERRIDE;
    virtual void resizeGL(int w, int h) Q_DECL_OVERRIDE;
    virtual void paintGL() Q_DECL_OVERRIDE;

private:
    QOpenGLShaderProgram shaderProgram;
    QOpenGLBuffer vbo;
    QOpenGLVertexArrayObject vao;
    QOpenGLTexture *texture1 = nullptr;
    QOpenGLTexture *texture2 = nullptr;

    QTimer* m_pTimer = nullptr;
    int     m_nTimeValue = 0;
};

#endif // QTFUNCTIONWIDGET_H
</code></pre><h3 id="QtFunctionWidget-cpp"><a href="#QtFunctionWidget-cpp" class="headerlink" title="QtFunctionWidget.cpp"></a>QtFunctionWidget.cpp</h3><pre><code>#include &quot;QtFunctionWidget.h&quot;
#include &lt;QDebug&gt;
#include &lt;QTimer&gt;

QtFunctionWidget::QtFunctionWidget(QWidget *parent) : QOpenGLWidget (parent),
    vbo(QOpenGLBuffer::VertexBuffer)
{
    m_pTimer = new QTimer(this);
    connect(m_pTimer, &amp;QTimer::timeout, this, [=]{
        m_nTimeValue += 1;
        update();
    });
    m_pTimer-&gt;start(40);
}

QtFunctionWidget::~QtFunctionWidget(){
    makeCurrent();

    vbo.destroy();
    vao.destroy();

    delete texture1;
    delete texture2;

    doneCurrent();
}

void QtFunctionWidget::initializeGL(){
    this-&gt;initializeOpenGLFunctions();

    bool success = shaderProgram.addShaderFromSourceFile(QOpenGLShader::Vertex, &quot;:/textures.vert&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; shaderProgram.log();
        return;
    }

    success = shaderProgram.addShaderFromSourceFile(QOpenGLShader::Fragment, &quot;:/textures.frag&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; shaderProgram.log();
        return;
    }

    success = shaderProgram.link();
    if(!success) {
        qDebug() &lt;&lt; &quot;shaderProgram link failed!&quot; &lt;&lt; shaderProgram.log();
    }

    // configure global opengl state
    // -----------------------------
    glEnable(GL_DEPTH_TEST);

    //VAO，VBO data
    float vertices[] = {
        -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,
         0.5f, -0.5f, -0.5f,  1.0f, 0.0f,
         0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
         0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
        -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
        -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,

        -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
         0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
         0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
         0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
        -0.5f,  0.5f,  0.5f,  0.0f, 1.0f,
        -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,

        -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
        -0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
        -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
        -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
        -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
        -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

         0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
         0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
         0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
         0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
         0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
         0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

        -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
         0.5f, -0.5f, -0.5f,  1.0f, 1.0f,
         0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
         0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
        -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
        -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,

        -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
         0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
         0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
         0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
        -0.5f,  0.5f,  0.5f,  0.0f, 0.0f,
        -0.5f,  0.5f, -0.5f,  0.0f, 1.0f
    };

    QOpenGLVertexArrayObject::Binder vaoBind(&amp;vao);

    vbo.create();
    vbo.bind();
    vbo.allocate(vertices, sizeof(vertices));

    // position attribute
    int attr = -1;
    attr = shaderProgram.attributeLocation(&quot;aPos&quot;);
    shaderProgram.setAttributeBuffer(attr, GL_FLOAT, 0, 3, sizeof(GLfloat) * 5);
    shaderProgram.enableAttributeArray(attr);
    // texture coord attribute
    attr = shaderProgram.attributeLocation(&quot;aTexCoord&quot;);
    shaderProgram.setAttributeBuffer(attr, GL_FLOAT, sizeof(GLfloat) * 3, 2, sizeof(GLfloat) * 5);
    shaderProgram.enableAttributeArray(attr);

    // texture 1
    // ---------
    texture1 = new QOpenGLTexture(QImage(&quot;:/container.jpg&quot;), QOpenGLTexture::GenerateMipMaps);
    if(!texture1-&gt;isCreated()){
        qDebug() &lt;&lt; &quot;Failed to load texture&quot;;
    }
    // set the texture wrapping parameters
    texture1-&gt;setWrapMode(QOpenGLTexture::DirectionS, QOpenGLTexture::Repeat);
    texture1-&gt;setWrapMode(QOpenGLTexture::DirectionT, QOpenGLTexture::Repeat);
    // set texture filtering parameters
    texture1-&gt;setMinificationFilter(QOpenGLTexture::Linear);
    texture1-&gt;setMagnificationFilter(QOpenGLTexture::Linear);

    // texture 2
    // ---------
    texture2 = new QOpenGLTexture(QImage(&quot;:/awesomeface.png&quot;).mirrored(true, true), QOpenGLTexture::GenerateMipMaps);
    if(!texture2-&gt;isCreated()){
        qDebug() &lt;&lt; &quot;Failed to load texture&quot;;
    }
    // set the texture wrapping parameters
    texture2-&gt;setWrapMode(QOpenGLTexture::DirectionS, QOpenGLTexture::Repeat);
    texture2-&gt;setWrapMode(QOpenGLTexture::DirectionT, QOpenGLTexture::Repeat);
    // set texture filtering parameters
    texture2-&gt;setMinificationFilter(QOpenGLTexture::Linear);
    texture1-&gt;setMagnificationFilter(QOpenGLTexture::Linear);

    // tell opengl for each sampler to which texture unit it belongs to (only has to be done once)
    shaderProgram.bind();   // don&#39;t forget to activate/use the shader before setting uniforms!
    shaderProgram.setUniformValue(&quot;texture1&quot;, 0);
    shaderProgram.setUniformValue(&quot;texture2&quot;, 1);
    // note: currently we set the projection matrix each frame, but since the projection matrix rarely changes it&#39;s often best practice to set it outside the main loop only once.
    QMatrix4x4 view;
    view.translate(QVector3D(0.0f, 0.0f, -3.0f));
    shaderProgram.setUniformValue(&quot;view&quot;, view);
    QMatrix4x4 projection;
    projection.perspective(45.0f, 1.0f * width() / height(), 0.1f, 100.0f);
    shaderProgram.setUniformValue(&quot;projection&quot;, projection);
    shaderProgram.release();

    vbo.release();
}

void QtFunctionWidget::resizeGL(int w, int h){
    glViewport(0, 0, w, h);
}

static QVector3D cubePositions[] = {
  QVector3D( 0.0f,  0.0f,  0.0f),
  QVector3D( 2.0f,  5.0f, -15.0f),
  QVector3D(-1.5f, -2.2f, -2.5f),
  QVector3D(-3.8f, -2.0f, -12.3f),
  QVector3D( 2.4f, -0.4f, -3.5f),
  QVector3D(-1.7f,  3.0f, -7.5f),
  QVector3D( 1.3f, -2.0f, -2.5f),
  QVector3D( 1.5f,  2.0f, -2.5f),
  QVector3D( 1.5f,  0.2f, -1.5f),
  QVector3D(-1.3f,  1.0f, -1.5f)
};

void QtFunctionWidget::paintGL(){
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // also clear the depth buffer now!

    // bind textures on corresponding texture units
    glActiveTexture(GL_TEXTURE0);
    texture1-&gt;bind();
    glActiveTexture(GL_TEXTURE1);
    texture2-&gt;bind();

    shaderProgram.bind();

    {// render box
        QOpenGLVertexArrayObject::Binder vaoBind(&amp;vao);

        for (unsigned int i = 0; i &lt; 10; i++) {
           // calculate the model matrix for each object and pass it to shader before drawing
           QMatrix4x4 model;
           model.translate(cubePositions[i]);
           float angle = (i + 1.0f) * m_nTimeValue;
           model.rotate(angle, QVector3D(1.0f, 0.3f, 0.5f));
           shaderProgram.setUniformValue(&quot;model&quot;, model);
           glDrawArrays(GL_TRIANGLES, 0, 36);
        }
    }

    texture1-&gt;release();
    texture2-&gt;release();
    shaderProgram.release();
}
</code></pre><h2 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h2><h3 id="textures-vert"><a href="#textures-vert" class="headerlink" title="textures.vert"></a>textures.vert</h3><pre><code>#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aTexCoord;

out vec2 TexCoord;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main(){
  gl_Position = projection * view * model * vec4(aPos, 1.0f);
  TexCoord = aTexCoord;
}
</code></pre><h3 id="textures-frag"><a href="#textures-frag" class="headerlink" title="textures.frag"></a>textures.frag</h3><pre><code>#version 330 core
out vec4 FragColor;

in vec2 TexCoord;

uniform sampler2D texture1;
uniform sampler2D texture2;

void main()
{
    FragColor = mix(texture2D(texture1, TexCoord), texture2D(texture2, TexCoord), 0.2f);
}
</code></pre><h2 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h2><pre><code>#include &lt;QApplication&gt;
#include &quot;QtFunctionWidget.h&quot;
#include &quot;CoreFunctionWidget.h&quot;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QtFunctionWidget w1;
    CoreFunctionWidget w2;

    w1.setWindowTitle(QObject::tr(&quot;QtFunction&quot;));
    w2.setWindowTitle(QObject::tr(&quot;CoreFunction&quot;));

    w1.show();
    w2.show();

    return a.exec();
}
</code></pre></the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于Qt的OpenGL学习（4）—— 变换]]></title>
      <url>https://longxuan.ren/2019/08/09/Qt-OpenGL-Transform/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>要学习OpenGL的话，强烈安利这个教程JoeyDeVries的<a href="https://learnopengl-cn.github.io/" target="_blank" rel="noopener">learnopengl</a>，这里是中文翻译好的版本。教程中使用OpenGL是通过<a href="http://www.glfw.org/download.html" target="_blank" rel="noopener">GLFW</a>这个库，而在Qt中对OpenGL封装得很好，并且和GUI以及IO相关的处理Qt更便捷，学习起来更轻松。这里就对每篇教程，在Qt在分别直接使用OpenGL的函数和Qt封装好的类以作对比。<br>教程中使用的OpenGL版本为3.3，在Qt中需要使用此版本的OpenGL只需要继承类<code>QOpenGLFunctions_3_3_Core</code>即可。如果为了在不同设备上都能用OpenGL的话，Qt提供了类<code>QOpenGLFunctions</code>，这个类包含了大部分公共的函数，可能会有个别函数不能用。 <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="对比说明"><a href="#对比说明" class="headerlink" title="对比说明"></a>对比说明</h2><h3 id="教程地址"><a href="#教程地址" class="headerlink" title="教程地址"></a>教程地址</h3><p><a href="https://learnopengl-cn.github.io/01%20Getting%20started/07%20Transformations/" target="_blank" rel="noopener">原教程地址</a>，相关知识可以点击链接学习。<br><a href="https://github.com/Longxr/LearnopenglQt" target="_blank" rel="noopener">我的工程地址</a>，每篇教程一个commit，可以切换着看，查看本篇代码 <code>git checkout v1.4</code>，喜欢就点个Star吧~</p>
<h3 id="不同点-仅列出新增"><a href="#不同点-仅列出新增" class="headerlink" title="不同点 (仅列出新增)"></a>不同点 (仅列出新增)</h3><ol>
<li>原教程使用GLM来进行矩阵变换，Qt中有对应的QMatrix4x4处理4维矩阵。</li>
</ol>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-OpenGL-Transform_01.gif" alt="运行结果"></p>
<h2 id="使用OpenGL函数版"><a href="#使用OpenGL函数版" class="headerlink" title="使用OpenGL函数版"></a>使用OpenGL函数版</h2><h3 id="CoreFunctionWidget-h"><a href="#CoreFunctionWidget-h" class="headerlink" title="CoreFunctionWidget.h"></a>CoreFunctionWidget.h</h3><pre><code>#ifndef COREFUNCTIONWIDGET_H
#define COREFUNCTIONWIDGET_H

#include &lt;QOpenGLWidget&gt;
#include &lt;QOpenGLExtraFunctions&gt;
#include &lt;QOpenGLFunctions_3_3_Core&gt;
#include &lt;QOpenGLShader&gt;
#include &lt;QOpenGLShaderProgram&gt;

class CoreFunctionWidget : public QOpenGLWidget
                           , protected /*QOpenGLExtraFunctions*/QOpenGLFunctions_3_3_Core
{
    Q_OBJECT
public:
    explicit CoreFunctionWidget(QWidget *parent = nullptr);
    ~CoreFunctionWidget();

protected:
    virtual void initializeGL();
    virtual void resizeGL(int w, int h);
    virtual void paintGL();

private:
    QOpenGLShaderProgram shaderProgram;

    QTimer* m_pTimer = nullptr;
    int     m_nTimeValue = 0;
};

#endif // COREFUNCTIONWIDGET_H
</code></pre><h3 id="CoreFunctionWidget-cpp"><a href="#CoreFunctionWidget-cpp" class="headerlink" title="CoreFunctionWidget.cpp"></a>CoreFunctionWidget.cpp</h3><pre><code>#include &quot;CoreFunctionWidget.h&quot;
#include &lt;QDebug&gt;
#include &lt;QTimer&gt;

static GLuint VBO, VAO, EBO, texture1, texture2;

CoreFunctionWidget::CoreFunctionWidget(QWidget *parent) : QOpenGLWidget(parent)
{
    m_pTimer = new QTimer(this);
    connect(m_pTimer, &amp;QTimer::timeout, this, [=]{
        m_nTimeValue += 5;
        update();
    });
    m_pTimer-&gt;start(50);
}

CoreFunctionWidget::~CoreFunctionWidget()
{
    glDeleteVertexArrays(1, &amp;VAO);
    glDeleteBuffers(1, &amp;VBO);
    glDeleteBuffers(1, &amp;EBO);
}

void CoreFunctionWidget::initializeGL(){
    this-&gt;initializeOpenGLFunctions();

    bool success = shaderProgram.addShaderFromSourceFile(QOpenGLShader::Vertex, &quot;:/textures.vert&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; shaderProgram.log();
        return;
    }

    success = shaderProgram.addShaderFromSourceFile(QOpenGLShader::Fragment, &quot;:/textures.frag&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; shaderProgram.log();
        return;
    }

    success = shaderProgram.link();
    if(!success) {
        qDebug() &lt;&lt; &quot;shaderProgram link failed!&quot; &lt;&lt; shaderProgram.log();
    }

    //VAO，VBO data
    float vertices[] = {
        // positions          // colors           // texture coords
         0.5f,  0.5f, 0.0f,   1.0f, 0.0f, 0.0f,   1.0f, 1.0f, // top right
         0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,   1.0f, 0.0f, // bottom right
        -0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 1.0f,   0.0f, 0.0f, // bottom left
        -0.5f,  0.5f, 0.0f,   1.0f, 1.0f, 0.0f,   0.0f, 1.0f  // top left
    };
    unsigned int indices[] = {  // note that we start from 0!
        0, 1, 3,  // first Triangle
        1, 2, 3   // second Triangle
    };

    glGenVertexArrays(1, &amp;VAO);
    glGenBuffers(1, &amp;VBO);
    glGenBuffers(1, &amp;EBO);
    // bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s).
    glBindVertexArray(VAO);

    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);

    // position attribute
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);
    // color attribute
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);
    // texture coord attribute
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));
    glEnableVertexAttribArray(2);

    // texture 1
    // ---------
    glGenTextures(1, &amp;texture1);
    glBindTexture(GL_TEXTURE_2D, texture1);
     // set the texture wrapping parameters
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   // set texture wrapping to GL_REPEAT (default wrapping method)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    // set texture filtering parameters
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    // load image, create texture and generate mipmaps
    QImage img1 = QImage(&quot;:/container.jpg&quot;).convertToFormat(QImage::Format_RGB888);
    if (!img1.isNull()) {
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, img1.width(), img1.height(), 0, GL_RGB, GL_UNSIGNED_BYTE, img1.bits());
        glGenerateMipmap(GL_TEXTURE_2D);
    }

    // texture 2
    // ---------
    glGenTextures(1, &amp;texture2);
    glBindTexture(GL_TEXTURE_2D, texture2);
    // set the texture wrapping parameters
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   // set texture wrapping to GL_REPEAT (default wrapping method)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    // set texture filtering parameters
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    // load image, create texture and generate mipmaps
    QImage img2 = QImage(&quot;:/awesomeface.png&quot;).convertToFormat(QImage::Format_RGBA8888).mirrored(true, true);
    if (!img2.isNull()) {
        // note that the awesomeface.png has transparency and thus an alpha channel, so make sure to tell OpenGL the data type is of GL_RGBA
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, img2.width(), img2.height(), 0, GL_RGBA, GL_UNSIGNED_BYTE, img2.bits());
        glGenerateMipmap(GL_TEXTURE_2D);
    }

    // tell opengl for each sampler to which texture unit it belongs to (only has to be done once)
    shaderProgram.bind();   // don&#39;t forget to activate/use the shader before setting uniforms!
    glUniform1i(shaderProgram.uniformLocation(&quot;texture1&quot;), 0);
    glUniform1i(shaderProgram.uniformLocation(&quot;texture2&quot;), 1);
    shaderProgram.release();

    //线框模式，QOpenGLExtraFunctions没这函数, 3_3_Core有
//    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
}

void CoreFunctionWidget::resizeGL(int w, int h){
    glViewport(0, 0, w, h);
}

void CoreFunctionWidget::paintGL(){
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    // bind textures on corresponding texture units
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, texture1);
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, texture2);

    // create transformations
    QMatrix4x4 transform;
    transform.translate(QVector3D(0.5f, -0.5f, 0.0f));
    transform.rotate(m_nTimeValue, QVector3D(0.0f, 0.0f, 1.0f));

    // get matrix&#39;s uniform location and set matrix
    shaderProgram.bind();
    int transformLoc = shaderProgram.uniformLocation(&quot;transform&quot;);
    glUniformMatrix4fv(transformLoc, 1, GL_FALSE, transform.data());

    // render container
    glBindVertexArray(VAO);
    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);
    shaderProgram.release();
}
</code></pre><h2 id="使用Qt相关函数版"><a href="#使用Qt相关函数版" class="headerlink" title="使用Qt相关函数版"></a>使用Qt相关函数版</h2><h3 id="QtFunctionWidget-h"><a href="#QtFunctionWidget-h" class="headerlink" title="QtFunctionWidget.h"></a>QtFunctionWidget.h</h3><pre><code>#ifndef QTFUNCTIONWIDGET_H
#define QTFUNCTIONWIDGET_H

#include &lt;QOpenGLWidget&gt;


#include &lt;QOpenGLWidget&gt;
#include &lt;QOpenGLShader&gt;
#include &lt;QOpenGLShaderProgram&gt;
#include &lt;QOpenGLFunctions&gt;
#include &lt;QOpenGLVertexArrayObject&gt;
#include &lt;QOpenGLBuffer&gt;
#include &lt;QOpenGLTexture&gt;

class QtFunctionWidget : public QOpenGLWidget, protected QOpenGLFunctions
{
public:
    QtFunctionWidget(QWidget *parent = nullptr);
    ~QtFunctionWidget() Q_DECL_OVERRIDE;

protected:
    virtual void initializeGL() Q_DECL_OVERRIDE;
    virtual void resizeGL(int w, int h) Q_DECL_OVERRIDE;
    virtual void paintGL() Q_DECL_OVERRIDE;

private:
    QOpenGLShaderProgram shaderProgram;
    QOpenGLBuffer vbo, ebo;
    QOpenGLVertexArrayObject vao;
    QOpenGLTexture *texture1 = nullptr;
    QOpenGLTexture *texture2 = nullptr;

    QTimer* m_pTimer = nullptr;
    int     m_nTimeValue = 0;
};

#endif // QTFUNCTIONWIDGET_H
</code></pre><h3 id="QtFunctionWidget-cpp"><a href="#QtFunctionWidget-cpp" class="headerlink" title="QtFunctionWidget.cpp"></a>QtFunctionWidget.cpp</h3><pre><code>#include &quot;QtFunctionWidget.h&quot;
#include &lt;QDebug&gt;
#include &lt;QTimer&gt;

QtFunctionWidget::QtFunctionWidget(QWidget *parent) : QOpenGLWidget (parent),
    vbo(QOpenGLBuffer::VertexBuffer),
    ebo(QOpenGLBuffer::IndexBuffer)
{
    m_pTimer = new QTimer(this);
    connect(m_pTimer, &amp;QTimer::timeout, this, [=]{
        m_nTimeValue += 5;
        update();
    });
    m_pTimer-&gt;start(50);
}

QtFunctionWidget::~QtFunctionWidget(){
    makeCurrent();

    vbo.destroy();
    ebo.destroy();
    vao.destroy();

    delete texture1;
    delete texture2;

    doneCurrent();
}

void QtFunctionWidget::initializeGL(){
    this-&gt;initializeOpenGLFunctions();

    bool success = shaderProgram.addShaderFromSourceFile(QOpenGLShader::Vertex, &quot;:/textures.vert&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; shaderProgram.log();
        return;
    }

    success = shaderProgram.addShaderFromSourceFile(QOpenGLShader::Fragment, &quot;:/textures.frag&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; shaderProgram.log();
        return;
    }

    success = shaderProgram.link();
    if(!success) {
        qDebug() &lt;&lt; &quot;shaderProgram link failed!&quot; &lt;&lt; shaderProgram.log();
    }

    //VAO，VBO data
    float vertices[] = {
        // positions          // colors           // texture coords
         0.5f,  0.5f, 0.0f,   1.0f, 0.0f, 0.0f,   1.0f, 1.0f, // top right
         0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,   1.0f, 0.0f, // bottom right
        -0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 1.0f,   0.0f, 0.0f, // bottom left
        -0.5f,  0.5f, 0.0f,   1.0f, 1.0f, 0.0f,   0.0f, 1.0f  // top left
    };
    unsigned int indices[] = {  // note that we start from 0!
        0, 1, 3,  // first Triangle
        1, 2, 3   // second Triangle
    };

    QOpenGLVertexArrayObject::Binder vaoBind(&amp;vao);

    vbo.create();
    vbo.bind();
    vbo.allocate(vertices, sizeof(vertices));

    ebo.create();
    ebo.bind();
    ebo.allocate(indices, sizeof(indices));

    // position attribute
    int attr = -1;
    attr = shaderProgram.attributeLocation(&quot;aPos&quot;);
    shaderProgram.setAttributeBuffer(attr, GL_FLOAT, 0, 3, sizeof(GLfloat) * 8);
    shaderProgram.enableAttributeArray(attr);
    // color attribute
    attr = shaderProgram.attributeLocation(&quot;aColor&quot;);
    shaderProgram.setAttributeBuffer(attr, GL_FLOAT, sizeof(GLfloat) * 3, 3, sizeof(GLfloat) * 8);
    shaderProgram.enableAttributeArray(attr);
    // texture coord attribute
    attr = shaderProgram.attributeLocation(&quot;aTexCoord&quot;);
    shaderProgram.setAttributeBuffer(attr, GL_FLOAT, sizeof(GLfloat) * 6, 2, sizeof(GLfloat) * 8);
    shaderProgram.enableAttributeArray(attr);

    // texture 1
    // ---------
    texture1 = new QOpenGLTexture(QImage(&quot;:/container.jpg&quot;), QOpenGLTexture::GenerateMipMaps); //直接生成绑定一个2d纹理, 并生成多级纹理MipMaps
    if(!texture1-&gt;isCreated()){
        qDebug() &lt;&lt; &quot;Failed to load texture&quot;;
    }
    // set the texture wrapping parameters
    texture1-&gt;setWrapMode(QOpenGLTexture::DirectionS, QOpenGLTexture::Repeat);// 等于glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    texture1-&gt;setWrapMode(QOpenGLTexture::DirectionT, QOpenGLTexture::Repeat);//    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    // set texture filtering parameters
    texture1-&gt;setMinificationFilter(QOpenGLTexture::Linear);   //等价于glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    texture1-&gt;setMagnificationFilter(QOpenGLTexture::Linear);

    // texture 2
    // ---------
    texture2 = new QOpenGLTexture(QImage(&quot;:/awesomeface.png&quot;).mirrored(true, true), QOpenGLTexture::GenerateMipMaps); //直接生成绑定一个2d纹理, 并生成多级纹理MipMaps
    if(!texture2-&gt;isCreated()){
        qDebug() &lt;&lt; &quot;Failed to load texture&quot;;
    }
    // set the texture wrapping parameters
    texture2-&gt;setWrapMode(QOpenGLTexture::DirectionS, QOpenGLTexture::Repeat);// 等于glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    texture2-&gt;setWrapMode(QOpenGLTexture::DirectionT, QOpenGLTexture::Repeat);//    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    // set texture filtering parameters
    texture2-&gt;setMinificationFilter(QOpenGLTexture::Linear);   //等价于glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    texture1-&gt;setMagnificationFilter(QOpenGLTexture::Linear);

    // tell opengl for each sampler to which texture unit it belongs to (only has to be done once)
    shaderProgram.bind();   // don&#39;t forget to activate/use the shader before setting uniforms!
    shaderProgram.setUniformValue(&quot;texture1&quot;, 0);
    shaderProgram.setUniformValue(&quot;texture2&quot;, 1);
    shaderProgram.release();

    vbo.release();
//    remember: do NOT unbind the EBO while a VAO is active as the bound element buffer object IS stored in the VAO; keep the EBO bound.
//    ebo.release();

}

void QtFunctionWidget::resizeGL(int w, int h){
    glViewport(0, 0, w, h);
}

void QtFunctionWidget::paintGL(){
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    // bind textures on corresponding texture units
    glActiveTexture(GL_TEXTURE0);
    texture1-&gt;bind();
    glActiveTexture(GL_TEXTURE1);
    texture2-&gt;bind();

    // create transformations
    QMatrix4x4 transform;
    transform.translate(QVector3D(0.5f, -0.5f, 0.0f));
    transform.rotate(m_nTimeValue, QVector3D(0.0f, 0.0f, 1.0f));

    shaderProgram.bind();
    shaderProgram.setUniformValue(&quot;transform&quot;, transform);

    {// render container
        QOpenGLVertexArrayObject::Binder vaoBind(&amp;vao);
        glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);
    }

    texture1-&gt;release();
    texture2-&gt;release();
    shaderProgram.release();
}
</code></pre><h2 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h2><h3 id="textures-vert"><a href="#textures-vert" class="headerlink" title="textures.vert"></a>textures.vert</h3><pre><code>#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aColor;
layout (location = 2) in vec2 aTexCoord;

out vec3 ourColor;
out vec2 TexCoord;

uniform mat4 transform;

void main()
{
    gl_Position = transform * vec4(aPos, 1.0f);
    ourColor = aColor;
    TexCoord = aTexCoord;
    //TexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);
}
</code></pre><h3 id="textures-frag"><a href="#textures-frag" class="headerlink" title="textures.frag"></a>textures.frag</h3><pre><code>#version 330 core
out vec4 FragColor;

in vec3 ourColor;
in vec2 TexCoord;

uniform sampler2D texture1;
uniform sampler2D texture2;

void main()
{
    //FragColor = texture(texture1, TexCoord) * vec4(ourColor, 1.0);
    FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2);
}
</code></pre><h2 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h2><pre><code>#include &lt;QApplication&gt;
#include &quot;QtFunctionWidget.h&quot;
#include &quot;CoreFunctionWidget.h&quot;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QtFunctionWidget w1;
    CoreFunctionWidget w2;

    w1.setWindowTitle(QObject::tr(&quot;QtFunction&quot;));
    w2.setWindowTitle(QObject::tr(&quot;CoreFunction&quot;));

    w1.show();
    w2.show();

    return a.exec();
}
</code></pre></the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于Qt的OpenGL学习（3）—— 纹理]]></title>
      <url>https://longxuan.ren/2019/08/08/Qt-OpenGL-Textures/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>要学习OpenGL的话，强烈安利这个教程JoeyDeVries的<a href="https://learnopengl-cn.github.io/" target="_blank" rel="noopener">learnopengl</a>，这里是中文翻译好的版本。教程中使用OpenGL是通过<a href="http://www.glfw.org/download.html" target="_blank" rel="noopener">GLFW</a>这个库，而在Qt中对OpenGL封装得很好，并且和GUI以及IO相关的处理Qt更便捷，学习起来更轻松。这里就对每篇教程，在Qt在分别直接使用OpenGL的函数和Qt封装好的类以作对比。<br>教程中使用的OpenGL版本为3.3，在Qt中需要使用此版本的OpenGL只需要继承类<code>QOpenGLFunctions_3_3_Core</code>即可。如果为了在不同设备上都能用OpenGL的话，Qt提供了类<code>QOpenGLFunctions</code>，这个类包含了大部分公共的函数，可能会有个别函数不能用。 <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="对比说明"><a href="#对比说明" class="headerlink" title="对比说明"></a>对比说明</h2><h3 id="教程地址"><a href="#教程地址" class="headerlink" title="教程地址"></a>教程地址</h3><p><a href="https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/" target="_blank" rel="noopener">原教程地址</a>，相关知识可以点击链接学习。<br><a href="https://github.com/Longxr/LearnopenglQt" target="_blank" rel="noopener">我的工程地址</a>，准备后期每篇教程一个commit，可以切换着看，查看本篇代码 <code>git checkout v1.3</code>，喜欢就点个Star吧~</p>
<h3 id="不同点-仅列出新增"><a href="#不同点-仅列出新增" class="headerlink" title="不同点 (仅列出新增)"></a>不同点 (仅列出新增)</h3><ol>
<li>Qt提供了<code>QOpenGLTexture</code>类来处理OpenGL中的Texture，并且创建的时候可以直接传递一个QImage给纹理对象，如果使用gl相关函数还要读取图片数据的data再设置，比较麻烦。</li>
</ol>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-OpenGL-Textures_01.png" alt="运行结果"></p>
<h2 id="使用OpenGL函数版"><a href="#使用OpenGL函数版" class="headerlink" title="使用OpenGL函数版"></a>使用OpenGL函数版</h2><h3 id="CoreFunctionWidget-h"><a href="#CoreFunctionWidget-h" class="headerlink" title="CoreFunctionWidget.h"></a>CoreFunctionWidget.h</h3><pre><code>#ifndef COREFUNCTIONWIDGET_H
#define COREFUNCTIONWIDGET_H

#include &lt;QOpenGLWidget&gt;
#include &lt;QOpenGLExtraFunctions&gt;
#include &lt;QOpenGLFunctions_3_3_Core&gt;
#include &lt;QOpenGLShader&gt;
#include &lt;QOpenGLShaderProgram&gt;

class CoreFunctionWidget : public QOpenGLWidget
                           , protected /*QOpenGLExtraFunctions*/QOpenGLFunctions_3_3_Core
{
    Q_OBJECT
public:
    explicit CoreFunctionWidget(QWidget *parent = nullptr);
    ~CoreFunctionWidget();

protected:
    virtual void initializeGL();
    virtual void resizeGL(int w, int h);
    virtual void paintGL();

private:
    QOpenGLShaderProgram shaderProgram;

//    QTimer* m_pTimer = nullptr;
//    float m_uniformValue = 0.0f;
};

#endif // COREFUNCTIONWIDGET_H

</code></pre><h3 id="CoreFunctionWidget-cpp"><a href="#CoreFunctionWidget-cpp" class="headerlink" title="CoreFunctionWidget.cpp"></a>CoreFunctionWidget.cpp</h3><pre><code>#include &quot;CoreFunctionWidget.h&quot;
#include &lt;QDebug&gt;
#include &lt;QTimer&gt;

static GLuint VBO, VAO, EBO, texture1, texture2;

CoreFunctionWidget::CoreFunctionWidget(QWidget *parent) : QOpenGLWidget(parent)
{
//    m_pTimer = new QTimer(this);
//    m_pTimer-&gt;setInterval(200);

//    connect(m_pTimer, &amp;QTimer::timeout, this, [=]{
//        m_uniformValue += 0.1f;

//        if (m_uniformValue &gt; 1.5f) {
//            m_uniformValue = -1.5f;
//        }

//        update();
//    });

//    m_pTimer-&gt;start();
}

CoreFunctionWidget::~CoreFunctionWidget()
{
    glDeleteVertexArrays(1, &amp;VAO);
    glDeleteBuffers(1, &amp;VBO);
    glDeleteBuffers(1, &amp;EBO);
}

void CoreFunctionWidget::initializeGL(){
    this-&gt;initializeOpenGLFunctions();

    bool success = shaderProgram.addShaderFromSourceFile(QOpenGLShader::Vertex, &quot;:/textures.vert&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; shaderProgram.log();
        return;
    }

    success = shaderProgram.addShaderFromSourceFile(QOpenGLShader::Fragment, &quot;:/textures.frag&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; shaderProgram.log();
        return;
    }

    success = shaderProgram.link();
    if(!success) {
        qDebug() &lt;&lt; &quot;shaderProgram link failed!&quot; &lt;&lt; shaderProgram.log();
    }

    //VAO，VBO data
    float vertices[] = {
        // positions          // colors           // texture coords
         0.5f,  0.5f, 0.0f,   1.0f, 0.0f, 0.0f,   1.0f, 1.0f, // top right
         0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,   1.0f, 0.0f, // bottom right
        -0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 1.0f,   0.0f, 0.0f, // bottom left
        -0.5f,  0.5f, 0.0f,   1.0f, 1.0f, 0.0f,   0.0f, 1.0f  // top left
    };
    unsigned int indices[] = {  // note that we start from 0!
        0, 1, 3,  // first Triangle
        1, 2, 3   // second Triangle
    };

    glGenVertexArrays(1, &amp;VAO);
    glGenBuffers(1, &amp;VBO);
    glGenBuffers(1, &amp;EBO);
    // bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s).
    glBindVertexArray(VAO);

    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);

    // position attribute
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);
    // color attribute
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);
    // texture coord attribute
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));
    glEnableVertexAttribArray(2);

    // texture 1
    // ---------
    glGenTextures(1, &amp;texture1);
    glBindTexture(GL_TEXTURE_2D, texture1);
     // set the texture wrapping parameters
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   // set texture wrapping to GL_REPEAT (default wrapping method)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    // set texture filtering parameters
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    // load image, create texture and generate mipmaps
    QImage img1 = QImage(&quot;:/container.jpg&quot;).convertToFormat(QImage::Format_RGB888);
    if (!img1.isNull()) {
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, img1.width(), img1.height(), 0, GL_RGB, GL_UNSIGNED_BYTE, img1.bits());
        glGenerateMipmap(GL_TEXTURE_2D);
    }

    // texture 2
    // ---------
    glGenTextures(1, &amp;texture2);
    glBindTexture(GL_TEXTURE_2D, texture2);
    // set the texture wrapping parameters
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   // set texture wrapping to GL_REPEAT (default wrapping method)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    // set texture filtering parameters
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    // load image, create texture and generate mipmaps
    QImage img2 = QImage(&quot;:/awesomeface.png&quot;).convertToFormat(QImage::Format_RGBA8888).mirrored(true, true);
    if (!img2.isNull()) {
        // note that the awesomeface.png has transparency and thus an alpha channel, so make sure to tell OpenGL the data type is of GL_RGBA
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, img2.width(), img2.height(), 0, GL_RGBA, GL_UNSIGNED_BYTE, img2.bits());
        glGenerateMipmap(GL_TEXTURE_2D);
    }

    // tell opengl for each sampler to which texture unit it belongs to (only has to be done once)
    shaderProgram.bind();   // don&#39;t forget to activate/use the shader before setting uniforms!
    glUniform1i(shaderProgram.uniformLocation(&quot;texture1&quot;), 0);
    glUniform1i(shaderProgram.uniformLocation(&quot;texture2&quot;), 1);
    shaderProgram.release();

//    glBindBuffer(GL_ARRAY_BUFFER, 0);//取消VBO的绑定

//    remember: do NOT unbind the EBO while a VAO is active as the bound element buffer object IS stored in the VAO; keep the EBO bound.
//    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

//    You can unbind the VAO afterwards so other VAO calls won&#39;t accidentally modify this VAO, but this rarely happens. Modifying other
//    VAOs requires a call to glBindVertexArray anyways so we generally don&#39;t unbind VAOs (nor VBOs) when it&#39;s not directly necessary.
//    glBindVertexArray(0);   //取消VAO绑定

    //线框模式，QOpenGLExtraFunctions没这函数, 3_3_Core有
//    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
}

void CoreFunctionWidget::resizeGL(int w, int h){
    glViewport(0, 0, w, h);
}

void CoreFunctionWidget::paintGL(){
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    shaderProgram.bind();
    {
        // bind textures on corresponding texture units
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, texture1);
        glActiveTexture(GL_TEXTURE1);
        glBindTexture(GL_TEXTURE_2D, texture2);

        // render container
        glBindVertexArray(VAO);
        glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
    }
    shaderProgram.release();
}

</code></pre><h2 id="使用Qt相关函数版"><a href="#使用Qt相关函数版" class="headerlink" title="使用Qt相关函数版"></a>使用Qt相关函数版</h2><h3 id="QtFunctionWidget-h"><a href="#QtFunctionWidget-h" class="headerlink" title="QtFunctionWidget.h"></a>QtFunctionWidget.h</h3><pre><code>#ifndef QTFUNCTIONWIDGET_H
#define QTFUNCTIONWIDGET_H

#include &lt;QOpenGLWidget&gt;


#include &lt;QOpenGLWidget&gt;
#include &lt;QOpenGLShader&gt;
#include &lt;QOpenGLShaderProgram&gt;
#include &lt;QOpenGLFunctions&gt;
#include &lt;QOpenGLVertexArrayObject&gt;
#include &lt;QOpenGLBuffer&gt;
#include &lt;QOpenGLTexture&gt;

class QtFunctionWidget : public QOpenGLWidget, protected QOpenGLFunctions
{
public:
    QtFunctionWidget(QWidget *parent = nullptr);
    ~QtFunctionWidget() Q_DECL_OVERRIDE;

protected:
    virtual void initializeGL() Q_DECL_OVERRIDE;
    virtual void resizeGL(int w, int h) Q_DECL_OVERRIDE;
    virtual void paintGL() Q_DECL_OVERRIDE;

private:
    QOpenGLShaderProgram shaderProgram;
    QOpenGLBuffer vbo, ebo;
    QOpenGLVertexArrayObject vao;
    QOpenGLTexture *texture1 = nullptr;
    QOpenGLTexture *texture2 = nullptr;

//    QTimer* m_pTimer = nullptr;
//    float m_uniformValue = 0.0f;
};

#endif // QTFUNCTIONWIDGET_H

</code></pre><h3 id="QtFunctionWidget-cpp"><a href="#QtFunctionWidget-cpp" class="headerlink" title="QtFunctionWidget.cpp"></a>QtFunctionWidget.cpp</h3><pre><code>#include &quot;QtFunctionWidget.h&quot;
#include &lt;QDebug&gt;
#include &lt;QTimer&gt;

QtFunctionWidget::QtFunctionWidget(QWidget *parent) : QOpenGLWidget (parent),
    vbo(QOpenGLBuffer::VertexBuffer),
    ebo(QOpenGLBuffer::IndexBuffer)
{
//    m_pTimer = new QTimer(this);
//    m_pTimer-&gt;setInterval(200);

//    connect(m_pTimer, &amp;QTimer::timeout, this, [=]{
//        m_uniformValue += 0.1f;

//        if (m_uniformValue &gt; 1.5f) {
//            m_uniformValue = -1.5f;
//        }

//        update();
//    });

//    m_pTimer-&gt;start();
}

QtFunctionWidget::~QtFunctionWidget(){
    makeCurrent();

    vbo.destroy();
    ebo.destroy();
    vao.destroy();

    delete texture1;
    delete texture2;

    doneCurrent();
}

void QtFunctionWidget::initializeGL(){
    this-&gt;initializeOpenGLFunctions();

    bool success = shaderProgram.addShaderFromSourceFile(QOpenGLShader::Vertex, &quot;:/textures.vert&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; shaderProgram.log();
        return;
    }

    success = shaderProgram.addShaderFromSourceFile(QOpenGLShader::Fragment, &quot;:/textures.frag&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; shaderProgram.log();
        return;
    }

    success = shaderProgram.link();
    if(!success) {
        qDebug() &lt;&lt; &quot;shaderProgram link failed!&quot; &lt;&lt; shaderProgram.log();
    }

    //VAO，VBO data
    float vertices[] = {
        // positions          // colors           // texture coords
         0.5f,  0.5f, 0.0f,   1.0f, 0.0f, 0.0f,   1.0f, 1.0f, // top right
         0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,   1.0f, 0.0f, // bottom right
        -0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 1.0f,   0.0f, 0.0f, // bottom left
        -0.5f,  0.5f, 0.0f,   1.0f, 1.0f, 0.0f,   0.0f, 1.0f  // top left
    };
    unsigned int indices[] = {  // note that we start from 0!
        0, 1, 3,  // first Triangle
        1, 2, 3   // second Triangle
    };

    QOpenGLVertexArrayObject::Binder vaoBind(&amp;vao);

    vbo.create();
    vbo.bind();
    vbo.allocate(vertices, sizeof(vertices));

    ebo.create();
    ebo.bind();
    ebo.allocate(indices, sizeof(indices));

    // position attribute
    int attr = -1;
    attr = shaderProgram.attributeLocation(&quot;aPos&quot;);
    shaderProgram.setAttributeBuffer(attr, GL_FLOAT, 0, 3, sizeof(GLfloat) * 8);
    shaderProgram.enableAttributeArray(attr);
    // color attribute
    attr = shaderProgram.attributeLocation(&quot;aColor&quot;);
    shaderProgram.setAttributeBuffer(attr, GL_FLOAT, sizeof(GLfloat) * 3, 3, sizeof(GLfloat) * 8);
    shaderProgram.enableAttributeArray(attr);
    // texture coord attribute
    attr = shaderProgram.attributeLocation(&quot;aTexCoord&quot;);
    shaderProgram.setAttributeBuffer(attr, GL_FLOAT, sizeof(GLfloat) * 6, 2, sizeof(GLfloat) * 8);
    shaderProgram.enableAttributeArray(attr);

    // texture 1
    // ---------
    texture1 = new QOpenGLTexture(QImage(&quot;:/container.jpg&quot;), QOpenGLTexture::GenerateMipMaps); //直接生成绑定一个2d纹理, 并生成多级纹理MipMaps
    if(!texture1-&gt;isCreated()){
        qDebug() &lt;&lt; &quot;Failed to load texture&quot;;
    }
    // set the texture wrapping parameters
    texture1-&gt;setWrapMode(QOpenGLTexture::DirectionS, QOpenGLTexture::Repeat);// 等于glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    texture1-&gt;setWrapMode(QOpenGLTexture::DirectionT, QOpenGLTexture::Repeat);//    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    // set texture filtering parameters
    texture1-&gt;setMinificationFilter(QOpenGLTexture::Linear);   //等价于glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    texture1-&gt;setMagnificationFilter(QOpenGLTexture::Linear);

    // texture 2
    // ---------
    texture2 = new QOpenGLTexture(QImage(&quot;:/awesomeface.png&quot;).mirrored(true, true), QOpenGLTexture::GenerateMipMaps); //直接生成绑定一个2d纹理, 并生成多级纹理MipMaps
    if(!texture2-&gt;isCreated()){
        qDebug() &lt;&lt; &quot;Failed to load texture&quot;;
    }
    // set the texture wrapping parameters
    texture2-&gt;setWrapMode(QOpenGLTexture::DirectionS, QOpenGLTexture::Repeat);// 等于glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    texture2-&gt;setWrapMode(QOpenGLTexture::DirectionT, QOpenGLTexture::Repeat);//    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    // set texture filtering parameters
    texture2-&gt;setMinificationFilter(QOpenGLTexture::Linear);   //等价于glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    texture1-&gt;setMagnificationFilter(QOpenGLTexture::Linear);

    // tell opengl for each sampler to which texture unit it belongs to (only has to be done once)
    shaderProgram.bind();   // don&#39;t forget to activate/use the shader before setting uniforms!
    shaderProgram.setUniformValue(&quot;texture1&quot;, 0);
    shaderProgram.setUniformValue(&quot;texture2&quot;, 1);
    shaderProgram.release();

    vbo.release();
//    remember: do NOT unbind the EBO while a VAO is active as the bound element buffer object IS stored in the VAO; keep the EBO bound.
//    ebo.release();

}

void QtFunctionWidget::resizeGL(int w, int h){
    glViewport(0, 0, w, h);
}

void QtFunctionWidget::paintGL(){
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    shaderProgram.bind();
    {
        glActiveTexture(GL_TEXTURE0);
        texture1-&gt;bind();
//        glBindTexture(GL_TEXTURE_2D, texture1-&gt;textureId());
        glActiveTexture(GL_TEXTURE1);
        texture2-&gt;bind();
//        glBindTexture(GL_TEXTURE_2D, texture2-&gt;textureId());

        // render container
        QOpenGLVertexArrayObject::Binder vaoBind(&amp;vao);
        glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);

        texture1-&gt;release();
        texture2-&gt;release();
    }
    shaderProgram.release();
}

</code></pre><h2 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h2><h3 id="textures-vert"><a href="#textures-vert" class="headerlink" title="textures.vert"></a>textures.vert</h3><pre><code>#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aColor;
layout (location = 2) in vec2 aTexCoord;

out vec3 ourColor;
out vec2 TexCoord;

void main()
{
    gl_Position = vec4(aPos, 1.0);
    ourColor = aColor;
    TexCoord = aTexCoord;
}
</code></pre><h3 id="textures-frag"><a href="#textures-frag" class="headerlink" title="textures.frag"></a>textures.frag</h3><pre><code>#version 330 core
out vec4 FragColor;

in vec3 ourColor;
in vec2 TexCoord;

uniform sampler2D texture1;
uniform sampler2D texture2;

void main()
{
    //FragColor = texture(texture1, TexCoord) * vec4(ourColor, 1.0);
    FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2);
}

</code></pre><h2 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h2><pre><code>#include &lt;QApplication&gt;
#include &quot;MainWindow.h&quot;
#include &quot;QtFunctionWidget.h&quot;
#include &quot;CoreFunctionWidget.h&quot;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

//    MainWindow w;
    QtFunctionWidget w1;
    CoreFunctionWidget w2;

    w1.setWindowTitle(QObject::tr(&quot;QtFunction&quot;));
    w2.setWindowTitle(QObject::tr(&quot;CoreFunction&quot;));

    w1.show();
    w2.show();

    return a.exec();
}

</code></pre></the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于Qt的OpenGL学习（2）—— 着色器]]></title>
      <url>https://longxuan.ren/2019/08/08/Qt-OpenGL-Shader/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>要学习OpenGL的话，强烈安利这个教程JoeyDeVries的<a href="https://learnopengl-cn.github.io/" target="_blank" rel="noopener">learnopengl</a>，这里是中文翻译好的版本。教程中使用OpenGL是通过<a href="http://www.glfw.org/download.html" target="_blank" rel="noopener">GLFW</a>这个库，而在Qt中对OpenGL封装得很好，并且和GUI以及IO相关的处理Qt更便捷，学习起来更轻松。这里就对每篇教程，在Qt在分别直接使用OpenGL的函数和Qt封装好的类以作对比。<br>教程中使用的OpenGL版本为3.3，在Qt中需要使用此版本的OpenGL只需要继承类<code>QOpenGLFunctions_3_3_Core</code>即可。如果为了在不同设备上都能用OpenGL的话，Qt提供了类<code>QOpenGLFunctions</code>，这个类包含了大部分公共的函数，可能会有个别函数不能用。 <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="对比说明"><a href="#对比说明" class="headerlink" title="对比说明"></a>对比说明</h2><h3 id="教程地址"><a href="#教程地址" class="headerlink" title="教程地址"></a>教程地址</h3><p><a href="https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/" target="_blank" rel="noopener">原教程地址</a>，相关知识可以点击链接学习。<br><a href="https://github.com/Longxr/LearnopenglQt" target="_blank" rel="noopener">我的工程地址</a>，准备后期每篇教程一个commit，可以切换着看，查看本篇代码 <code>git checkout v1.2</code>，喜欢就点个Star吧~</p>
<h3 id="不同点-仅列出新增"><a href="#不同点-仅列出新增" class="headerlink" title="不同点 (仅列出新增)"></a>不同点 (仅列出新增)</h3><ol>
<li>我的代码实现的是原教程中练习2的三角形沿着X轴水平移动</li>
<li>原教程是一个while循环不停重绘，Qt中的<code>paintGL</code>则是在需要时才重绘，因此采用QTimer定时器触发重绘刷新。</li>
</ol>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-OpenGL-Shader_01.gif" alt="运行结果"></p>
<h2 id="使用OpenGL函数版"><a href="#使用OpenGL函数版" class="headerlink" title="使用OpenGL函数版"></a>使用OpenGL函数版</h2><h3 id="CoreFunctionWidget-h"><a href="#CoreFunctionWidget-h" class="headerlink" title="CoreFunctionWidget.h"></a>CoreFunctionWidget.h</h3><pre><code>#ifndef COREFUNCTIONWIDGET_H
#define COREFUNCTIONWIDGET_H

#include &lt;QOpenGLWidget&gt;
#include &lt;QOpenGLExtraFunctions&gt;
#include &lt;QOpenGLFunctions_3_3_Core&gt;
#include &lt;QOpenGLShader&gt;
#include &lt;QOpenGLShaderProgram&gt;

class CoreFunctionWidget : public QOpenGLWidget
                           , protected /*QOpenGLExtraFunctions*/QOpenGLFunctions_3_3_Core
{
    Q_OBJECT
public:
    explicit CoreFunctionWidget(QWidget *parent = nullptr);
    ~CoreFunctionWidget();

protected:
    virtual void initializeGL();
    virtual void resizeGL(int w, int h);
    virtual void paintGL();

private:
    QOpenGLShaderProgram shaderProgram;

    QTimer* m_pTimer = nullptr;
    float m_uniformValue = 0.0f;
};

#endif // COREFUNCTIONWIDGET_H
</code></pre><h3 id="CoreFunctionWidget-cpp"><a href="#CoreFunctionWidget-cpp" class="headerlink" title="CoreFunctionWidget.cpp"></a>CoreFunctionWidget.cpp</h3><pre><code>#include &quot;CoreFunctionWidget.h&quot;
#include &lt;QDebug&gt;
#include &lt;QTimer&gt;

static GLuint VBO, VAO, EBO;

CoreFunctionWidget::CoreFunctionWidget(QWidget *parent) : QOpenGLWidget(parent)
{
    m_pTimer = new QTimer(this);
    m_pTimer-&gt;setInterval(200);

    connect(m_pTimer, &amp;QTimer::timeout, this, [=]{
        m_uniformValue += 0.1f;

        if (m_uniformValue &gt; 1.5f) {
            m_uniformValue = -1.5f;
        }

        update();
    });

    m_pTimer-&gt;start();
}

CoreFunctionWidget::~CoreFunctionWidget()
{
    glDeleteVertexArrays(1, &amp;VAO);
    glDeleteBuffers(1, &amp;VBO);
//    glDeleteBuffers(1, &amp;EBO);
}

void CoreFunctionWidget::initializeGL(){
    this-&gt;initializeOpenGLFunctions();

    bool success = shaderProgram.addShaderFromSourceFile(QOpenGLShader::Vertex, &quot;:/colortriangle.vert&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; shaderProgram.log();
        return;
    }

    success = shaderProgram.addShaderFromSourceFile(QOpenGLShader::Fragment, &quot;:/colortriangle.frag&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; shaderProgram.log();
        return;
    }

    success = shaderProgram.link();
    if(!success) {
        qDebug() &lt;&lt; &quot;shaderProgram link failed!&quot; &lt;&lt; shaderProgram.log();
    }

    //VAO，VBO数据部分
    float vertices[] = {
        // positions         // colors
        0.5f, -0.5f, 0.0f,  1.0f, 0.0f, 0.0f,  // bottom right
        -0.5f, -0.5f, 0.0f,  0.0f, 1.0f, 0.0f,  // bottom left
        0.0f,  0.5f, 0.0f,  0.0f, 0.0f, 1.0f   // top
    };
//    unsigned int indices[] = {  // note that we start from 0!
//        0, 1, 3,  // first Triangle
//        1, 2, 3   // second Triangle
//    };

    glGenVertexArrays(1, &amp;VAO);
    glGenBuffers(1, &amp;VBO);
//    glGenBuffers(1, &amp;EBO);
    // bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s).
    glBindVertexArray(VAO);

    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);  //顶点数据复制到缓冲

//    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
//    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (void*)0);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (GLvoid*)(3*sizeof(GLfloat)));
    glEnableVertexAttribArray(1);

    glBindBuffer(GL_ARRAY_BUFFER, 0);//取消VBO的绑定, glVertexAttribPointer已经把顶点属性关联到顶点缓冲对象了

//    remember: do NOT unbind the EBO while a VAO is active as the bound element buffer object IS stored in the VAO; keep the EBO bound.
//    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

//    You can unbind the VAO afterwards so other VAO calls won&#39;t accidentally modify this VAO, but this rarely happens. Modifying other
//    VAOs requires a call to glBindVertexArray anyways so we generally don&#39;t unbind VAOs (nor VBOs) when it&#39;s not directly necessary.
    glBindVertexArray(0);   //取消VAO绑定

    //线框模式，QOpenGLExtraFunctions没这函数, 3_3_Core有
//    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
}

void CoreFunctionWidget::resizeGL(int w, int h){
    glViewport(0, 0, w, h);
}

void CoreFunctionWidget::paintGL(){
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    shaderProgram.bind();
    {
        int xOffsetLocation = shaderProgram.uniformLocation(&quot;xOffset&quot;);
        glUniform1f(xOffsetLocation, m_uniformValue);

        // 绘制三角形
        glBindVertexArray(VAO);
        glDrawArrays(GL_TRIANGLES, 0, 3);

//        glBindVertexArray(VAO); // seeing as we only have a single VAO there&#39;s no need to bind it every time, but we&#39;ll do so to keep things a bit more organized
//        glDrawArrays(GL_TRIANGLES, 0, 6);
//        glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
    }
    shaderProgram.release();
}


</code></pre><h2 id="使用Qt相关函数版"><a href="#使用Qt相关函数版" class="headerlink" title="使用Qt相关函数版"></a>使用Qt相关函数版</h2><h3 id="QtFunctionWidget-h"><a href="#QtFunctionWidget-h" class="headerlink" title="QtFunctionWidget.h"></a>QtFunctionWidget.h</h3><pre><code>#ifndef QTFUNCTIONWIDGET_H
#define QTFUNCTIONWIDGET_H

#include &lt;QOpenGLWidget&gt;


#include &lt;QOpenGLWidget&gt;
#include &lt;QOpenGLShader&gt;
#include &lt;QOpenGLShaderProgram&gt;
#include &lt;QOpenGLFunctions&gt;
#include &lt;QOpenGLVertexArrayObject&gt;
#include &lt;QOpenGLBuffer&gt;

class QtFunctionWidget : public QOpenGLWidget, protected QOpenGLFunctions
{
public:
    QtFunctionWidget(QWidget *parent = nullptr);
    ~QtFunctionWidget() Q_DECL_OVERRIDE;

protected:
    virtual void initializeGL() Q_DECL_OVERRIDE;
    virtual void resizeGL(int w, int h) Q_DECL_OVERRIDE;
    virtual void paintGL() Q_DECL_OVERRIDE;

private:
    QOpenGLShaderProgram shaderProgram;
    QOpenGLBuffer vbo, ebo;
    QOpenGLVertexArrayObject vao;

    QTimer* m_pTimer = nullptr;
    float m_uniformValue = 0.0f;
};

#endif // QTFUNCTIONWIDGET_H


</code></pre><h3 id="QtFunctionWidget-cpp"><a href="#QtFunctionWidget-cpp" class="headerlink" title="QtFunctionWidget.cpp"></a>QtFunctionWidget.cpp</h3><pre><code>#include &quot;QtFunctionWidget.h&quot;
#include &lt;QDebug&gt;
#include &lt;QTimer&gt;

QtFunctionWidget::QtFunctionWidget(QWidget *parent) : QOpenGLWidget (parent),
    vbo(QOpenGLBuffer::VertexBuffer),
    ebo(QOpenGLBuffer::IndexBuffer)
{
    m_pTimer = new QTimer(this);
    m_pTimer-&gt;setInterval(200);

    connect(m_pTimer, &amp;QTimer::timeout, this, [=]{
        m_uniformValue += 0.1f;

        if (m_uniformValue &gt; 1.5f) {
            m_uniformValue = -1.5f;
        }

        update();
    });

    m_pTimer-&gt;start();
}

QtFunctionWidget::~QtFunctionWidget(){
    makeCurrent();

    vbo.destroy();
    ebo.destroy();
    vao.destroy();

    doneCurrent();
}

void QtFunctionWidget::initializeGL(){
    this-&gt;initializeOpenGLFunctions();

    bool success = shaderProgram.addShaderFromSourceFile(QOpenGLShader::Vertex, &quot;:/colortriangle.vert&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; shaderProgram.log();
        return;
    }

    success = shaderProgram.addShaderFromSourceFile(QOpenGLShader::Fragment, &quot;:/colortriangle.frag&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; shaderProgram.log();
        return;
    }

    success = shaderProgram.link();
    if(!success) {
        qDebug() &lt;&lt; &quot;shaderProgram link failed!&quot; &lt;&lt; shaderProgram.log();
    }

    //VAO，VBO数据部分
    GLfloat vertices[] = {
        // positions         // colors
        0.5f, -0.5f, 0.0f,  1.0f, 0.0f, 0.0f,  // bottom right
        -0.5f, -0.5f, 0.0f,  0.0f, 1.0f, 0.0f,  // bottom left
        0.0f,  0.5f, 0.0f,  0.0f, 0.0f, 1.0f   // top
    };
//    unsigned int indices[] = {  // note that we start from 0!
//        0, 1, 3,  // first Triangle
//        1, 2, 3   // second Triangle
//    };

    QOpenGLVertexArrayObject::Binder vaoBind(&amp;vao);

    vbo.create();
    vbo.bind();
    vbo.allocate(vertices, sizeof(vertices));

//    ebo.create();
//    ebo.bind();
//    ebo.allocate(indices, sizeof(indices));

    int attr = -1;
    attr = shaderProgram.attributeLocation(&quot;aPos&quot;);
    shaderProgram.setAttributeBuffer(attr, GL_FLOAT, 0, 3, sizeof(GLfloat) * 6);
    shaderProgram.enableAttributeArray(attr);

    attr = shaderProgram.attributeLocation(&quot;aColor&quot;);
    shaderProgram.setAttributeBuffer(attr, GL_FLOAT, sizeof(GLfloat) * 3, 3, sizeof(GLfloat) * 6);
    shaderProgram.enableAttributeArray(attr);

    vbo.release();
//    remember: do NOT unbind the EBO while a VAO is active as the bound element buffer object IS stored in the VAO; keep the EBO bound.
//    ebo.release();

}

void QtFunctionWidget::resizeGL(int w, int h){
    glViewport(0, 0, w, h);
}

void QtFunctionWidget::paintGL(){
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    shaderProgram.bind();
    {
        shaderProgram.setUniformValue(&quot;xOffset&quot;, m_uniformValue);

        QOpenGLVertexArrayObject::Binder vaoBind(&amp;vao);
        glDrawArrays(GL_TRIANGLES, 0, 3);

//        glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
    }
    shaderProgram.release();
}

</code></pre><h2 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h2><h3 id="colortriangle-vert"><a href="#colortriangle-vert" class="headerlink" title="colortriangle.vert"></a>colortriangle.vert</h3><pre><code>#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aColor;

out vec3 ourColor;
uniform float xOffset;

void main(){
  gl_Position = vec4(aPos.x + xOffset, aPos.y, aPos.z, 1.0);
  ourColor = aColor;
}
</code></pre><h3 id="colortriangle-frag"><a href="#colortriangle-frag" class="headerlink" title="colortriangle.frag"></a>colortriangle.frag</h3><pre><code>#version 330 core
out vec4 FragColor;
in vec3 ourColor;

void main(void)
{
    FragColor = vec4(ourColor, 1.0f);
}
</code></pre><h2 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h2><pre><code>#include &lt;QApplication&gt;
#include &quot;MainWindow.h&quot;
#include &quot;QtFunctionWidget.h&quot;
#include &quot;CoreFunctionWidget.h&quot;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

//    MainWindow w;
    QtFunctionWidget w1;
    CoreFunctionWidget w2;

    w1.setWindowTitle(QObject::tr(&quot;QtFunction&quot;));
    w2.setWindowTitle(QObject::tr(&quot;CoreFunction&quot;));

    w1.show();
    w2.show();

    return a.exec();
}

</code></pre></the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于Qt的OpenGL学习（1）—— Hello Triangle]]></title>
      <url>https://longxuan.ren/2019/08/08/Qt-OpenGL-HelloTriangle/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>要学习OpenGL的话，强烈安利这个教程JoeyDeVries的<a href="https://learnopengl-cn.github.io/" target="_blank" rel="noopener">learnopengl</a>，这里是中文翻译好的版本。教程中使用OpenGL是通过<a href="http://www.glfw.org/download.html" target="_blank" rel="noopener">GLFW</a>这个库，而在Qt中对OpenGL封装得很好，并且和GUI以及IO相关的处理Qt更便捷，学习起来更轻松。这里就对每篇教程，在Qt在分别直接使用OpenGL的函数和Qt封装好的类以作对比。<br>教程中使用的OpenGL版本为3.3，在Qt中需要使用此版本的OpenGL只需要继承类<code>QOpenGLFunctions_3_3_Core</code>即可。如果为了在不同设备上都能用OpenGL的话，Qt提供了类<code>QOpenGLFunctions</code>，这个类包含了大部分公共的函数，可能会有个别函数不能用。 <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="对比说明"><a href="#对比说明" class="headerlink" title="对比说明"></a>对比说明</h2><h3 id="教程地址"><a href="#教程地址" class="headerlink" title="教程地址"></a>教程地址</h3><p><a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/" target="_blank" rel="noopener">原教程地址</a>，相关知识可以点击链接学习。<br><a href="https://github.com/Longxr/LearnopenglQt" target="_blank" rel="noopener">我的工程地址</a>，准备后期每篇教程一个commit，查看本篇代码 <code>git checkout v1.1</code>，喜欢就点个Star吧~</p>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ol>
<li>原教程关于ShaderProgram的读取、链接很繁琐，后面教程还专门写了个类<code>Shader</code>，这里我直接使用Qt封装好的<code>addShaderFromSourceFile</code>函数更方便。</li>
<li>Qt提供了<code>QOpenGLShaderProgram</code>、<code>QOpenGLVertexArrayObject</code>、<code>QOpenGLBuffer</code>这些类来处理OpenGL中的<code>program</code>、<code>VAO</code>、<code>VBO</code>。</li>
</ol>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-OpenGL-HelloTriangle_01.png" alt="运行结果"></p>
<h2 id="使用OpenGL函数版"><a href="#使用OpenGL函数版" class="headerlink" title="使用OpenGL函数版"></a>使用OpenGL函数版</h2><h3 id="CoreFunctionWidget-h"><a href="#CoreFunctionWidget-h" class="headerlink" title="CoreFunctionWidget.h"></a>CoreFunctionWidget.h</h3><pre><code>#ifndef COREFUNCTIONWIDGET_H
#define COREFUNCTIONWIDGET_H

#include &lt;QOpenGLWidget&gt;
#include &lt;QOpenGLExtraFunctions&gt;
#include &lt;QOpenGLFunctions_3_3_Core&gt;
#include &lt;QOpenGLShader&gt;
#include &lt;QOpenGLShaderProgram&gt;

class CoreFunctionWidget : public QOpenGLWidget
                           , protected /*QOpenGLExtraFunctions*/QOpenGLFunctions_3_3_Core
{
    Q_OBJECT
public:
    explicit CoreFunctionWidget(QWidget *parent = nullptr);
    ~CoreFunctionWidget();

protected:
    virtual void initializeGL();
    virtual void resizeGL(int w, int h);
    virtual void paintGL();

private:
    QOpenGLShaderProgram shaderProgram;
};

#endif // COREFUNCTIONWIDGET_H
</code></pre><h3 id="CoreFunctionWidget-cpp"><a href="#CoreFunctionWidget-cpp" class="headerlink" title="CoreFunctionWidget.cpp"></a>CoreFunctionWidget.cpp</h3><pre><code>#include &quot;CoreFunctionWidget.h&quot;
#include &lt;QDebug&gt;
#include &lt;QFile&gt;

static GLuint VBO, VAO, EBO;

CoreFunctionWidget::CoreFunctionWidget(QWidget *parent) : QOpenGLWidget(parent)
{

}

CoreFunctionWidget::~CoreFunctionWidget()
{
    glDeleteVertexArrays(1, &amp;VAO);
    glDeleteBuffers(1, &amp;VBO);
//    glDeleteBuffers(1, &amp;EBO);
}

void CoreFunctionWidget::initializeGL(){
    this-&gt;initializeOpenGLFunctions();

    bool success = shaderProgram.addShaderFromSourceFile(QOpenGLShader::Vertex, &quot;:/triangle.vert&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; shaderProgram.log();
        return;
    }

    success = shaderProgram.addShaderFromSourceFile(QOpenGLShader::Fragment, &quot;:/triangle.frag&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; shaderProgram.log();
        return;
    }

    success = shaderProgram.link();
    if(!success) {
        qDebug() &lt;&lt; &quot;shaderProgram link failed!&quot; &lt;&lt; shaderProgram.log();
    }

    //VAO，VBO数据部分
    float vertices[] = {
        0.5f,  0.5f, 0.0f,  // top right
         0.5f, -0.5f, 0.0f,  // bottom right
        -0.5f, -0.5f, 0.0f,  // bottom left
        -0.5f,  0.5f, 0.0f   // top left
    };
    unsigned int indices[] = {  // note that we start from 0!
        0, 1, 3,  // first Triangle
        1, 2, 3   // second Triangle
    };

    glGenVertexArrays(1, &amp;VAO);
    glGenBuffers(1, &amp;VBO);
    glGenBuffers(1, &amp;EBO);
    // bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s).
    glBindVertexArray(VAO);

    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);  //顶点数据复制到缓冲

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (void*)0);//告诉程序如何解析顶点数据
    glEnableVertexAttribArray(0);

    glBindBuffer(GL_ARRAY_BUFFER, 0);//取消VBO的绑定, glVertexAttribPointer已经把顶点属性关联到顶点缓冲对象了

//    remember: do NOT unbind the EBO while a VAO is active as the bound element buffer object IS stored in the VAO; keep the EBO bound.
//    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

//    You can unbind the VAO afterwards so other VAO calls won&#39;t accidentally modify this VAO, but this rarely happens. Modifying other
//    VAOs requires a call to glBindVertexArray anyways so we generally don&#39;t unbind VAOs (nor VBOs) when it&#39;s not directly necessary.
    glBindVertexArray(0);   //取消VAO绑定

    //线框模式，QOpenGLExtraFunctions没这函数, 3_3_Core有
//    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
}

void CoreFunctionWidget::resizeGL(int w, int h){
    glViewport(0, 0, w, h);
}

void CoreFunctionWidget::paintGL(){
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    shaderProgram.bind();
    glBindVertexArray(VAO); // seeing as we only have a single VAO there&#39;s no need to bind it every time, but we&#39;ll do so to keep things a bit more organized
//    glDrawArrays(GL_TRIANGLES, 0, 6);
    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);

    shaderProgram.release();
}

</code></pre><h2 id="使用Qt相关函数版"><a href="#使用Qt相关函数版" class="headerlink" title="使用Qt相关函数版"></a>使用Qt相关函数版</h2><h3 id="QtFunctionWidget-h"><a href="#QtFunctionWidget-h" class="headerlink" title="QtFunctionWidget.h"></a>QtFunctionWidget.h</h3><pre><code>#ifndef QTFUNCTIONWIDGET_H
#define QTFUNCTIONWIDGET_H

#include &lt;QOpenGLWidget&gt;


#include &lt;QOpenGLWidget&gt;
#include &lt;QOpenGLShader&gt;
#include &lt;QOpenGLShaderProgram&gt;
#include &lt;QDebug&gt;
#include &lt;QOpenGLFunctions&gt;
#include &lt;QOpenGLVertexArrayObject&gt;
#include &lt;QOpenGLBuffer&gt;

class QtFunctionWidget : public QOpenGLWidget, protected QOpenGLFunctions
{
public:
    QtFunctionWidget(QWidget *parent = nullptr);
    ~QtFunctionWidget() Q_DECL_OVERRIDE;

protected:
    virtual void initializeGL() Q_DECL_OVERRIDE;
    virtual void resizeGL(int w, int h) Q_DECL_OVERRIDE;
    virtual void paintGL() Q_DECL_OVERRIDE;

private:
    QOpenGLShaderProgram shaderProgram;
    QOpenGLBuffer vbo, ebo;
    QOpenGLVertexArrayObject vao;
};

#endif // QTFUNCTIONWIDGET_H

</code></pre><h3 id="QtFunctionWidget-cpp"><a href="#QtFunctionWidget-cpp" class="headerlink" title="QtFunctionWidget.cpp"></a>QtFunctionWidget.cpp</h3><pre><code>#include &quot;QtFunctionWidget.h&quot;

#include &lt;QFile&gt;

QtFunctionWidget::QtFunctionWidget(QWidget *parent) : QOpenGLWidget (parent),
    vbo(QOpenGLBuffer::VertexBuffer),
    ebo(QOpenGLBuffer::IndexBuffer)
{

}

QtFunctionWidget::~QtFunctionWidget(){
    makeCurrent();

    vbo.destroy();
    ebo.destroy();
    vao.destroy();

    doneCurrent();
}

void QtFunctionWidget::initializeGL(){
    this-&gt;initializeOpenGLFunctions();

    bool success = shaderProgram.addShaderFromSourceFile(QOpenGLShader::Vertex, &quot;:/triangle.vert&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; shaderProgram.log();
        return;
    }

    success = shaderProgram.addShaderFromSourceFile(QOpenGLShader::Fragment, &quot;:/triangle.frag&quot;);
    if (!success) {
        qDebug() &lt;&lt; &quot;shaderProgram addShaderFromSourceFile failed!&quot; &lt;&lt; shaderProgram.log();
        return;
    }

    success = shaderProgram.link();
    if(!success) {
        qDebug() &lt;&lt; &quot;shaderProgram link failed!&quot; &lt;&lt; shaderProgram.log();
    }

    //VAO，VBO数据部分
    GLfloat vertices[] = {
        0.5f,  0.5f, 0.0f,  // top right
         0.5f, -0.5f, 0.0f,  // bottom right
        -0.5f, -0.5f, 0.0f,  // bottom left
        -0.5f,  0.5f, 0.0f   // top left
    };
    unsigned int indices[] = {  // note that we start from 0!
        0, 1, 3,  // first Triangle
        1, 2, 3   // second Triangle
    };

    QOpenGLVertexArrayObject::Binder vaoBind(&amp;vao);

    vbo.create();
    vbo.bind();
    vbo.allocate(vertices, sizeof(vertices));

    ebo.create();
    ebo.bind();
    ebo.allocate(indices, sizeof(indices));

    int attr = -1;
    attr = shaderProgram.attributeLocation(&quot;aPos&quot;);
    shaderProgram.setAttributeBuffer(attr, GL_FLOAT, 0, 3, sizeof(GLfloat) * 3);
    shaderProgram.enableAttributeArray(attr);

    vbo.release();
//    remember: do NOT unbind the EBO while a VAO is active as the bound element buffer object IS stored in the VAO; keep the EBO bound.
//    ebo.release();
}

void QtFunctionWidget::resizeGL(int w, int h){
    glViewport(0, 0, w, h);
}

void QtFunctionWidget::paintGL(){
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    shaderProgram.bind();
    {
        QOpenGLVertexArrayObject::Binder vaoBind(&amp;vao);
        glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
    }
    shaderProgram.release();
}

</code></pre><h2 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h2><h3 id="triangle-vert"><a href="#triangle-vert" class="headerlink" title="triangle.vert"></a>triangle.vert</h3><pre><code>#version 330 core
layout(location = 0) in vec3 aPos;

void main(){
    gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0f);
}
</code></pre><h3 id="triangle-frag"><a href="#triangle-frag" class="headerlink" title="triangle.frag"></a>triangle.frag</h3><pre><code>#version 330 core
out vec4 FragColor;

void main(){
    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);
}
</code></pre><h2 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h2><pre><code>#include &lt;QApplication&gt;
#include &quot;MainWindow.h&quot;
#include &quot;QtFunctionWidget.h&quot;
#include &quot;CoreFunctionWidget.h&quot;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

//    MainWindow w;
    QtFunctionWidget w1;
    CoreFunctionWidget w2;

    w1.setWindowTitle(QObject::tr(&quot;QtFunction&quot;));
    w2.setWindowTitle(QObject::tr(&quot;CoreFunction&quot;));

    w1.show();
    w2.show();

    return a.exec();
}

</code></pre></the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt5.12.4 Android环境配置]]></title>
      <url>https://longxuan.ren/2019/07/25/Qt-Android-environment/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>Qt5.12.4 Android环境配置，从入门到入土<em>(:з)∠)</em> <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="Java-JDK-配置"><a href="#Java-JDK-配置" class="headerlink" title="Java JDK 配置"></a>Java JDK 配置</h2><h3 id="Java-JDK-下载"><a href="#Java-JDK-下载" class="headerlink" title="Java JDK 下载"></a>Java JDK 下载</h3><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/" target="_blank" rel="noopener">JDK下载地址戳这里</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Android-environment_01.png" alt="JDK下载"></p>
<h3 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h3><p>安装过程略，一路下一步就行，安装完毕需要把Java相关路径添加到环境变量。<br>在环境变量里新建两个用户变量（用户变量是当前用户环境变量，系统变量是所有用户的）：</p>
<ul>
<li><p>JAVA_HOME，值为安装的Java JDK 目录，<code>C:\Program Files\Java\jdk1.8.0_221</code><br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Android-environment_02.png" alt="JAVA_HOME"></p>
</li>
<li><p>CLASSPATH，值为<code>.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</code><br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Android-environment_03.png" alt="CLASSPATH"></p>
</li>
</ul>
<p>再在Path里添加两个环境变量：</p>
<ul>
<li><code>%JAVA_HOME%\bin</code></li>
<li><code>%JAVA_HOME%\jre\bin</code><br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Android-environment_04.png" alt="环境变量"></li>
</ul>
<p>设置完点确定就可以在命令行输入<code>java -version</code>，来测试下环境变量设置好没。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Android-environment_05.png" alt="java -version"></p>
<h2 id="NDK-配置"><a href="#NDK-配置" class="headerlink" title="NDK 配置"></a>NDK 配置</h2><p><a href="https://developer.android.google.cn/ndk/downloads/" target="_blank" rel="noopener">NDK 下载地址戳这里</a><br>下载特定的版本r19c，<code>https://dl.google.com/android/repository/android-ndk-r19c-windows-x86_64.zip</code><br>下载后直接解压到一个路径不包含空格的目录即可，包含空格Qt不识别。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Android-environment_06.png" alt="NDK解压"></p>
<h2 id="Android-SDK-配置"><a href="#Android-SDK-配置" class="headerlink" title="Android SDK 配置"></a>Android SDK 配置</h2><h3 id="仅安装SDK-（具体参考下方其他博客链接）"><a href="#仅安装SDK-（具体参考下方其他博客链接）" class="headerlink" title="仅安装SDK （具体参考下方其他博客链接）"></a>仅安装SDK （具体参考下方其他博客链接）</h3><p>下载地址：<code>https://dl.google.com/android/repository/sdk-tools-windows-4333796.zip</code>。<br>同上NDK，解压即可。参考位置 <code>C:\Android\sdk-tools-windows-4333796</code>。<br>如果您不需要 Android Studio，可以从下面下载基本的 Android 命令行工具。您可以使用随附的 sdkmanager 下载其他 SDK 软件包。<br><a href="https://developer.android.com/studio/command-line/sdkmanager" target="_blank" rel="noopener">sdkmanager | Android Developers</a>。<br>命令行执行<code>sdkmanager &quot;build-tools&quot; &quot;platform-tools&quot; &quot;platforms;android-28&quot;</code>。</p>
<h3 id="安装Android-Studio"><a href="#安装Android-Studio" class="headerlink" title="安装Android Studio"></a>安装Android Studio</h3><p><a href="https://www.androiddevtools.cn/" target="_blank" rel="noopener">下载地址戳这里</a><br>我是之前已经装好了Android Studio了，就直接用其自带的SDK Manager了。相关配置仅供参考，我也不确定哪些是必须的哈，勾选9.0因为我手机就是Android9.0的。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Android-environment_07.png" alt="SDK Platforms"><br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Android-environment_08.png" alt="SDK Tools"></p>
<p><strong><em>Android 相关的下载大部分都需要翻墙，最省事的是将小飞机的代理模式改为全局模式</em></strong><br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Android-environment_09.png" alt="小飞机全局模式"></p>
<h2 id="Qt配置"><a href="#Qt配置" class="headerlink" title="Qt配置"></a>Qt配置</h2><p>  <a href="https://download.qt.io/official_releases/qt/" target="_blank" rel="noopener">Qt各版本下载戳这里</a>，我这里用的是5.12.4，此版本有个重大更新：logo换了233333<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Android-environment_10.png" alt="5.12.2"><br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Android-environment_11.png" alt="5.12.4"></p>
<p>Qt5.12.4下载链接，<code>http://iso.mirrors.ustc.edu.cn/qtproject/archive/qt/5.12/5.12.4/qt-opensource-windows-x86-5.12.4.exe</code><br>构建套件Android的3个都勾上了，基本不占多少空间，这里吐槽下Mingw一个就要5GB多…<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Android-environment_12.png" alt="构建套件选择"></p>
<p>安装好后打开Qt Creator，在选项-&gt;设备里，填好上面设置的JDK、Android SDK、NDK路径。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Android-environment_13.png" alt="配置Android相关路径"></p>
<h2 id="运行Demo测试"><a href="#运行Demo测试" class="headerlink" title="运行Demo测试"></a>运行Demo测试</h2><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>Qt新建个项目，点那个像手机的，构建套件把Android的都勾上，方便切换不勾选这么多也行。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Android-environment_14.png" alt="新建项目"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Android-environment_15.png" alt="构建套件选择"></p>
<h3 id="开启USB调试"><a href="#开启USB调试" class="headerlink" title="开启USB调试"></a>开启USB调试</h3><p>我这里直接真机调试，手机要允许USB调试，小米6开启是在设置-&gt;更多设置-&gt;开发者选项-&gt;USB调试、USB安装，这两个选项打开。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Android-environment_16.jpeg" alt="开启USB调试"></p>
<h3 id="编译运行遇到的问题"><a href="#编译运行遇到的问题" class="headerlink" title="编译运行遇到的问题"></a>编译运行遇到的问题</h3><p>点击Qt Creator的绿色小三角就开始编译运行了，此时手机会提示允许USB调试，允许后就能看到自己的手机了，手机允许后此界面没刷新可以点左下角的<code>Refresh Device List</code>。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Android-environment_17.png" alt="手机设备"></p>
<p>编译过程很慢，可以看到查看下方编译输出，提示为<code>Downloading https://services.gradle.org/distributions/gradle-4.6-bin.zip</code>，这个很迷，开着小飞机也下不动，但是复制下载链接到浏览器立马就能下下来。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Android-environment_18.png" alt="编译输出提示"></p>
<p>取消编译，将下载好的gradle-4.6-bin.zip拷贝到下载目录，下载的两个临时文件gradle-4.6-bin.zip.lck、gradle-4.6-bin.zip.part删掉。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Android-environment_19.png" alt="gradle-4.6-bin.zip下载"></p>
<p>重新开始编译，后面就很顺利，可以直接运行了。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Android-environment_20.jpeg" alt="滚动Demo运行"></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://blog.csdn.net/future_ai/article/details/85616180" target="_blank" rel="noopener">QT–Android之全配置教程</a></li>
<li><a href="https://zx9229.github.io/2019/01/26/Qt-For-Android%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">Qt-For-Android配置</a></li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ffmpeg相关常用命令及可选参数]]></title>
      <url>https://longxuan.ren/2019/07/05/ffmpeg-command/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>ffmpeg相关常用命令及可选参数, 包括ffmpeg.exe、 ffplay.exe、 ffprobe.exe, 程序下载链接<a href="https://ffmpeg.zeranoe.com/builds/" target="_blank" rel="noopener">戳这里</a>, 选择static即可 <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="ffmpeg"><a href="#ffmpeg" class="headerlink" title="ffmpeg"></a>ffmpeg</h2><h3 id="ffmpeg-常用命令"><a href="#ffmpeg-常用命令" class="headerlink" title="ffmpeg 常用命令"></a>ffmpeg 常用命令</h3><pre><code>//列出所有设备
ffmpeg -list_devices true -f dshow -i dummy

//提取h264裸流
ffmpeg -i video.mp4 -codec copy -f h264 video.h264
ffmpeg -i video.mp4 -an -vcodec copy video.h264

//提取aac裸流
ffmpeg -i video.mp4 -vn -acodec copy audio.aac

//桌面采集录制
ffmpeg -f gdigrab -video_size 1920x1080 -t 10 -r 30 -i desktop -vcodec libx264 x264.mp4
ffmpeg -f gdigrab -video_size 1920x1080 -t 40 -r 30 -i desktop -vcodec h264_qsv x264.mp4
ffmpeg -f dshow -i video=&quot;screen-capture-recorder&quot; -f dshow -i audio=&quot;virtual-audio-capturer&quot; -t 40 -r 30 -vcodec libx264 output.mp4

//桌面采集推流
ffmpeg -f gdigrab -i desktop -vcodec libx264 -preset:v ultrafast -tune:v zerolatency -f flv rtmp://server/live/streamName

//桌面+声卡采集推流 (virtual-audio-capturer需要安装相关程序，https://sourceforge.net/projects/screencapturer/files/)
ffmpeg -f dshow -i video=&quot;screen-capture-recorder&quot; -f dshow -i audio=&quot;virtual-audio-capturer&quot; -pix_fmt yuv420p -vcodec libx264 -acodec aac -s 1280x720 -r 25 -q 10 -ar 44100 -ac 2 -tune zerolatency -preset ultrafast -f flv rtmp://server/live/streamName

//文件源推流
ffmpeg -re -i video.mp4 -c copy -f flv rtmp://server/live/streamName

//直播流录制
ffmpeg -i rtmp://server/live/streamName -c copy dump.flv

//mkv转mp4
ffmpeg -i video.mkv -codec copy video.mp4

//视频切割
ffmpeg -ss 00:01:00 -t 00:01:03 -y -i video.mp4 -vcodec copy -acodec copy cutting.mp4 

//视频缩放, iw是输入的宽度, iw/2就是一半;-1 为保持宽高比
ffmpeg -i video.mp4 -vf scale=iw/2:-1 output.mp4

//视频截取, 从[80,60]的位置开始, 截取200x100的视频
ffmpeg -i video.mp4 -filter:v &quot;crop=80:60:200:100&quot; -c:a copy output-200x100.mp4

//视频截取, 右下角1/4
ffmpeg -i video.mp4 -filter:v &quot;crop=in_w/2:in_h/2:in_w/2:in_h/2&quot; -c:a copy output-1-4.mp4

//指定时间截图
ffmpeg -ss 00:00:30 -i video.mp4 -y -f image2 -vframes 1 image.png

//每隔20S截图
ffmpeg -i video.mp4 -f image2 -vf fps=fps=1/20 out%d.png

//将视频转为gif
ffmpeg -i video.mp4 -ss 0:0:30 -t 10 -s 320x240 -pix_fmt rgb24 output.gif

//图片转换为视频
ffmpeg -f image2 -i out%4d.png -r 25 video.mp4

//添加图片水印,colorkey将图片中指定颜色变为透明
ffmpeg -i video.mp4 -i test.png -filter_complex &quot;[1:v]colorkey=0xFFFFFF:0.6:1.0[ckout];[0:v][ckout]overlay=x=W-w-10:y=0[out]&quot; -map &quot;[out]&quot; -movflags faststart drawimage.mp4

//添加文字水印，simsun.ttc是宋体，字体可更换
ffmpeg.exe  -i video.mp4 -vf &quot;drawtext=fontfile=simsun.ttc: text=&#39;文字水印&#39;:x=100:y=100:fontsize=28:fontcolor=red:shadowy=2&quot; drawtext.mp4

//内嵌字幕(嵌入视频中)
ffmpeg -i video.mp4 -vf ass=subtitles.ass output.mp4

//内挂字幕(视频字幕还是分离的，会导致进度条不能拖动)
ffmpeg -i video.mp4 -i subtitles.ass -c:s mov_text -c:v copy -c:a copy output.mp4

//加密视频
ffmpeg -i video.mp4 -vcodec copy -acodec copy -encryption_scheme cenc-aes-ctr -encryption_key 76a6c65c5ea76 2046bd749a2e632ccbb -encryption_kid a7e61c373e219033c21091fa607bf3b8 video_encrypted.mp4
//播放加密视频
ffplay video_encrypted.mp4 -decryption_key 76a6c65c5ea762046bd749a2e632ccbb

//视频拼接
ffmpeg -f concat -i filelist.txt -c copy output.mp4
</code></pre><h3 id="ffmpeg可选参数"><a href="#ffmpeg可选参数" class="headerlink" title="ffmpeg可选参数"></a>ffmpeg可选参数</h3><h4 id="通用选项"><a href="#通用选项" class="headerlink" title="通用选项"></a>通用选项</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-L</td>
<td>license</td>
</tr>
<tr>
<td>-h</td>
<td>帮助</td>
</tr>
<tr>
<td>-fromats</td>
<td>显示可用的格式，编解码的，协议的…</td>
</tr>
<tr>
<td>-f</td>
<td>强迫采用格式fmt</td>
</tr>
<tr>
<td>-i filename</td>
<td>输入文件</td>
</tr>
<tr>
<td>-y</td>
<td>覆盖输出文件</td>
</tr>
<tr>
<td>-t duration</td>
<td>设置纪录时间 hh:mm:ss[.xxx]格式的记录时间也支持</td>
</tr>
<tr>
<td>-ss position</td>
<td>搜索到指定的时间 [-]hh:mm:ss[.xxx]的格式也支持</td>
</tr>
<tr>
<td>-title string</td>
<td>设置标题</td>
</tr>
<tr>
<td>-author string</td>
<td>设置作者</td>
</tr>
<tr>
<td>-copyright string</td>
<td>设置版权</td>
</tr>
<tr>
<td>-comment string</td>
<td>设置评论</td>
</tr>
<tr>
<td>-target type</td>
<td>设置目标文件类型(vcd,svcd,dvd) 所有的格式选项（比特率，编解码以及缓冲区大小）自动设置</td>
</tr>
<tr>
<td>-hq</td>
<td>激活高质量设置</td>
</tr>
<tr>
<td>-itsoffset offset</td>
<td>置以秒为基准的时间偏移，该选项影响所有后面的输入文件，定义一个正偏移意味着相应的流被延迟了 offset秒</td>
</tr>
</tbody>
</table>
<h4 id="视频选项"><a href="#视频选项" class="headerlink" title="视频选项"></a>视频选项</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-b bitrate</td>
<td>设置比特率，缺省200kb/s</td>
</tr>
<tr>
<td>-r fps</td>
<td>设置帧频 缺省25</td>
</tr>
<tr>
<td>-s size</td>
<td>设置帧大小 格式为WXH 缺省160X128</td>
</tr>
<tr>
<td>-aspect aspect</td>
<td>设置横纵比 4:3 16:9 或 1.3333 1.7777</td>
</tr>
<tr>
<td>-croptop size</td>
<td>设置顶部切除带大小 像素单位</td>
</tr>
<tr>
<td>-cropbottom size</td>
<td>同上，方向不同</td>
</tr>
<tr>
<td>–cropleft size</td>
<td>同上，方向不同</td>
</tr>
<tr>
<td>–cropright size</td>
<td>同上，方向不同</td>
</tr>
<tr>
<td>-padtop size</td>
<td>设置顶部补齐的大小 像素单位</td>
</tr>
<tr>
<td>-padbottom size</td>
<td>同上，方向不同</td>
</tr>
<tr>
<td>–padleft size</td>
<td>同上，方向不同</td>
</tr>
<tr>
<td>–padright size</td>
<td>同上，方向不同</td>
</tr>
<tr>
<td>–padcolor color</td>
<td>设置补齐条颜色(hex,6个16进制的数，红:绿:兰排列，比如 000000代表黑色)</td>
</tr>
<tr>
<td>-vn</td>
<td>不做视频记录</td>
</tr>
<tr>
<td>-bt tolerance</td>
<td>设置视频码率容忍度kbit/s</td>
</tr>
<tr>
<td>-maxrate bitrate</td>
<td>设置最大视频码率容忍度</td>
</tr>
<tr>
<td>-minrate bitreate</td>
<td>设置最小视频码率容忍度</td>
</tr>
<tr>
<td>-bufsize size</td>
<td>设置码率控制缓冲区大小</td>
</tr>
<tr>
<td>-bufsize size</td>
<td>设置码率控制缓冲区大小</td>
</tr>
<tr>
<td>-vcodec codec</td>
<td>强制使用codec编解码方式。如果用copy表示原始编解码数据必须被拷贝</td>
</tr>
<tr>
<td>-sameq</td>
<td>使用同样视频质量作为源（VBR）</td>
</tr>
<tr>
<td>-pass n</td>
<td>选择处理遍数（1或者2）。两遍编码非常有用。第一遍生成统计信息，第二遍生成精确的请求的码率</td>
</tr>
<tr>
<td>-passlogfile file</td>
<td>选择两遍的纪录文件名为file</td>
</tr>
</tbody>
</table>
<h4 id="高级视频选项"><a href="#高级视频选项" class="headerlink" title="高级视频选项"></a>高级视频选项</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-g gop_size</td>
<td>设置图像组大小</td>
</tr>
<tr>
<td>-intra</td>
<td>仅适用帧内编码</td>
</tr>
<tr>
<td>-qscale q</td>
<td>使用固定的视频量化标度(VBR)</td>
</tr>
<tr>
<td>-qmin q</td>
<td>最小视频量化标度(VBR)</td>
</tr>
<tr>
<td>-qmax q</td>
<td>最大视频量化标度(VBR)</td>
</tr>
<tr>
<td>-qdiff q</td>
<td>量化标度间最大偏差 (VBR)</td>
</tr>
<tr>
<td>-qblur blur</td>
<td>视频量化标度柔化(VBR)</td>
</tr>
<tr>
<td>-qcomp compression</td>
<td>视频量化标度压缩(VBR)</td>
</tr>
<tr>
<td>-rc_init_cplx complexity</td>
<td>一遍编码的初始复杂度</td>
</tr>
<tr>
<td>-b_qfactor factor</td>
<td>在p和b帧间的qp因子</td>
</tr>
<tr>
<td>-i_qfactor factor</td>
<td>在p和i帧间的qp因子</td>
</tr>
<tr>
<td>-b_qoffset offset</td>
<td>在p和b帧间的qp偏差</td>
</tr>
<tr>
<td>-i_qoffset offset</td>
<td>在p和i帧间的qp偏差</td>
</tr>
<tr>
<td>-rc_eq equation</td>
<td>设置码率控制方程 默认tex^qComp</td>
</tr>
<tr>
<td>-rc_override override</td>
<td>特定间隔下的速率控制重载</td>
</tr>
<tr>
<td>-me method</td>
<td>设置运动估计的方法 可用方法有 zero phods log x1 epzs(缺省) full</td>
</tr>
<tr>
<td>-dct_algo algo</td>
<td>设置dct的算法 可用的有 0 FF_DCT_AUTO 缺省的DCT 1 FF_DCT_FASTINT 2 FF_DCT_INT 3 FF_DCT_MMX 4 FF_DCT_MLIB 5 FF_DCT_ALTIVEC</td>
</tr>
<tr>
<td>-idct_algo algo</td>
<td>设置idct算法。可用的有 0 FF_IDCT_AUTO 缺省的IDCT 1 FF_IDCT_INT 2 FF_IDCT_SIMPLE 3 FF_IDCT_SIMPLEMMX 4 FF_IDCT_LIBMPEG2MMX 5 FF_IDCT_PS2 6 FF_IDCT_MLIB 7 FF_IDCT_ARM 8 FF_IDCT_ALTIVEC 9 FF_IDCT_SH4 10 FF_IDCT_SIMPLEARM</td>
</tr>
<tr>
<td>-er n</td>
<td>设置错误残留为n 1 FF_ER_CAREFULL 缺省 2 FF_ER_COMPLIANT 3 FF_ER_AGGRESSIVE 4 FF_ER_VERY_AGGRESSIVE</td>
</tr>
<tr>
<td>-ec bit_mask</td>
<td>设置错误掩蔽为bit_mask,该值为如下值的位掩码 1 FF_EC_GUESS_MVS (default=enabled) 2 FF_EC_DEBLOCK (default=enabled)</td>
</tr>
<tr>
<td>-bf frames</td>
<td>使用frames B 帧，支持mpeg1,mpeg2,mpeg4</td>
</tr>
<tr>
<td>-mbd mode</td>
<td>宏块决策 0 FF_MB_DECISION_SIMPLE 使用mb_cmp 1 FF_MB_DECISION_BITS 2 FF_MB_DECISION_RD</td>
</tr>
<tr>
<td>-4mv</td>
<td>使用4个运动矢量 仅用于mpeg4</td>
</tr>
<tr>
<td>-part</td>
<td>使用数据划分 仅用于mpeg4</td>
</tr>
<tr>
<td>-bug param</td>
<td>绕过没有被自动监测到编码器的问题</td>
</tr>
<tr>
<td>-strict strictness</td>
<td>跟标准的严格性</td>
</tr>
<tr>
<td>-aic</td>
<td>使能高级帧内编码 h263+</td>
</tr>
<tr>
<td>-umv</td>
<td>使能无限运动矢量 h263+</td>
</tr>
<tr>
<td>-deinterlace</td>
<td>不采用交织方法</td>
</tr>
<tr>
<td>-interlace</td>
<td>强迫交织法编码仅对mpeg2和mpeg4有效。当你的输入是交织的并且你想要保持交织以最小图像损失的时候采用该选项。可选的方法是不交织，但是损失更大</td>
</tr>
<tr>
<td>-psnr</td>
<td>计算压缩帧的psnr</td>
</tr>
<tr>
<td>-vstats</td>
<td>输出视频编码统计到vstats_hhmmss.log</td>
</tr>
<tr>
<td>-vhook module</td>
<td>插入视频处理模块 module 包括了模块名和参数，用空格分开</td>
</tr>
</tbody>
</table>
<h4 id="音频选项"><a href="#音频选项" class="headerlink" title="音频选项"></a>音频选项</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-ab bitrate</td>
<td>设置音频码率</td>
</tr>
<tr>
<td>-ar freq</td>
<td>设置音频采样率</td>
</tr>
<tr>
<td>-ac channels</td>
<td>设置通道 缺省为1</td>
</tr>
<tr>
<td>-an</td>
<td>不使能音频纪录</td>
</tr>
<tr>
<td>-acodec codec</td>
<td>使用codec编解码</td>
</tr>
</tbody>
</table>
<h4 id="音频-视频捕获选项"><a href="#音频-视频捕获选项" class="headerlink" title="音频/视频捕获选项"></a>音频/视频捕获选项</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-vd device</td>
<td>设置视频捕获设备。比如/dev/video0</td>
</tr>
<tr>
<td>-vc channel</td>
<td>设置视频捕获通道 DV1394专用</td>
</tr>
<tr>
<td>-tvstd standard</td>
<td>置电视标准 NTSC PAL(SECAM)</td>
</tr>
<tr>
<td>-dv1394</td>
<td>设置DV1394捕获</td>
</tr>
<tr>
<td>-av device</td>
<td>设置音频设备 比如/dev/dsp</td>
</tr>
</tbody>
</table>
<h4 id="高级选项"><a href="#高级选项" class="headerlink" title="高级选项"></a>高级选项</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-map file:stream</td>
<td>设置输入流映射</td>
</tr>
<tr>
<td>-debug</td>
<td>打印特定调试信息</td>
</tr>
<tr>
<td>-benchmark</td>
<td>为基准测试加入时间</td>
</tr>
<tr>
<td>-hex</td>
<td>倾倒每一个输入包</td>
</tr>
<tr>
<td>-bitexact</td>
<td>仅使用位精确算法 用于编解码测试</td>
</tr>
<tr>
<td>-ps size</td>
<td>设置包大小，以bits为单位</td>
</tr>
<tr>
<td>-re</td>
<td>以本地帧频读数据，主要用于模拟捕获设备</td>
</tr>
<tr>
<td>-loop</td>
<td>循环输入流（只工作于图像流，用于ffserver测试）</td>
</tr>
</tbody>
</table>
<h2 id="ffplay"><a href="#ffplay" class="headerlink" title="ffplay"></a>ffplay</h2><h3 id="ffplay常用命令"><a href="#ffplay常用命令" class="headerlink" title="ffplay常用命令"></a>ffplay常用命令</h3><pre><code>//从30s开始播放10s，播放完退出
ffplay -ss 00:00:30 -t 10 -autoexit video.mp4

//指定播放窗口大小为320x180
ffplay -x 320 -y 180 video.mp4

//音频波形可视化
ffplay -showmode 1 audio.aac
</code></pre><h3 id="ffplay可选参数"><a href="#ffplay可选参数" class="headerlink" title="ffplay可选参数"></a>ffplay可选参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-x width</td>
<td>强制以 “width” 宽度显示</td>
</tr>
<tr>
<td>-y height</td>
<td>强制以 “height” 高度显示</td>
</tr>
<tr>
<td>-an</td>
<td>禁止音频</td>
</tr>
<tr>
<td>-vn</td>
<td>禁止视频</td>
</tr>
<tr>
<td>-ss pos</td>
<td>跳转到指定的位置(秒)</td>
</tr>
<tr>
<td>-t duration</td>
<td>播放 “duration” 秒音/视频</td>
</tr>
<tr>
<td>-bytes</td>
<td>按字节跳转</td>
</tr>
<tr>
<td>-nodisp</td>
<td>禁止图像显示(只输出音频)</td>
</tr>
<tr>
<td>-f fmt</td>
<td>强制使用 “fmt” 格式</td>
</tr>
<tr>
<td>-window_title title</td>
<td>设置窗口标题(默认为输入文件名)</td>
</tr>
<tr>
<td>-loop number</td>
<td>循环播放 “number” 次(0将一直循环)</td>
</tr>
<tr>
<td>-showmode mode</td>
<td>设置显示模式,可选mode： 0, 显示视频; 1, 显示音频波形; 2, 显示音频频带。默认为0, 播放时按w键可切换mode</td>
</tr>
<tr>
<td>-i input_file</td>
<td>指定输入文件</td>
</tr>
<tr>
<td>-sync type</td>
<td>设置主时钟为音频、视频、或者外部。默认为音频。主时钟用来进行音视频同步</td>
</tr>
<tr>
<td>-threads count</td>
<td>设置线程个数</td>
</tr>
<tr>
<td>-autoexit</td>
<td>播放完成后自动退出</td>
</tr>
<tr>
<td>-exitonkeydown</td>
<td>任意键按下时退出</td>
</tr>
<tr>
<td>-exitonmousedown</td>
<td>任意鼠标按键按下时退出</td>
</tr>
<tr>
<td>-acodec codec_name</td>
<td>强制指定音频解码器为 “codec_name”</td>
</tr>
<tr>
<td>-vcodec codec_name</td>
<td>强制指定视频解码器为 “codec_name”</td>
</tr>
<tr>
<td>-scodec codec_name</td>
<td>强制指定字幕解码器为 “codec_name”</td>
</tr>
</tbody>
</table>
<h3 id="ffplay快捷键"><a href="#ffplay快捷键" class="headerlink" title="ffplay快捷键"></a>ffplay快捷键</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>q</td>
<td>退出</td>
</tr>
<tr>
<td>f</td>
<td>全屏</td>
</tr>
<tr>
<td>p</td>
<td>暂停</td>
</tr>
<tr>
<td>w</td>
<td>切换显示模式(视频/音频波形/音频频带)</td>
</tr>
<tr>
<td>s</td>
<td>步进到下一帧</td>
</tr>
<tr>
<td>left/right</td>
<td>快退/快进 10 秒</td>
</tr>
<tr>
<td>down/up</td>
<td>快退/快进 1 分钟</td>
</tr>
<tr>
<td>page down/page up</td>
<td>跳转到前一章/下一章(如果没有章节，快退/快进 10 分钟)</td>
</tr>
<tr>
<td>mouse click</td>
<td>跳转到鼠标点击的位置(根据鼠标在显示窗口点击的位置计算百分比)</td>
</tr>
</tbody>
</table>
<h2 id="ffprobe"><a href="#ffprobe" class="headerlink" title="ffprobe"></a>ffprobe</h2><h3 id="ffprobe常用命令"><a href="#ffprobe常用命令" class="headerlink" title="ffprobe常用命令"></a>ffprobe常用命令</h3><pre><code>//打印视频format信息，代码里就是av_dump_format()函数
ffprobe -show_format video.mp4

//以json格式输出&quot;streams&quot;音视频编码信息，还有“format”音视频封包信息
ffprobe -v quiet -show_format -show_streams -print_format json video.mp4
</code></pre><h3 id="ffprobe可选参数"><a href="#ffprobe可选参数" class="headerlink" title="ffprobe可选参数"></a>ffprobe可选参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-show_packets</td>
<td>[PACKET]标签的多媒体信息</td>
</tr>
<tr>
<td>-show_data</td>
<td>packets多媒体数据</td>
</tr>
<tr>
<td>-show_format</td>
<td>多媒体封装格式</td>
</tr>
<tr>
<td>-show_frames</td>
<td>视频帧信息</td>
</tr>
<tr>
<td>-print_format</td>
<td>信息输出格式，支持xml、csv、json、flat、ini</td>
</tr>
<tr>
<td>-select_streams</td>
<td>参数可以是a、v、s分别表示只查看音频、视频、字幕</td>
</tr>
</tbody>
</table>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://blog.csdn.net/leixiaohua1020/article/details/12751349" target="_blank" rel="noopener">ffmpeg参数中文详细解释</a></li>
<li><a href="https://www.jianshu.com/p/11b6c4eb9e49" target="_blank" rel="noopener">FFmpeg常用命令及参数</a></li>
<li><a href="https://www.cnblogs.com/renhui/p/8458802.html" target="_blank" rel="noopener">FFmpeg命令行工具学习(二)：播放媒体文件的工具ffplay</a></li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> ffmpeg </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ffmpeg </tag>
            
            <tag> ffplay </tag>
            
            <tag> ffprobe </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt-msvc使用Protocol Buffers]]></title>
      <url>https://longxuan.ren/2019/07/04/Qt-use-Protobuf/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>Qt + VS2017 使用Protocol Buffers<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Protocol Buffer是google 的一种数据交换的格式，它独立于语言，独立于平台。google 提供了多种语言的实现：java、c#、c++、go 和 python，每一种实现都包含了相应语言的编译器以及库文件。由于它是一种二进制的格式，比使用 xml进行数据交换快许多。可以把它用于分布式应用之间的数据通信或者异构环境下的数据交换。作为一种效率和兼容性都很优秀的二进制数据传输格式，可以用于诸如网络传输、配置文件、数据存储等诸多领域。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li>Qt-msvc相关配置，我的是Qt5.12.2 + VS2017，<a href="https://www.jianshu.com/p/ac22d511aea6" target="_blank" rel="noopener">相关环境搭建教程戳这里</a>。</li>
<li>Protocol Buffer源码下载，我使用的是<a href="https://github.com/protocolbuffers/protobuf/releases/download/v3.8.0/protobuf-cpp-3.8.0.zip" target="_blank" rel="noopener">protobuf-cpp-3.8.0.zip</a>。</li>
<li>CMake安装，我用的是3.13.4 64bit, <a href="https://cmake.org/download/" target="_blank" rel="noopener">相关下载链接</a>。</li>
</ol>
<h2 id="编译Protocol-Buffer"><a href="#编译Protocol-Buffer" class="headerlink" title="编译Protocol Buffer"></a>编译Protocol Buffer</h2><h3 id="配置CMake"><a href="#配置CMake" class="headerlink" title="配置CMake"></a>配置CMake</h3><ol>
<li>打开CMake (cmake-gui)，设置好源码路径和build路径。</li>
<li>点击左下角的configure，弹出的对话框中编译32位就选择，<code>Visual Studio 15 2017</code>;64位就选择Visual Studio 15 2017 Win64。</li>
<li>configure选好后，就会有下图红色部分的配置信息，其中蓝色的项是确定编译生成动态库还是静态库的，要生成动态库就勾选上，其他配置默认不变。</li>
<li>点击左下角的Generate，生成VS的工程文件。</li>
<li>点击左下角的Open Project，打开对应的VS工程。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-use-Protobuf_01.png" alt="CMake配置"><br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-use-Protobuf_02.png" alt="Configure选择"></li>
</ol>
<h3 id="VS中生成库文件"><a href="#VS中生成库文件" class="headerlink" title="VS中生成库文件"></a>VS中生成库文件</h3><ol>
<li>release还是debug在菜单栏切换<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-use-Protobuf_03.png" alt="releasse、debug切换"></li>
<li>大工程中还包含了些测试工程，必须生成的有两个，也可以偷懒直接右键解决方案-&gt;生成解决方案。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-use-Protobuf_04.png" alt="不同工程"></li>
<li>生成的文件就在之前设置的CMakebuild目录下的Debug、Release文件夹下。</li>
</ol>
<h2 id="使用Protocol-Buffer"><a href="#使用Protocol-Buffer" class="headerlink" title="使用Protocol Buffer"></a>使用Protocol Buffer</h2><h3 id="库文件整理"><a href="#库文件整理" class="headerlink" title="库文件整理"></a>库文件整理</h3><ol>
<li>新建一个protobuf文件夹，再建include、bin、lib三个子文件夹。</li>
<li>将源码文件夹下的<code>protobuf-3.8.0\src\google</code>这个google文件夹拷贝至include中。</li>
<li>libprotobufd.dll、libprotocd.dll、protoc.exe放到bin中。</li>
<li>libprotobufd.lib、libprotocd.lib放到lib中。</li>
</ol>
<h3 id="定义proto文件"><a href="#定义proto文件" class="headerlink" title="定义proto文件"></a>定义proto文件</h3><p>新建一个person.proto文件，文件内容如下：</p>
<pre><code>package tutorial;

message Person {
  required int32 id = 1;
  required string name = 2;
  optional string email = 3;
}
</code></pre><h3 id="生成C-代码"><a href="#生成C-代码" class="headerlink" title="生成C++代码"></a>生成C++代码</h3><p>将person.proto放至bin目录下，在命令行输入下方内容或者新建个bat输入下方内容保存并运行：</p>
<pre><code>protoc --cpp_out=./ person.proto
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-use-Protobuf_05.png" alt="TIM截图20190704145611.png"></p>
<h3 id="Qt中使用Protocol-Buffer"><a href="#Qt中使用Protocol-Buffer" class="headerlink" title="Qt中使用Protocol Buffer"></a>Qt中使用Protocol Buffer</h3><p>新建一个控制台工程，将上面生成的person.pb.h、person.pb.cc加入工程，并修改main.cpp和.pro文件</p>
<h4 id="pro文件"><a href="#pro文件" class="headerlink" title="pro文件"></a>pro文件</h4><pre><code>QT -= gui

CONFIG += c++11 console
CONFIG -= app_bundle

# The following define makes your compiler emit warnings if you use
# any Qt feature that has been marked deprecated (the exact warnings
# depend on your compiler). Please consult the documentation of the
# deprecated API in order to know how to port your code away from it.
DEFINES += QT_DEPRECATED_WARNINGS

# You can also make your code fail to compile if it uses deprecated APIs.
# In order to do so, uncomment the following line.
# You can also select to disable deprecated APIs only up to a certain version of Qt.
#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0

DEFINES += PROTOBUF_USE_DLLS

INCLUDEPATH += $$PWD/protobuf/include
LIBS += -L$$PWD/protobuf/bin/debug -L$$PWD/protobuf/lib/debug -llibprotobufd

SOURCES += \
        main.cpp \
    person.pb.cc

# Default rules for deployment.
qnx: target.path = /tmp/$${TARGET}/bin
else: unix:!android: target.path = /opt/$${TARGET}/bin
!isEmpty(target.path): INSTALLS += target

HEADERS += \
    person.pb.h

</code></pre><h4 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h4><pre><code>#include &lt;QCoreApplication&gt;
#include &lt;QDataStream&gt;
#include &lt;QFile&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;QDebug&gt;
#include &quot;person.pb.h&quot;

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    GOOGLE_PROTOBUF_VERIFY_VERSION;

    //set person protobuf
    tutorial::Person person;
    person.set_id(123456);
    person.set_name(&quot;Mark&quot;);
    person.set_email(&quot;mark@example.com&quot;);

    //write
    QFile file_out(QCoreApplication::applicationDirPath() + &quot;/person.pb&quot;);
    if(!file_out.open(QIODevice::WriteOnly)) {
        qDebug() &lt;&lt; &quot;can not open file&quot;;
    }

    std::ostringstream streamOut;
    person.SerializeToOstream(&amp;streamOut);
    QByteArray byteArray(streamOut.str().c_str());

    QDataStream out(&amp;file_out);
    out &lt;&lt; byteArray.length();
    out.writeRawData(byteArray.data(), byteArray.length());
    file_out.close();

    //read
    QFile file_in(QCoreApplication::applicationDirPath() + &quot;/person.pb&quot;);
    if(!file_in.open(QIODevice::ReadOnly)) {
         qDebug() &lt;&lt; &quot;can not open file&quot;;
    }

    QDataStream in(&amp;file_in);
    int dataLength = 0;
    in &gt;&gt; dataLength;

    QByteArray byteArray2;
    byteArray2.resize(dataLength);
    in.readRawData(byteArray2.data(), dataLength);

    tutorial::Person person2;
    if (!person2.ParseFromArray(byteArray2.data(), byteArray2.size())) {
      qDebug() &lt;&lt; &quot;Failed to parse person.pb.&quot;;
    }

    qDebug() &lt;&lt; &quot;ID: &quot; &lt;&lt; person.id();
    qDebug() &lt;&lt; &quot;name: &quot; &lt;&lt; QString::fromStdString(person.name());
    if (person.has_email()) {
        qDebug() &lt;&lt; &quot;e-mail: &quot; &lt;&lt; QString::fromStdString(person.email());
    }
    file_in.close();

    return a.exec();
}
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-use-Protobuf_06.png" alt="运行结果"></p>
<p>Protocol Buffers数据写入和读取的简单应用就完成了。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://blog.csdn.net/yizhou2010/article/details/80610881" target="_blank" rel="noopener">Google Protocol Buffer在windows下的配置</a></li>
<li><a href="https://blog.csdn.net/hp_cpp/article/details/81561310" target="_blank" rel="noopener">protobuf的编译和使用，在windows平台上</a></li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> msvc </tag>
            
            <tag> Protobuf </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ffmpeg从MP4中提取H264裸流（新旧API对比）]]></title>
      <url>https://longxuan.ren/2019/07/03/ffmpeg-get-raw-h264/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>ffmpeg从MP4中提取H264裸流，新旧API对比<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在分离mpe中的H264码流的时候，如果使用ffmpeg在命令行操作非常简单，<code>ffmpeg -i video.mp4 -codec copy -f h264 video.h264</code>，这一句就可以将MP4中的H264裸流提取出来了。<br>尝试着想用代码来实现这一功能，发现将<code>av_read_frame()</code>得到的AVPacket存入文件，得到的文件用PotPlayer是不能播放的。通过查找相关内容发现，MP4格式需要使用FFMPEG中的名为”h264_mp4toannexb”的bitstream filter 来处理AVPacket，下面是新旧API在实现上的不同部分。</p>
<h2 id="老版本API"><a href="#老版本API" class="headerlink" title="老版本API"></a>老版本API</h2><pre><code>AVBitStreamFilterContext* h264bsfc =  av_bitstream_filter_init(&quot;h264_mp4toannexb&quot;); 

AVPacket packet;
while( av_read_frame(format_ctx_, &amp;packet) &gt;= 0 ) {
    if( packet.stream_index == video_stream_index ) {
        uint8_t* outbuf = nullptr;
        int outlen = 0;
        av_bitstream_filter_filter(h264bsfc, codec_ctx_, NULL, 
            &amp;outbuf, &amp;outlen, packet.data, packet.size, 0);
        fwrite(packet.data, packet.size, 1, fp);
        if(outbuf){
            av_free(outbuf);
        }
    }

    av_free_packet(&amp;packet);
}

av_bitstream_filter_close(h264bsfc);
</code></pre><h2 id="新版本API"><a href="#新版本API" class="headerlink" title="新版本API"></a>新版本API</h2><pre><code>AVBSFContext * h264bsfc;
const AVBitStreamFilter * filter = av_bsf_get_by_name(&quot;h264_mp4toannexb&quot;);
ret = av_bsf_alloc(filter, &amp;h264bsfc);
avcodec_parameters_copy(h264bsfc-&gt;par_in, input_fmt_ctx-&gt;streams[video_stream_index]-&gt;codecpar);
av_bsf_init(h264bsfc);

AVPacket* packet = av_packet_alloc();
while( av_read_frame(format_ctx_, packet) &gt;= 0 ) {
    if( packet.stream_index == video_stream_index ) {
        ret = av_bsf_send_packet(h264bsfc, packet);
        if(ret &lt; 0) qDebug(&quot;av_bsf_send_packet error&quot;);

        while ((ret = av_bsf_receive_packet(h264bsfc, packet)) == 0) {
            fwrite(packet-&gt;data, packet-&gt;size, 1, fp);
        }
    }

    av_packet_unref(packet);
}

av_packet_free(&amp;packet);
av_bsf_free(&amp;h264bsfc);
</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://blog.csdn.net/leixiaohua1020/article/details/11800877" target="_blank" rel="noopener">使用FFMPEG类库分离出多媒体文件中的H.264码流</a></li>
<li><a href="https://xilixili.net/2018/08/20/ffmpeg-got-raw-h264/" target="_blank" rel="noopener">用ffmpeg从MP4提取H264裸流</a></li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> ffmpeg </category>
            
        </categories>
        
        
        <tags>
            
            <tag> H264 </tag>
            
            <tag> ffmpeg </tag>
            
            <tag> MP4 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt键盘-Android键盘映射]]></title>
      <url>https://longxuan.ren/2019/06/17/Qt-Android-Keycode-Map/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>在做远程控制的时候，需要在本地先捕获当前键盘事件，再将按的键发送给远端，在被控制端模拟对应的键盘事件来做出反应。要让程序知道按了键盘上的某个键，可以通过<a href="https://baike.baidu.com/item/%E9%94%AE%E7%9B%98%E6%89%AB%E6%8F%8F%E7%A0%81" target="_blank" rel="noopener">键盘扫描码</a>或者各平台的<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E9%94%AE%E7%A0%81" target="_blank" rel="noopener">虚拟键码</a>来实现。<br>同一个键盘的键盘扫描码在不同平台结果都是相同的，但是不同厂家的键盘，以及接口不同的键盘(PS/2、USB) 扫描码都有可能不一样，为了减少硬件的影响还是将两个平台的虚拟键码做个映射。<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="映射表"><a href="#映射表" class="headerlink" title="映射表"></a>映射表</h2><p>只做了常见的键盘上的键，并不是全部的哈~</p>
<h3 id="主键盘"><a href="#主键盘" class="headerlink" title="主键盘"></a>主键盘</h3><table>
<thead>
<tr>
<th>Qt按键</th>
<th>Android按键</th>
<th>Android键码</th>
</tr>
</thead>
<tbody>
<tr>
<td>Qt::Key_Escape</td>
<td>KEYCODE_ESCAPE</td>
<td>111</td>
</tr>
<tr>
<td>Qt::Key_F1</td>
<td>KEYCODE_F1</td>
<td>131</td>
</tr>
<tr>
<td>Qt::Key_F2</td>
<td>KEYCODE_F2</td>
<td>132</td>
</tr>
<tr>
<td>Qt::Key_F3</td>
<td>KEYCODE_F3</td>
<td>133</td>
</tr>
<tr>
<td>Qt::Key_F4</td>
<td>KEYCODE_F4</td>
<td>134</td>
</tr>
<tr>
<td>Qt::Key_F5</td>
<td>KEYCODE_F5</td>
<td>135</td>
</tr>
<tr>
<td>Qt::Key_F6</td>
<td>KEYCODE_F6</td>
<td>136</td>
</tr>
<tr>
<td>Qt::Key_F7</td>
<td>KEYCODE_F7</td>
<td>137</td>
</tr>
<tr>
<td>Qt::Key_F8</td>
<td>KEYCODE_F8</td>
<td>138</td>
</tr>
<tr>
<td>Qt::Key_F9</td>
<td>KEYCODE_F9</td>
<td>139</td>
</tr>
<tr>
<td>Qt::Key_F10</td>
<td>KEYCODE_F10</td>
<td>140</td>
</tr>
<tr>
<td>Qt::Key_F11</td>
<td>KEYCODE_F11</td>
<td>141</td>
</tr>
<tr>
<td>Qt::Key_F12</td>
<td>KEYCODE_F12</td>
<td>142</td>
</tr>
<tr>
<td>Qt::Key_QuoteLeft</td>
<td>KEYCODE_GRAVE</td>
<td>68</td>
</tr>
<tr>
<td>Qt::Key_0</td>
<td>KEYCODE_0</td>
<td>7</td>
</tr>
<tr>
<td>Qt::Key_1</td>
<td>KEYCODE_1</td>
<td>8</td>
</tr>
<tr>
<td>Qt::Key_2</td>
<td>KEYCODE_2</td>
<td>9</td>
</tr>
<tr>
<td>Qt::Key_3</td>
<td>KEYCODE_3</td>
<td>10</td>
</tr>
<tr>
<td>Qt::Key_4</td>
<td>KEYCODE_4</td>
<td>11</td>
</tr>
<tr>
<td>Qt::Key_5</td>
<td>KEYCODE_5</td>
<td>12</td>
</tr>
<tr>
<td>Qt::Key_6</td>
<td>KEYCODE_6</td>
<td>13</td>
</tr>
<tr>
<td>Qt::Key_7</td>
<td>KEYCODE_7</td>
<td>14</td>
</tr>
<tr>
<td>Qt::Key_8</td>
<td>KEYCODE_8</td>
<td>15</td>
</tr>
<tr>
<td>Qt::Key_9</td>
<td>KEYCODE_9</td>
<td>16</td>
</tr>
<tr>
<td>Qt::Key_Minus</td>
<td>KEYCODE_MINUS</td>
<td>69</td>
</tr>
<tr>
<td>Qt::Key_Equal</td>
<td>KEYCODE_EQUALS</td>
<td>70</td>
</tr>
<tr>
<td>Qt::Key_Backspace</td>
<td>KEYCODE_DEL</td>
<td>67</td>
</tr>
<tr>
<td>Qt::Key_A</td>
<td>KEYCODE_A</td>
<td>29</td>
</tr>
<tr>
<td>Qt::Key_B</td>
<td>KEYCODE_B</td>
<td>30</td>
</tr>
<tr>
<td>Qt::Key_C</td>
<td>KEYCODE_C</td>
<td>31</td>
</tr>
<tr>
<td>Qt::Key_D</td>
<td>KEYCODE_D</td>
<td>32</td>
</tr>
<tr>
<td>Qt::Key_E</td>
<td>KEYCODE_E</td>
<td>33</td>
</tr>
<tr>
<td>Qt::Key_F</td>
<td>KEYCODE_F</td>
<td>34</td>
</tr>
<tr>
<td>Qt::Key_G</td>
<td>KEYCODE_G</td>
<td>35</td>
</tr>
<tr>
<td>Qt::Key_H</td>
<td>KEYCODE_H</td>
<td>36</td>
</tr>
<tr>
<td>Qt::Key_I</td>
<td>KEYCODE_I</td>
<td>37</td>
</tr>
<tr>
<td>Qt::Key_J</td>
<td>KEYCODE_J</td>
<td>38</td>
</tr>
<tr>
<td>Qt::Key_K</td>
<td>KEYCODE_K</td>
<td>39</td>
</tr>
<tr>
<td>Qt::Key_L</td>
<td>KEYCODE_L</td>
<td>40</td>
</tr>
<tr>
<td>Qt::Key_M</td>
<td>KEYCODE_M</td>
<td>41</td>
</tr>
<tr>
<td>Qt::Key_N</td>
<td>KEYCODE_N</td>
<td>42</td>
</tr>
<tr>
<td>Qt::Key_O</td>
<td>KEYCODE_O</td>
<td>43</td>
</tr>
<tr>
<td>Qt::Key_P</td>
<td>KEYCODE_P</td>
<td>44</td>
</tr>
<tr>
<td>Qt::Key_Q</td>
<td>KEYCODE_Q</td>
<td>45</td>
</tr>
<tr>
<td>Qt::Key_R</td>
<td>KEYCODE_R</td>
<td>46</td>
</tr>
<tr>
<td>Qt::Key_S</td>
<td>KEYCODE_S</td>
<td>47</td>
</tr>
<tr>
<td>Qt::Key_T</td>
<td>KEYCODE_T</td>
<td>48</td>
</tr>
<tr>
<td>Qt::Key_U</td>
<td>KEYCODE_U</td>
<td>49</td>
</tr>
<tr>
<td>Qt::Key_V</td>
<td>KEYCODE_V</td>
<td>50</td>
</tr>
<tr>
<td>Qt::Key_W</td>
<td>KEYCODE_W</td>
<td>51</td>
</tr>
<tr>
<td>Qt::Key_X</td>
<td>KEYCODE_X</td>
<td>52</td>
</tr>
<tr>
<td>Qt::Key_Y</td>
<td>KEYCODE_Y</td>
<td>53</td>
</tr>
<tr>
<td>Qt::Key_Z</td>
<td>KEYCODE_Z</td>
<td>54</td>
</tr>
<tr>
<td>Qt::Key_Tab</td>
<td>KEYCODE_TAB</td>
<td>61</td>
</tr>
<tr>
<td>Qt::Key_CapsLock</td>
<td>KEYCODE_CAPS_LOCK</td>
<td>115</td>
</tr>
<tr>
<td>Qt::Key_Space</td>
<td>KEYCODE_SPACE</td>
<td>62</td>
</tr>
<tr>
<td>Qt::Key_BracketLeft</td>
<td>KEYCODE_LEFT_BRACKET</td>
<td>71</td>
</tr>
<tr>
<td>Qt::Key_BracketRight</td>
<td>KEYCODE_RIGHT_BRACKET</td>
<td>72</td>
</tr>
<tr>
<td>Qt::Key_Backslash</td>
<td>KEYCODE_BACKSLASH</td>
<td>73</td>
</tr>
<tr>
<td>Qt::Key_Semicolon</td>
<td>KEYCODE_SEMICOLON</td>
<td>74</td>
</tr>
<tr>
<td>Qt::Key_Apostrophe</td>
<td>KEYCODE_APOSTROPHE</td>
<td>75</td>
</tr>
<tr>
<td>Qt::Key_Return</td>
<td>KEYCODE_ENTER</td>
<td>66</td>
</tr>
<tr>
<td>Qt::Key_Comma</td>
<td>KEYCODE_COMMA</td>
<td>55</td>
</tr>
<tr>
<td>Qt::Key_Period</td>
<td>KEYCODE_PERIOD</td>
<td>56</td>
</tr>
<tr>
<td>Qt::Key_Slash</td>
<td>KEYCODE_SLASH</td>
<td>76</td>
</tr>
<tr>
<td>Qt::Key_ScrollLock</td>
<td>KEYCODE_SCROLL_LOCK</td>
<td>116</td>
</tr>
<tr>
<td>Qt::Key_Pause</td>
<td>KEYCODE_BREAK</td>
<td>121</td>
</tr>
<tr>
<td>Qt::Key_Insert</td>
<td>KEYCODE_INSERT</td>
<td>124</td>
</tr>
<tr>
<td>Qt::Key_Home</td>
<td>KEYCODE_MOVE_HOME</td>
<td>122</td>
</tr>
<tr>
<td>Qt::Key_PageUp</td>
<td>KEYCODE_PAGE_UP</td>
<td>92</td>
</tr>
<tr>
<td>Qt::Key_Delete</td>
<td>KEYCODE_FORWARD_DEL</td>
<td>112</td>
</tr>
<tr>
<td>Qt::Key_End</td>
<td>KEYCODE_MOVE_END</td>
<td>123</td>
</tr>
<tr>
<td>Qt::Key_PageDown</td>
<td>KEYCODE_PAGE_DOWN</td>
<td>93</td>
</tr>
<tr>
<td>Qt::Key_Up</td>
<td>KEYCODE_DPAD_UP</td>
<td>19</td>
</tr>
<tr>
<td>Qt::Key_Down</td>
<td>KEYCODE_DPAD_DOWN</td>
<td>20</td>
</tr>
<tr>
<td>Qt::Key_Left</td>
<td>KEYCODE_DPAD_LEFT</td>
<td>21</td>
</tr>
<tr>
<td>Qt::Key_Right</td>
<td>KEYCODE_DPAD_RIGHT</td>
<td>22</td>
</tr>
<tr>
<td>Qt::Key_Menu</td>
<td>KEYCODE_MENU</td>
<td>82</td>
</tr>
<tr>
<td>Qt::Key_Meta</td>
<td>—</td>
<td>—</td>
</tr>
<tr>
<td>Qt::Key_Control</td>
<td>KEYCODE_CTRL_LEFT</td>
<td>113</td>
</tr>
<tr>
<td>Qt::Key_Shift</td>
<td>KEYCODE_SHIFT_LEFT</td>
<td>59</td>
</tr>
<tr>
<td>Qt::Key_Alt</td>
<td>KEYCODE_ALT_LEFT</td>
<td>57</td>
</tr>
</tbody>
</table>
<h3 id="小键盘"><a href="#小键盘" class="headerlink" title="小键盘"></a>小键盘</h3><p>只标了和主键盘不同的键码，通过<code>event-&gt;modifiers() &amp; Qt::KeypadModifier</code>检测按的键是否为小键盘上的键：</p>
<table>
<thead>
<tr>
<th>Qt按键</th>
<th>Android按键</th>
<th>Android键码</th>
</tr>
</thead>
<tbody>
<tr>
<td>Qt::Key_NumLock</td>
<td>KEYCODE_NUM_LOCK</td>
<td>143</td>
</tr>
<tr>
<td>Qt::Key_Slash</td>
<td>KEYCODE_NUMPAD_DIVIDE</td>
<td>154</td>
</tr>
<tr>
<td>Qt::Key_Asterisk</td>
<td>KEYCODE_NUMPAD_MULTIPLY</td>
<td>155</td>
</tr>
<tr>
<td>Qt::Key_0</td>
<td>KEYCODE_NUMPAD_0</td>
<td>144</td>
</tr>
<tr>
<td>Qt::Key_1</td>
<td>KEYCODE_NUMPAD_1</td>
<td>145</td>
</tr>
<tr>
<td>Qt::Key_2</td>
<td>KEYCODE_NUMPAD_2</td>
<td>146</td>
</tr>
<tr>
<td>Qt::Key_3</td>
<td>KEYCODE_NUMPAD_3</td>
<td>147</td>
</tr>
<tr>
<td>Qt::Key_4</td>
<td>KEYCODE_NUMPAD_4</td>
<td>148</td>
</tr>
<tr>
<td>Qt::Key_5</td>
<td>KEYCODE_NUMPAD_5</td>
<td>149</td>
</tr>
<tr>
<td>Qt::Key_6</td>
<td>KEYCODE_NUMPAD_6</td>
<td>150</td>
</tr>
<tr>
<td>Qt::Key_7</td>
<td>KEYCODE_NUMPAD_7</td>
<td>151</td>
</tr>
<tr>
<td>Qt::Key_8</td>
<td>KEYCODE_NUMPAD_8</td>
<td>152</td>
</tr>
<tr>
<td>Qt::Key_9</td>
<td>KEYCODE_NUMPAD_9</td>
<td>153</td>
</tr>
<tr>
<td>Qt::Key_Minus</td>
<td>KEYCODE_NUMPAD_SUBTRACT</td>
<td>156</td>
</tr>
<tr>
<td>Qt::Key_Plus</td>
<td>KEYCODE_NUMPAD_ADD</td>
<td>157</td>
</tr>
<tr>
<td>Qt::Key_Period</td>
<td>KEYCODE_NUMPAD_DOT</td>
<td>158</td>
</tr>
<tr>
<td>Qt::Key_Enter</td>
<td>KEYCODE_ENTER</td>
<td>66</td>
</tr>
</tbody>
</table>
<h3 id="组合键"><a href="#组合键" class="headerlink" title="组合键"></a>组合键</h3><p>组合键发送一个按键列表给被控制端， 例如需要按住Shift切换的键，发送Shift + 键盘上对应的键</p>
<table>
<thead>
<tr>
<th>Qt按键</th>
<th>Android按键</th>
<th>Android键码</th>
</tr>
</thead>
<tbody>
<tr>
<td>Qt::Key_AsciiTilde</td>
<td>—</td>
<td>59 + 68</td>
</tr>
<tr>
<td>Qt::Key_Exclam</td>
<td>—</td>
<td>59 + 8</td>
</tr>
<tr>
<td>Qt::Key_At</td>
<td>—</td>
<td>59 + 9</td>
</tr>
<tr>
<td>Qt::Key_NumberSign</td>
<td>—</td>
<td>59 + 10</td>
</tr>
<tr>
<td>Qt::Key_Dollar</td>
<td>—</td>
<td>59 + 11</td>
</tr>
<tr>
<td>Qt::Key_Percent</td>
<td>—</td>
<td>59 +12</td>
</tr>
<tr>
<td>Qt::Key_AsciiCircum</td>
<td>—</td>
<td>59 + 13</td>
</tr>
<tr>
<td>Qt::Key_Ampersand</td>
<td>—</td>
<td>59 + 14</td>
</tr>
<tr>
<td>Qt::Key_Asterisk</td>
<td>—</td>
<td>59 + 15</td>
</tr>
<tr>
<td>Qt::Key_ParenLeft</td>
<td>—</td>
<td>59 + 16</td>
</tr>
<tr>
<td>Qt::Key_ParenRight</td>
<td>—</td>
<td>59 + 7</td>
</tr>
<tr>
<td>Qt::Key_Underscore</td>
<td>—</td>
<td>59 + 69</td>
</tr>
<tr>
<td>Qt::Key_Plus</td>
<td>—</td>
<td>59 + 70</td>
</tr>
<tr>
<td>Qt::Key_BraceLeft</td>
<td>—</td>
<td>59 + 71</td>
</tr>
<tr>
<td>Qt::Key_BraceRight</td>
<td>—</td>
<td>59 + 72</td>
</tr>
<tr>
<td>Qt::Key_Bar</td>
<td>—</td>
<td>59 + 73</td>
</tr>
<tr>
<td>Qt::Key_Colon</td>
<td>—</td>
<td>59 + 74</td>
</tr>
<tr>
<td>Qt::Key_QuoteDbl</td>
<td>—</td>
<td>59 + 75</td>
</tr>
<tr>
<td>Qt::Key_Less</td>
<td>—</td>
<td>59 + 55</td>
</tr>
<tr>
<td>Qt::Key_Greater</td>
<td>—</td>
<td>59 + 56</td>
</tr>
<tr>
<td>Qt::Key_Question</td>
<td>—</td>
<td>59 + 76</td>
</tr>
</tbody>
</table>
<p>其余的根据<code>event-&gt;modifiers()</code>来识别功能键，再加上键盘键， 例如<code>Ctrl+A =&gt; 113+29</code>。</p>
<pre><code>    if (event-&gt;modifiers() &amp; Qt::ControlModifier) {
        //ctrl
    }

    if (event-&gt;modifiers() &amp; Qt::ShiftModifier) {
        //shift
    }

    if (event-&gt;modifiers() &amp; Qt::AltModifier) {
        //alt
    }

    if (event-&gt;modifiers() &amp; Qt::MetaModifier) {
        //win
    }
</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://doc.qt.io/qt-5/qt.html" target="_blank" rel="noopener">Qt键盘码</a></li>
<li><a href="https://www.cnblogs.com/findyou/p/5614178.html" target="_blank" rel="noopener">Android键盘码</a></li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> Android </tag>
            
            <tag> Keycode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt程序的持续集成]]></title>
      <url>https://longxuan.ren/2019/03/02/Continuous-integration-of-Qt-programs/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>持续集成用到的相关软件TeamCity，这里就不多介绍了，主要说明下自动构建、打包脚本相关内容 <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="构建程序"><a href="#构建程序" class="headerlink" title="构建程序"></a>构建程序</h2><p>源代码通过编译生成exe的过程就是构建了，写代码的时候IDE的绿色小三角点击之后就会编译你写好的程序，没有错误的话还会顺便将生成的程序运行起来。这一过程用脚本来做的话就是自动构建了，其实IDE也是通过命令调用编译程序的，可以点击<code>项目-&gt;构建设置</code>查看。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Continuous-integration-of-Qt-programs_01.png" alt="构建设置"></p>
<h3 id="Qt-mingw-构建参数"><a href="#Qt-mingw-构建参数" class="headerlink" title="Qt-mingw 构建参数"></a>Qt-mingw 构建参数</h3><pre><code>SET PATH=%PATH%;C:\Qt\Qt5.7.0\5.7\mingw53_32\bin;
SET PATH=%PATH%;C:\Qt\Qt5.7.0\Tools\mingw530_32\bin;
SET RELEASE_DIR=%~dp0..\RunImage\release

CD %~dp0..
//Delete the last generated directory
...
if EXIST &quot;RunImage&quot; (
    RD /S /Q &quot;RunImage&quot;
)
...

mingw32-make.exe clean
qmake.exe YourProject.pro -spec win32-g++ &quot;CONFIG+=release&quot; &amp;&amp; mingw32-make.exe qmake_all
mingw32-make.exe -j8
lrelease YourProject.pro

//copy you knows dll
copy /y Third\ffmpeg\bin\*.dll RunImage\release\

CD %RELEASE_DIR%
//copy Qt dll
windeployqt.exe YouProgram.exe 
</code></pre><h3 id="Qt-msvc-构建参数"><a href="#Qt-msvc-构建参数" class="headerlink" title="Qt-msvc 构建参数"></a>Qt-msvc 构建参数</h3><pre><code>SET PATH=%PATH%;C:\Qt\Qt5.12.0\5.12.0\msvc2017\bin;
SET PATH=%PATH%;C:\Qt\Qt5.12.0\Tools\QtCreator\bin;
SET PATH=%PATH%;C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Auxiliary\Build;
SET RELEASE_DIR=%~dp0..\RunImage\release

CD %~dp0..
//Delete the last generated directory
...
if EXIST &quot;RunImage&quot; (
    RD /S /Q &quot;RunImage&quot;
)
...

//Set msvc environment
call vcvarsall.bat amd64_x86

jom.exe clean
qmake.exe YourProject.pro -spec win32-msvc &quot;CONFIG+=qtquickcompiler&quot; &quot;CONFIG+=release&quot;
jom qmake_all
jom.exe
lrelease YourProject.pro

//copy you knows dll
copy /y Third\ffmpeg\bin\*.dll RunImage\release\

CD %RELEASE_DIR%
//copy Qt dll
windeployqt.exe YouProgram.exe 
</code></pre><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>构建的时候qmake在源码路径下执行的话，生成的makefile会在源码对应pro所在文件夹内，这就相当于IDE构建中的shadow build没开的情况，如果同时需要编译多个编译器的版本的时候，上一次编译的makefile会被下一个编译器读取导致编译失败，解决方法是在源码路径外调用qmake，相当于IDE的shadow build勾选的效果<pre><code>CD %~dp0..\..\build-test
qmake.exe %~dp0..\ComicReader.pro -spec win32-g++ &quot;CONFIG+=release&quot; &amp;&amp; mingw32-make.exe qmake_all
mingw32-make.exe -j4
</code></pre>这样makefile就会生成到build-test目录中了，默认其他生成文件也会在这里，也可以在pro中指定：<pre><code>MOC_DIR         = temp/moc
RCC_DIR         = temp/rcc
UI_DIR          = temp/ui
OBJECTS_DIR     = temp/obj
DESTDIR         = $$PWD/bin
</code></pre></li>
<li>msvc编译时要设置相关的环境，需要调用VS2017的脚本文件<code>call vcvarsall.bat amd64_x86</code> ，后面的参数是64位系统编译生成32位程序的选项</li>
</ol>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>构建并且将相关依赖的dll都拷贝到release目录后，将release目录弄个压缩包拷贝给别人就能用了，如果想弄好看点或者需要写注册表时，可以用nsis制作一个打包脚本，相关内容可以看之前的文章<a href="https://www.jianshu.com/p/138606e34997" target="_blank" rel="noopener">Qt之打包发布程序 (NSIS)</a></p>
<h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><p>前面两步按照顺序执行完后就将源码变成了最终的产品，这种固定的步骤就可以交给负责持续集成的软件来做了，只要指定好对应的环境变量还有目录位置即可，其他IDE也可以翻翻构建配置，找到命令行参数后同理。</p>
</the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> Continuous integration </tag>
            
            <tag> mingw </tag>
            
            <tag> msvc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt5.12.0 + VS2017 环境搭建]]></title>
      <url>https://longxuan.ren/2018/12/30/Qt5-12-0-VS2017-environment/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>Qt5.12.0在2018年12月5日发布，虽然平时工作还是在用Qt5.7.0的mingw32版(支持XP的最后一个mingw版本？)，放假了折腾下新版本看看。<br>2019.3.15更新：Qt5.12.2在2019.3.14发布，这个版本Mingw32又装回去了_(:з)∠)__ <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="构建版本选择"><a href="#构建版本选择" class="headerlink" title="构建版本选择"></a>构建版本选择</h2><p>Qt5.9以上的Qt安装程序可以在安装的时候选择mingw版本和VS版本等，但是每个版本对mingw和VS、32位和64位的支持都有点不太一样…..项目要是迁移的话需要注意下，比如：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt5-12-0-VS2017-environment_01.png" alt="Qt5.11.2"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt5-12-0-VS2017-environment_02.png" alt="Qt5.12.0"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt5-12-0-VS2017-environment_03.png" alt="Qt5.12.2"></p>
<ul>
<li>Qt5.11.2有mingw32版，VS2015有32位和64位， VS2017只有64位；</li>
<li>Qt5.12.0只有mingw64版，VS2017有32位和64位，VS2015只有64位；</li>
<li>Qt5.12.2有mingw32、64版，VS2017有32位和64位，VS2015只有64位；</li>
</ul>
<p><del>首先，mingw32我是需要的，这个官方版本没提供，需要自行编译；VS的32位也是需要的，一是要用VS调试的话32位好迁移，二是VS对XP支持可以在安装时勾选 (5.7.0后mingw版貌似没辙了)。所以，安装环境就确定为Qt5.12.0 + VS2017 + 自行编译的mingw32部分。</del><br>换成Qt5.12.2，安装版本为Mingw32、VS2017的32位、64位。</p>
<h2 id="VS2017安装"><a href="#VS2017安装" class="headerlink" title="VS2017安装"></a>VS2017安装</h2><p>VS2015还有iso安装的，2017好像只能在线安装了。VS2017安装器下载地址<a href="https://visualstudio.microsoft.com/zh-hans/downloads/" target="_blank" rel="noopener">戳这里</a>。Visual Studio Installer我开始装的时候点到VS2017 build Tool了，注意不是这个…我装的是2017的社区版，就上面第一个。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt5-12-0-VS2017-environment_04.png" alt="VS2017社区版选择"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt5-12-0-VS2017-environment_05.png" alt="VS2017安装组件"></p>
<p>C++桌面开发是要勾选的，右边对XP的支持看你需要选择，另外其他组件根据自己需要选择，全家桶好像有50多个G，越来越大了。</p>
<h2 id="Qt5-12-0-安装"><a href="#Qt5-12-0-安装" class="headerlink" title="Qt5.12.0 安装"></a>Qt5.12.0 安装</h2><p>5.12.0下载地址<a href="https://download.qt.io/archive/qt/5.12/5.12.0/" target="_blank" rel="noopener">戳这里</a>，安装就组件那里根据需要装就行了，我是勾选的MSVC2017的32位、64位、还有mingw的32位。只要装好了VS2017，在Qt的构建套件里，相关的编译器、调试器就会自动识别了。要是调试器没有(装VS没勾win10 SDK啥的)，可以另外装<a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/debugger/debugger-download-tools" target="_blank" rel="noopener">戳这里</a>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt5-12-0-VS2017-environment_06.png" alt="Qt构建套件"></p>
<h3 id="mingw32位安装-Qt5-12-2又把Mingw32给放到安装包里了-з-∠-……"><a href="#mingw32位安装-Qt5-12-2又把Mingw32给放到安装包里了-з-∠-……" class="headerlink" title="mingw32位安装  (Qt5.12.2又把Mingw32给放到安装包里了(:з)∠)……)"></a><del>mingw32位安装</del>  (Qt5.12.2又把Mingw32给放到安装包里了<em>(:з)∠)</em>……)</h3><p><del>可以自己下载Qt的源码编译，正好看到网上有人放了个编译好的版本，<a href="https://yadi.sk/d/oaPalrciE_lUJQ" target="_blank" rel="noopener">原下载地址</a>。国外的网盘下载速度较慢，另外传到百度云了，<a href="https://pan.baidu.com/s/18qURVWIL5gDEKyM1nqGbug" target="_blank" rel="noopener">提取码：enf5</a> (其实百度云也挺慢的…)。下载解压后，复制到Qt安装目录，在构建套件中，新建一个mingw32的构建套件:</del></p>
<p><del>1. Debuggers：添加<code>C:\Qt\Qt5.12.0\Tools\mingw730_32\bin\gdb.exe</code></del><br><del>2. 编译器：添加C：<code>C:\Qt\Qt5.12.0\Tools\mingw730_32\bin\gcc.exe</code>；添加C++：<code>C:\Qt\Qt5.12.0\Tools\mingw730_32\bin\g++.exe</code></del><br><del>3. Qt Version：添加<code>C:\Qt\Qt5.12.0\5.12.0\mingw73_32\bin\qmake.exe</code></del><br><del>4. 构建套件：添加一个新的mingw32套件，指定前面添加的编译器、调试器、Qt Versions，如图所示：</del></p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt5-12-0-VS2017-environment_07.png" alt="mingw32构建套件"></p>
<p><del>另外，这个编译的mingw32有个小bug，找不到Qt的plugin目录，需要在mingw32构建套件的环境变量中加下Qt的插件目录，<code>QT_PLUGIN_PATH=C:\Qt\Qt5.12.0\5.12.0\mingw73_32\plugins</code>，然后在Qt Creator这边编译生成32位的程序已经没有问题了。</del><br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt5-12-0-VS2017-environment_08.png" alt="添加环境变量"></p>
<h2 id="VS-Qt插件安装"><a href="#VS-Qt插件安装" class="headerlink" title="VS Qt插件安装"></a>VS Qt插件安装</h2><p>一般我是在Qt Creator开发，VS暂时是没怎么用到，这里简单介绍下怎么在VS建立Qt工程。</p>
<ol>
<li>安装Qt的扩展：点击工具-&gt;扩展和更新-&gt;联机-&gt;搜索Qt，下载安装后重启即可。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt5-12-0-VS2017-environment_09.png" alt="扩展和更新"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt5-12-0-VS2017-environment_10.png" alt="下载Qt扩展"></p>
<p>2.配置Qt MSVC目录，安装好后菜单会有一个Qt VS Tools，点击Qt Options，将32位和64位目录设置好。<br>32位：<code>C:\Qt\Qt5.12.0\5.12.0\msvc2017</code>，64位：<code>C:\Qt\Qt5.12.0\5.12.0\msvc2017_64</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt5-12-0-VS2017-environment_11.png" alt="配置Option"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt5-12-0-VS2017-environment_12.png" alt="配置Option"></p>
<ol start="3">
<li>新建个项目测试下，不知道为啥模板在测试里=-=</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt5-12-0-VS2017-environment_13.png" alt="新建项目"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt5-12-0-VS2017-environment_14.png" alt="运行结果"></p>
<h2 id="Creator工程、VS工程互相转换"><a href="#Creator工程、VS工程互相转换" class="headerlink" title="Creator工程、VS工程互相转换"></a>Creator工程、VS工程互相转换</h2><p>详细内容可以看之前的这篇-&gt;<a href="https://www.jianshu.com/p/d57108ddd9de" target="_blank" rel="noopener">Qt-mingw工程、Qt-msvc工程、VS工程相互转换</a>，其他环境搭建问题碰到再补充。</p>
</the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> VS2017 </tag>
            
            <tag> Qt5.12.0 </tag>
            
            <tag> Mingw32 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ffmpeg解码H264裸流为YUV数据]]></title>
      <url>https://longxuan.ren/2018/11/08/ffmpeg-H264-to-YUV/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>视频画面的传输中，由于原始数据过大，实际传输的数据是已经编码好的数据，一般是H264, 当客户端收到后就需要解码并显示出来。<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h3 id="裸流解析成AVPacket"><a href="#裸流解析成AVPacket" class="headerlink" title="裸流解析成AVPacket"></a>裸流解析成AVPacket</h3><h4 id="AVCodecParser"><a href="#AVCodecParser" class="headerlink" title="AVCodecParser"></a>AVCodecParser</h4><p>AVCodecParser用于解析输入的数据流并把它分成一帧一帧的压缩编码数据。就像是你把肉塞进火腿，再交给它负责帮你切片，够一个完整的帧就返回给你处理。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre><code>int parser_len = 0;

while(parser_len &lt; buffer.length()){
    parser_len += av_parser_parse2(m_pVideoParserContext, m_pVideoDecoder-&gt;GetCodecContext(),
                                   &amp;pParsePacket-&gt;data, &amp;pParsePacket-&gt;size,
                                   (uint8_t *)(buffer.data() + parser_len), buffer.length() - parser_len,
                                   AV_NOPTS_VALUE, AV_NOPTS_VALUE, AV_NOPTS_VALUE);

    if(0 == pParsePacket-&gt;size){
        continue;
    }

    switch(m_pVideoParserContext-&gt;pict_type){
        case AV_PICTURE_TYPE_I: qDebug(&quot;Type:I\t&quot;);break;
        case AV_PICTURE_TYPE_P: qDebug(&quot;Type:P\t&quot;);break;
        case AV_PICTURE_TYPE_B: qDebug(&quot;Type:B\t&quot;);break;
    default: qDebug(&quot;Type:Other\t&quot;);break;
}
    //pParsePacket就是一帧的数据包AVPacket，这里可以保存作为录像
    NotifyReceiveVideoPacket(pParsePacket);

    //丢给解码器处理
    m_pVideoDecoder-&gt;Decode(pParsePacket);

    av_packet_unref(pParsePacket);
} // parse H264 packet while
</code></pre><p>每次塞给AVCodecParser的数据是buffer中的数据，其中可能包含多个帧，所以内部会有一个while循环，parser_len是已经解析了的数据的长度，直到解析完一次的buffer，再塞新的数据到buffer继续处理。</p>
<h3 id="解码为AVFrame"><a href="#解码为AVFrame" class="headerlink" title="解码为AVFrame"></a>解码为AVFrame</h3><pre><code>if(0 != avcodec_send_packet(pCodecContext, pPacket)){
    qDebug(&quot;avcodec_send_packet failed&quot;);
    return false;
}

while(0 == avcodec_receive_frame(pCodecContext, pFrame)){
    //pFrame包含了解码后的YUV数据
    ...
}
</code></pre><p>由于AVFrame是ffmpeg的数据结构，要分别提取出Y、U、V三个通道的数据才能用于显示。</p>
<h3 id="YUV数据格式"><a href="#YUV数据格式" class="headerlink" title="YUV数据格式"></a>YUV数据格式</h3><p>RGB来表示颜色大家都不陌生，R(红色)、G(绿色)、B(蓝色)，通过这三基色就可以组合成其他需要的颜色。YUV也是一种表示颜色的方式，其中Y(亮度)、U(色度)、V(浓度)。YUV根据采样方式的不同又有YUV444、YUV422、YUV420等多种格式。这里主要介绍YUV420采样格式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/ffmpeg-H264-to-YUV_01.jpg" alt="YUV格式"></p>
<h4 id="YUV420"><a href="#YUV420" class="headerlink" title="YUV420"></a>YUV420</h4><p>YUV420格式是指，每个像素都保留一个Y分量 (亮度全抽样)，而在水平方向上，不是每行都取U和V分量，而是一行只取U分量，接着一行就只取V分量，以此重复(即4:2:0, 4:0:2, 4:2:0, 4:0:2 …….)。所以420不是指没有V，而是指一行采样只取U，另一行采样只取V。从4x4矩阵列来看，每4个矩阵点Y区域中，只有一个U和V，所以它们的比值是4:1。</p>
<h4 id="数据大小"><a href="#数据大小" class="headerlink" title="数据大小"></a>数据大小</h4><h5 id="对于1个像素的信息存储"><a href="#对于1个像素的信息存储" class="headerlink" title="对于1个像素的信息存储"></a>对于1个像素的信息存储</h5><ol>
<li>RGB格式：R、G、B各占8位，共24位，即3byte</li>
<li>YUV420格式： Y占8位，U、V每4个点共有一个，共8 + 8 / 4 + 8 / 4  = 12位，即3 / 2byte</li>
</ol>
<h5 id="对于一张图像的数据大小"><a href="#对于一张图像的数据大小" class="headerlink" title="对于一张图像的数据大小"></a>对于一张图像的数据大小</h5><ol>
<li>RGB格式：width <em> height </em> 3byte</li>
<li>YUV420格式：width <em> height </em> 3 / 2 byte</li>
</ol>
<p>所以采取YUV420来存储图像数据比RGB格式节省了一半的空间。</p>
<h4 id="YUV420P"><a href="#YUV420P" class="headerlink" title="YUV420P"></a>YUV420P</h4><p>采样好了数据，在存储YUV数据的时候，对于YUV不同的存储方式又有YUV420P(YV12)、YUV420SP(NV12)等分类。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/ffmpeg-H264-to-YUV_02.png" alt="yv12"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/ffmpeg-H264-to-YUV_03.png" alt="nv12"></p>
<p>从图上可以看出，YUV420P和NV12的区别就是一个是UV交替存储，一个是先存U再存V。这个在解码的时候就看你解码格式指定的是哪个了，默认解码是YUV420P。</p>
<h3 id="从AVFrame中获取YUV数据"><a href="#从AVFrame中获取YUV数据" class="headerlink" title="从AVFrame中获取YUV数据"></a>从AVFrame中获取YUV数据</h3><p>YUV420P在AVFrame中的存储，data[0]存Y分量，data[1]存U分量，data[2]存V分量。<strong>其中，图像每一行Y、U、V数据的大小分别是linesize[0]、linesize[1]、linesize[2]，除了实际的图像数据，还有一些填充数据是不需要的。</strong>填充数据应该是为了内存对齐，保留的话可能会导致花屏，具体可以看<a href="https://blog.csdn.net/dancing_night/article/details/80830920" target="_blank" rel="noopener">这里的分析</a>。</p>
<p>所以，获取实际的图像YUV数据代码为：</p>
<pre><code>for(int i = 0; i &lt; pFrame-&gt;height; i++)
  memcpy(m_pBuffer + pFrame-&gt;width * i, pFrame-&gt;data[0]  + pFrame-&gt;linesize[0] * i, pFrame-&gt;width);

for(int j = 0; j &lt; pFrame-&gt;height / 2; j++)
  memcpy(m_pBuffer + pFrame-&gt;width / 2 * j + ysize, pFrame-&gt;data[1]  + pFrame-&gt;linesize[1] * j, pFrame-&gt;width / 2);

for(int k = 0; k &lt; pFrame-&gt;height / 2; k++)
  memcpy(m_pBuffer + pFrame-&gt;width / 2 * k + ysize * 5 / 4, pFrame-&gt;data[2]  + pFrame-&gt;linesize[2] * k, pFrame-&gt;width / 2);
</code></pre><p>我是直接用一个pBuffer来保存YUV数据了，记住偏移量就行，想分开存也没问题。这里的数据就可以直接交给渲染部分来显示图像了。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://blog.csdn.net/leixiaohua1020/article/details/42181571" target="_blank" rel="noopener">最简单的基于FFmpeg的解码器-纯净版（不包含libavformat）</a></li>
<li><a href="https://www.jianshu.com/p/a91502c00fb0" target="_blank" rel="noopener">YUV颜色编码解析</a></li>
<li><a href="https://blog.csdn.net/dancing_night/article/details/80830920" target="_blank" rel="noopener">AVFrame存储YUV420P对齐分析</a></li>
<li><a href="https://blog.csdn.net/Evankaka/article/details/38176025" target="_blank" rel="noopener">NV12与YV12，YUV的主要格式</a></li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> H264 </tag>
            
            <tag> ffmpeg </tag>
            
            <tag> YUV </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Github仓库过大、文件过多下载方案]]></title>
      <url>https://longxuan.ren/2018/10/28/Github-DownLoad-Big-File/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>当项目的文件过大或者小文件数量过多的时候，直接从github下载经常因为网络问题中断，而且还没个恢复下载的选项只能重新开始相当坑了….<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h3 id="方案一-码云中转"><a href="#方案一-码云中转" class="headerlink" title="方案一 码云中转"></a>方案一 码云中转</h3><ol>
<li>先fork需要下载的仓库</li>
<li>在<a href="https://gitee.com" target="_blank" rel="noopener">码云</a>中绑定自己的<a href="https://github.com" target="_blank" rel="noopener">Github</a>账号</li>
<li><p>点击码云页面右上角的”+”==&gt;从Github导入项目，就可以同步fork的仓库了<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Github-DownLoad-Big-File_01.png" alt="导入项目"></p>
</li>
<li><p>点击进入项目==&gt;右侧的克隆/下载就能下载打包好的zip了</p>
</li>
</ol>
<p>PS: 码云的压缩率有点扯，整个仓库实际有1.3G，压缩的zip是718M…..</p>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><ol>
<li>搞个服务器VPS。推荐<a href="https://www.vultr.com" target="_blank" rel="noopener">Vultr</a>，按小时收费，不用了可以直接删除，删除后不扣钱，就算连开一个月也才5美刀（最近好像有3.5美刀/月的套餐了）</li>
<li>登录VPS终端 (可用xshell) ，在VPS的终端上：<code>git clone ....</code></li>
<li>打包整个项目 ：<code>zip -r name.zip ./*</code> (name=压缩文件名 ./* 压缩当前目录所有文件)</li>
<li>通过一个FTP工具 , 我用的<a href="https://filezilla-project.org" target="_blank" rel="noopener">FileZilla</a>, 连上你的服务器就可以下载对应的压缩包了</li>
</ol>
<p>PS: VPS上clone是真的快，30M/s，1.3G压缩完是150M左右，下载150M的文件就很快了</p>
</the>]]></content>
      
        <categories>
            
            <category> 环境搭建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
            <tag> VPS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python合并C++文件]]></title>
      <url>https://longxuan.ren/2018/09/27/PythonC-Merge/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>Python合并C++文件<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p> 项目中接口类文件数量太多，老大让把同一个模块的接口文件合并到一个文件中，手动太特么累了，上Python。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code># -*- coding: utf-8 -*-

import os,sys
info = os.getcwd()+&#39;/MerageFiles&#39;
fout_h = open(&#39;merge.h&#39;, &#39;w&#39;) # 合并.h到该文件
fout_cpp = open(&#39;merge.cpp&#39;, &#39;w&#39;) # 合并.cpp到该文件

def writeintofile_h(filepath, shotname):
    fin = open(filepath)
    # strinfo = fin.read()
    lines = fin.readlines()
    fout_h.write(&#39;\n/*********************************************************************************&#39;)
    fout_h.write(&#39;\n&#39; + shotname)
    fout_h.write(&#39;\n*&#39;)
    fout_h.write(&#39;\n*********************************************************************************/\n&#39;)
    # fout_h.write(strinfo)
    for l in lines:
        if &#39;MANAGER_H&#39; in l:
            continue
        elif &#39;#include&#39; in l:
            continue
        else:
            fout_h.write(l)
    fin.close()

def writeintofile_cpp(filepath, shotname):
    fin = open(filepath)
    # strinfo = fin.read()
    lines = fin.readlines()
    fout_cpp.write(&#39;\n/*********************************************************************************&#39;)
    fout_cpp.write(&#39;\n&#39; + shotname)
    fout_cpp.write(&#39;\n*&#39;)
    fout_cpp.write(&#39;\n*********************************************************************************/\n&#39;)
    # fout_cpp.write(strinfo)
    for l in lines:
        if &#39;MANAGER_H&#39; in l:
            continue
        elif &#39;#include&#39; in l:
            continue
        else:
            fout_cpp.write(l)
    fin.close()

for root, dirs, files in os.walk(info):
    if len(dirs)==0:
        for file in files:
            filepath = os.path.join(root,file)
            (shotname,extension) = os.path.splitext(file);
            if extension == &#39;.h&#39;:
                writeintofile_h(filepath, shotname)
            elif extension == &#39;.cpp&#39;:
                writeintofile_cpp(filepath, shotname)

fout_h.close()
fout_cpp.close()
</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li>新建个py文件拷贝代码，在py同目录下新建个<code>MerageFiles</code>文件夹用来放要合并的h、cpp文件。</li>
<li>运行py文件。</li>
</ol>
</the>]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Python </tag>
            
            <tag> Merge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Sublime通用插件记录]]></title>
      <url>https://longxuan.ren/2018/08/30/Sublime-Common-Plugin/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>偶尔重置系统，前端语言还经常换，就记几个常用的插件得了 (装多了快捷键冲突也懒得改)，剩下的根据需求再添加 <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h3 id="本体"><a href="#本体" class="headerlink" title="本体"></a>本体</h3><p>Sublime免费的，只是偶尔弹窗一下，相当良心了<br><a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">官网地址</a>，根据你的系统选择下载</p>
<h3 id="Package-Control"><a href="#Package-Control" class="headerlink" title="Package Control"></a>Package Control</h3><p>安装插件之前要先装下<a href="https://packagecontrol.io/installation" target="_blank" rel="noopener">Package Control</a></p>
<h4 id="自动安装"><a href="#自动安装" class="headerlink" title="自动安装"></a>自动安装</h4><p>使用Ctrl+`快捷键或者通过View-&gt;Show Console菜单打开终端，粘贴如下代码：</p>
<pre><code>import urllib.request,os,hashlib; h = &#39;6f4c264a24d933ce70df5dedcf1dcaee&#39; + &#39;ebe013ee18cced0ef93d5f746d80ef60&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &#39;http://packagecontrol.io/&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &#39;wb&#39; ).write(by)
</code></pre><p>如果终端安装报错的话，就改用手动安装</p>
<h4 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h4><ol>
<li>点击<code>Preferences &gt; Browse Packages</code>菜单</li>
<li>进入打开的目录的上层目录，然后再进入<code>Installed Packages/</code>目录</li>
<li>下载<a href="https://packagecontrol.io/Package%20Control.sublime-package" target="_blank" rel="noopener">Package Control.sublime-package</a>并复制到<code>Installed Packages/</code>目录</li>
<li>重启Sublime Text</li>
</ol>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>快捷键：<strong>Ctrl+Shift+P</strong>，调出菜单，输入<code>pci</code>，再输入你要安装的插件名字即可<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Sublime-Common-Plugin_01.png" alt="Package Control"></p>
<h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><table>
<thead>
<tr>
<th>插件名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Package Control</td>
<td>管理插件的插件</td>
</tr>
<tr>
<td>ChineseLocalization</td>
<td>中文菜单</td>
</tr>
<tr>
<td>Emmet</td>
<td>前端神器</td>
</tr>
<tr>
<td>DocBlocker</td>
<td>文档注释插件</td>
</tr>
<tr>
<td>SideBarEnhancements</td>
<td>侧边栏增强插件</td>
</tr>
<tr>
<td>BrackeHighlighter</td>
<td>匹配括号标签引号的插件</td>
</tr>
<tr>
<td>AdvancedNewFile</td>
<td>新建文件插件，快捷键Ctrl+Alt+N</td>
</tr>
<tr>
<td>Boxy Theme，A File Icon</td>
<td>主题图标等配置</td>
</tr>
</tbody>
</table>
<h3 id="个人配置"><a href="#个人配置" class="headerlink" title="个人配置"></a>个人配置</h3><p>Sublime的配置有default和user，前者是默认配置，一般个人修改都是将修改内容粘贴到对应的user配置中即可<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Sublime-Common-Plugin_02.png" alt="配置修改"></p>
<h4 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h4><pre><code>{

    &quot;ensure_newline_at_eof_on_save&quot;: true,

    &quot;font_size&quot;: 14,

    &quot;highlight_line&quot;: true,

    &quot;update_check&quot;:false

}
</code></pre><h4 id="添加Sublime到右键菜单"><a href="#添加Sublime到右键菜单" class="headerlink" title="添加Sublime到右键菜单"></a>添加Sublime到右键菜单</h4><p>打开regedit.exe注册表</p>
<p>添加路径：<code>HKEY_CLASSES_ROOT\*\shell\Sublime\Command</code>，添加命令：<code>&quot;D:\Sublime Text Build 3103\sublime_text.exe&quot; &quot;%1&quot;</code></p>
<h4 id="AdvancedNewFile配置"><a href="#AdvancedNewFile配置" class="headerlink" title="AdvancedNewFile配置"></a>AdvancedNewFile配置</h4><pre><code>{

 &quot;default_root&quot;: &quot;current&quot;

}
</code></pre><h4 id="SideBarEnhancements-配置"><a href="#SideBarEnhancements-配置" class="headerlink" title="SideBarEnhancements 配置"></a>SideBarEnhancements 配置</h4><h5 id="按键绑定-按F1、F2直接在浏览器中打开当前文件"><a href="#按键绑定-按F1、F2直接在浏览器中打开当前文件" class="headerlink" title="按键绑定(按F1、F2直接在浏览器中打开当前文件)"></a>按键绑定(按F1、F2直接在浏览器中打开当前文件)</h5><pre><code>//***********************************Win版*****************************

[

       /*{ &quot;keys&quot;: [&quot;alt+f12&quot;],

            &quot;command&quot;: &quot;side_bar_open_in_browser&quot;,

            &quot;args&quot;:{&quot;paths&quot;:[], &quot;type&quot;:&quot;production&quot;, &quot;browser&quot;:&quot;&quot;}

        },*/

          { &quot;keys&quot;: [&quot;ctrl+shift+c&quot;], &quot;command&quot;: &quot;copy_path&quot; },

          //chrome

    { &quot;keys&quot;: [&quot;f1&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;,

            &quot;args&quot;: {

                &quot;paths&quot;: [],

                &quot;application&quot;: &quot;C://Program Files (x86)//Google//Chrome//Application//chrome.exe&quot;,

                &quot;extensions&quot;:&quot;.*&quot;

            }

     },

    //firefox

    { &quot;keys&quot;: [&quot;f2&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;,

             &quot;args&quot;: {

                &quot;paths&quot;: [],

                &quot;application&quot;: &quot;D://Firefox//firefox.exe&quot;,

                &quot;extensions&quot;:&quot;.*&quot; //匹配任何文件类型

            }

    },

    //ie

     { &quot;keys&quot;: [&quot;f3&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;,

             &quot;args&quot;: {

                &quot;paths&quot;: [],

                &quot;application&quot;: &quot;C://Program Files//Internet Explorer//iexplore.exe&quot;,

                &quot;extensions&quot;:&quot;.*&quot;

            }

    },

    ]

//***********************************Mac版*****************************

[

       /*{ &quot;keys&quot;: [&quot;alt+f12&quot;],

            &quot;command&quot;: &quot;side_bar_open_in_browser&quot;,

            &quot;args&quot;:{&quot;paths&quot;:[], &quot;type&quot;:&quot;production&quot;, &quot;browser&quot;:&quot;&quot;}

        },*/

          { &quot;keys&quot;: [&quot;ctrl+shift+c&quot;], &quot;command&quot;: &quot;copy_path&quot; },

    //safari

    { &quot;keys&quot;: [&quot;f1&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;,

            &quot;args&quot;: {

                &quot;paths&quot;: [],

                &quot;application&quot;: &quot;safari.app&quot;,

                &quot;extensions&quot;:&quot;.*&quot;

            }

     },

    //chrome

    { &quot;keys&quot;: [&quot;f2&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;,

             &quot;args&quot;: {

                &quot;paths&quot;: [],

                &quot;application&quot;: &quot;Google Chrome.app&quot;,

                &quot;extensions&quot;:&quot;.*&quot; //匹配任何文件类型

            }

    },

    ]

//***********************************ubuntu版*****************************

[

  /*{ &quot;keys&quot;: [&quot;alt+f12&quot;],

  &quot;command&quot;: &quot;side_bar_open_in_browser&quot;,

  &quot;args&quot;:{&quot;paths&quot;:[], &quot;type&quot;:&quot;production&quot;, &quot;browser&quot;:&quot;&quot;}

  },*/

  { &quot;keys&quot;: [&quot;ctrl+shift+c&quot;], &quot;command&quot;: &quot;copy_path&quot; },

  //chrome

  { &quot;keys&quot;: [&quot;f1&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;,

  &quot;args&quot;: {

  &quot;paths&quot;: [],

  &quot;application&quot;: &quot;/usr/bin/google-chrome&quot;,

  &quot;extensions&quot;:&quot;.*&quot; //匹配任何文件类型

  }

  },

  ]
</code></pre><h3 id="插件使用"><a href="#插件使用" class="headerlink" title="插件使用"></a>插件使用</h3><h4 id="Emmet插件使用"><a href="#Emmet插件使用" class="headerlink" title="Emmet插件使用"></a>Emmet插件使用</h4><p>输入相应指令格式，按Tab或Ctrl+E实现代码补全</p>
<h4 id="DocBlocker插件使用"><a href="#DocBlocker插件使用" class="headerlink" title="DocBlocker插件使用"></a>DocBlocker插件使用</h4><ul>
<li><p>/* : 回车创建一个代码块注释</p>
</li>
<li><p>/*<em> : 回车创建一个代码块注释，如果在函数or变量前一行会自动添加函数、变量参数说明等，继续回车会自动加上</em>，再输入@后可以再根据需要添加(自动补全)需要的注释内容</p>
</li>
<li><p>变量前输入/**按Enter，补全变量多行注释</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Sublime-Common-Plugin_03.gif" alt="注释插件.gif"></p>
<p>如果输入了一个行注释，再按Ctrl+Enter，注释将变成酱紫</p>
<pre><code>// Foo bar baz&lt;&lt;Ctrl+Enter&gt;&gt;

-- becomes

/////////////////
// Foo bar baz //
/////////////////
</code></pre></the>]]></content>
      
        <categories>
            
            <category> 环境搭建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Sublime </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt-mingw工程、Qt-msvc工程、VS工程相互转换]]></title>
      <url>https://longxuan.ren/2018/08/22/Qt-mingw-msvc/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>Qt-mingw 工程、Qt-msvc 工程、VS 工程相互转换，包括子工程动态库、第三方库设置，windows 下就应该老老实实用 msvc，用 mingw 的话 win8 以上的新特性都没得玩<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="Qt-mingw-工程转换为-Qt-msvc-工程"><a href="#Qt-mingw-工程转换为-Qt-msvc-工程" class="headerlink" title="Qt-mingw 工程转换为 Qt-msvc 工程"></a>Qt-mingw 工程转换为 Qt-msvc 工程</h2><blockquote>
<p>VS 不太会用，先在 QtCreator 调好了再扔 VS…<em>(:з)∠)</em></p>
</blockquote>
<h3 id="编译错误处理"><a href="#编译错误处理" class="headerlink" title="编译错误处理"></a>编译错误处理</h3><ul>
<li>第三方库更换，将.a 库都换成.lib 库</li>
<li>动态库没有导出 lib 文件，在 mingw 不在导出类上写 Q_DECL_EXPORT 也能导出相关的.a，VS 不写的话不会导出.lib</li>
<li>用到 windows.h 或者网络相关就会有一个蛋疼的 windows.h、winsock.h、winsock2.h 各种重定义的问题，在使用 windows.h 之前：</li>
</ul>
<pre><code>#define WIN32_LEAN_AND_MEAN
#include &lt;windows.h&gt;
</code></pre><ul>
<li>其他各种函数符号未解析什么的，把函数名用必应搜一下，就会跳到 windows API 文档，在 pro 中加上相关 lib</li>
</ul>
<pre><code>LIBS += \
    -ldwmapi -lOle32 -lwinmm -lksuser -luuid -lUser32
</code></pre><ul>
<li>Qt5mingw 中的 connect 函数接收者为 this 时，可以不写槽函数的作用域，VS 中不写会报错</li>
</ul>
<h3 id="编译警告处理"><a href="#编译警告处理" class="headerlink" title="编译警告处理"></a>编译警告处理</h3><ul>
<li>warning: LNK4098: 默认库“LIBCMT”与其他库的使用冲突；请使用 /NODEFAULTLIB:library。<br>修改<code>C:\Qt\Qt5.10.1\5.10.1\msvc2015\mkspecs\common</code>下的<strong>msvc-desktop.conf</strong>：</li>
</ul>
<pre><code>//修改前
QMAKE_LFLAGS_DEBUG      = /DEBUG

//修改后
QMAKE_LFLAGS_DEBUG      = /DEBUG /NODEFAULTLIB:libcmt.lib /NODEFAULTLIB:msvcrt.lib /NODEFAULTLIB:libcmtd.lib
</code></pre><ul>
<li>warning: 未引用的形参。<br>修改<code>C:\Qt\Qt5.10.1\5.10.1\msvc2015\mkspecs\common</code>下的<strong>msvc-desktop.conf</strong>：</li>
</ul>
<pre><code>//修改前
QMAKE_CXXFLAGS_WARN_ON  = $$QMAKE_CFLAGS_WARN_ON -w34100 -w34189 -w44996

//修改后
QMAKE_CXXFLAGS_WARN_ON  = $$QMAKE_CFLAGS_WARN_ON -w34189 -w44996
</code></pre><ul>
<li>warning: C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失<br>将对应的文件字符编码修改为 utf-8 BOM</li>
</ul>
<h2 id="Qt-工程转换为-VS-工程"><a href="#Qt-工程转换为-VS-工程" class="headerlink" title="Qt 工程转换为 VS 工程"></a>Qt 工程转换为 VS 工程</h2><h3 id="通过扩展"><a href="#通过扩展" class="headerlink" title="通过扩展"></a>通过扩展</h3><ol>
<li>安装 Qt Visual Studio Tools 拓展，配置好 Qt options 中的 MSVC 路径</li>
<li>点击工具栏 Qt VS Tools，Open Qt Project File，选择工程的.pro 文件后就能自动生成 sln 了</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-mingw-msvc-2020-04-16-10-26-03.png" alt="Qt-mingw-msvc-2020-04-16-10-26-03"></p>
<h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>先搞个 bat 把指定编译环境加到环境变量，比如下面就是 Qt5.12.5 + msvc2017 构建套件 + vs2019 的环境：</p>
<pre><code class="bat">SET DEPLOY_QT_VERSION=5.12.5
SET MSVC_VERSION=2019
SET DEPLOY_QT_COMPILE=msvc2017
SET PATH=%PATH%;C:\Qt\Qt%DEPLOY_QT_VERSION%\%DEPLOY_QT_VERSION%\%DEPLOY_QT_COMPILE%\bin;
SET PATH=%PATH%;C:\Qt\Qt%DEPLOY_QT_VERSION%\Tools\QtCreator\bin;
SET PATH=%PATH%;C:\Program Files (x86)\Microsoft Visual Studio\%MSVC_VERSION%\Community\VC\Auxiliary\Build;

call vcvarsall.bat amd64_x86
</code></pre>
<p>在最外层工程目录运行：<code>qmake -tp vc -r</code>。会递归生成子目录的 vcxproj，并生成总工程的 sln。</p>
<h2 id="VS-工程转换为-Qt-工程"><a href="#VS-工程转换为-Qt-工程" class="headerlink" title="VS 工程转换为 Qt 工程"></a>VS 工程转换为 Qt 工程</h2><ol>
<li><p>VS 装上 Qt VS Tool，点击插件的 Create basic .pro file</p>
</li>
<li><p>修改生成的.pro 文件：</p>
</li>
</ol>
<pre><code>TEMPLATE = lib
Release:DESTDIR = xxx/Release
Debug:DESTDIR = xxx/Debug
INCLUDEPATH += ... //添加第三方头文件引用路径
LIBS += ....//添加第三发库文件
</code></pre><ol start="3">
<li><p>双击改好的.pro 文件，QT Creator 打开此工程，选中合适的 Kit，就可以 build 了。看你之前相关库有没有限制，我之前是 32 程序就选的 QT 5.10.1 的 msvc2015。</p>
</li>
<li><p>要运行 VS 工程的时候记得把 Qt-msvc 的 bin 目录加到环境变量 Path 里<code>C:\Qt\Qt5.10.1\5.10.1\msvc2015\bin</code>。</p>
</li>
<li><p>编译 64 位的程序可能会有个坑，虽然我没碰到但是还是记录下.<br>在系统环境变量%PATH%里，对于 Visual Studio 的编译器 cl.exe 和链接器 link.exe, 要选对路径。比如，对于 64 位的机器，路径 <code>C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\bin\amd64</code> 应该被加到%PATH%中，而不是<code>C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\bin</code>。</p>
</li>
</ol>
<h2 id="VS2013-工程转换为-VS2015-工程"><a href="#VS2013-工程转换为-VS2015-工程" class="headerlink" title="VS2013 工程转换为 VS2015 工程"></a>VS2013 工程转换为 VS2015 工程</h2><p>这个最好是重新添加文件搞一个，直接点 VS 的那个升级会找不到 Qt 的相关头文件，会报一排错……</p>
</the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mingw </tag>
            
            <tag> msvc </tag>
            
            <tag> pro </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ffmpeg音频采集、编码]]></title>
      <url>https://longxuan.ren/2018/08/17/ffmpeg-Audio-Capture-Encoder/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>不同于视频采集一帧编码一帧，音频采集和编码之间稍微复杂一些，记录下相关内容<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h3 id="音频采集"><a href="#音频采集" class="headerlink" title="音频采集"></a>音频采集</h3><p>在windows上获取音频的方法，主要尝试了2种，效果差不多。一种是通过ffmpeg的dshow获取，另一种是直接从windows的Core Audio API 来获取。通过这两种方式采集到的音频的采样率都是当前声音播放的扬声器的采样率。</p>
<h4 id="ffmpeg-dshow-采集"><a href="#ffmpeg-dshow-采集" class="headerlink" title="ffmpeg dshow 采集"></a>ffmpeg dshow 采集</h4><p>使用dshow抓屏需要安装抓屏软件：<a href="https://sourceforge.net/projects/screencapturer/" target="_blank" rel="noopener">screen-capture-recorder</a>。</p>
<h5 id="在命令行用dshow"><a href="#在命令行用dshow" class="headerlink" title="在命令行用dshow:"></a>在命令行用dshow:</h5><pre><code>ffmpeg -f dshow -i video=&quot;screen-capture-recorder&quot; -f dshow -i audio=&quot;virtual-audio-capturer&quot; -t 30 -r 20 -vcodec libx264 output.mp4
</code></pre><h5 id="在代码中用dshow"><a href="#在代码中用dshow" class="headerlink" title="在代码中用dshow:"></a>在代码中用dshow:</h5><pre><code>//视频采集
AVInputFormat *ifmt=av_find_input_format(&quot;dshow&quot;);
 if(avformat_open_input(&amp;pFormatCtx,&quot;video=screen-capture-recorder&quot;,ifmt,NULL)!=0){
  qDebug() &lt;&lt; &quot;Couldn&#39;t open input stream.&quot;;
  return -1;
 }

//音频采集
AVInputFormat *ifmt=av_find_input_format(&quot;dshow&quot;);
 if(avformat_open_input(&amp;pFormatCtx,audio=&quot;virtual-audio-capturer&quot;,ifmt,NULL)!=0){
  qDebug() &lt;&lt; &quot;Couldn&#39;t open input stream.&quot;;
  return -1;
 }
</code></pre><p>具体采集可以参考<a href="https://blog.csdn.net/dancing_night/article/details/46698853" target="_blank" rel="noopener">ffmpeg实现录屏+录音</a>，懒得贴代码了。</p>
<h4 id="Core-Audio-音频采集"><a href="#Core-Audio-音频采集" class="headerlink" title="Core Audio 音频采集"></a>Core Audio 音频采集</h4><p>Core Audio不支持XP，只可以在Vista以上（包括Vista）的操作系统中才能使用，主要用来取代Wave系列API函数和DirectSound。</p>
<p>#####<br>具体采集可以参考<a href="https://blog.csdn.net/su_vast/article/details/78317584" target="_blank" rel="noopener">windows音频声卡采集</a>。主要说下采集到的buffer中framesAvailable就是采集一次包含的采样点多少了，同AVFrame中的nb_samples：</p>
<pre><code>hr = m_CACaptureClient-&gt;GetBuffer(&amp;pData, &amp;framesAvailable, &amp;flags, NULL, NULL);
        if (SUCCEEDED(hr))
        {
            if (framesAvailable!=0)
            {
                if (flags &amp; AUDCLNT_BUFFERFLAGS_SILENT)
                {
                    pData = NULL;
                }
                else
                {
                    //Copy data from the audio engine buffer to the output buffer.
                    int nDataLen = framesAvailable*m_CAFrameSize;

                    AVFrame *frame;
                    frame = av_frame_alloc();
                    frame-&gt;format = m_SrcParams.sample_fmt;
                    frame-&gt;nb_samples = framesAvailable;
                    frame-&gt;channels = m_SrcParams.channels;
                    frame-&gt;channel_layout = av_get_default_channel_layout(m_SrcParams.channels);
                    frame-&gt;sample_rate = m_SrcParams.sample_rate;

                    av_frame_get_buffer(frame, 1);
                    memcpy(frame-&gt;data[0], pData, nDataLen);

                    EncoderData *node = new EncoderData();
                    node-&gt;type = DATA_TYPE_AUDIO;
                    node-&gt;frame = frame;

//                    fwrite(pData, 1, nDataLen, pcmFp);

                    async_queue_push(m_AvailPtr, (void *)node);

                    CalcCapRate();
                }
            }
        }
</code></pre><h3 id="音频格式中的Plane"><a href="#音频格式中的Plane" class="headerlink" title="音频格式中的Plane"></a>音频格式中的Plane</h3><p>默认用ffmpeg采集到的格式是AV_SAMPLE_FMT_S16，但是AAC编码要的又是AV_SAMPLE_FMT_FLTP，中间需要通过swr_convert来转换。</p>
<pre><code>enum AVSampleFormat {
    AV_SAMPLE_FMT_NONE = -1,
    AV_SAMPLE_FMT_U8,          ///&lt; unsigned 8 bits
    AV_SAMPLE_FMT_S16,         ///&lt; signed 16 bits
    AV_SAMPLE_FMT_S32,         ///&lt; signed 32 bits
    AV_SAMPLE_FMT_FLT,         ///&lt; float
    AV_SAMPLE_FMT_DBL,         ///&lt; double

    AV_SAMPLE_FMT_U8P,         ///&lt; unsigned 8 bits, planar
    AV_SAMPLE_FMT_S16P,        ///&lt; signed 16 bits, planar
    AV_SAMPLE_FMT_S32P,        ///&lt; signed 32 bits, planar
    AV_SAMPLE_FMT_FLTP,        ///&lt; float, planar
    AV_SAMPLE_FMT_DBLP,        ///&lt; double, planar
    AV_SAMPLE_FMT_S64,         ///&lt; signed 64 bits
    AV_SAMPLE_FMT_S64P,        ///&lt; signed 64 bits, planar

    AV_SAMPLE_FMT_NB           ///&lt; Number of sample formats. DO NOT USE if linking dynamically
};
</code></pre><ol>
<li>无论是不是带P的数据总量是相同的.</li>
<li>带P的格式是左右声道分开存储的，data[0]：LLLLLLLLLLLLL….; data[1]: RRRRRRRRR…</li>
<li>不带P的格式是交替存储的，只在data[0] 有数据，data[0] :LRLRLRLRLRLRLRLRLRLR….</li>
</ol>
<h3 id="AAC编码"><a href="#AAC编码" class="headerlink" title="AAC编码"></a>AAC编码</h3><h4 id="AAC帧时长"><a href="#AAC帧时长" class="headerlink" title="AAC帧时长"></a>AAC帧时长</h4><p>一个AAC原始帧包含某段时间内1024个采样点相关数据（mp3则包含1152个采样点）。音频帧的播放时间 = 一个AAC帧对应的采样样本的个数 / 采样频率(单位为s)。</p>
<ol>
<li><p>采样率(sample rate)为 44100Hz，表示每秒 44100个采样点, 根据公式，当前一帧的播放时间 = 1024 * 1000000/44100= 22.32ms(单位为ms)</p>
</li>
<li><p>采样率为48000Hz，根据公式，当前一帧的播放时间 = 1024 * 1000000/48000= 21.32ms(单位为ms)</p>
</li>
</ol>
<h4 id="AAC帧数据大小"><a href="#AAC帧数据大小" class="headerlink" title="AAC帧数据大小"></a>AAC帧数据大小</h4><p>AAC帧一帧包含1024个采样点，数据量大小 = 一个AAC帧对应的采样样本的个数 <em> 通道数</em> 数据位数/8。采集数据为双通道，16位数据时，根据公式， 一帧数据量大小 = 1024<em>2 </em>16/8 = 4096。</p>
<p><strong>在采集采样率和编码采样率相同的情况下（就是不需要重采样），通道数，数据位数一般不会改变，那么采集的数据大小和编码的数据大小是一样的。也就是说，当采集了4096个字节的数据后，再送去给编码器编码一帧AAC帧，不同的采样率只是会改变每秒钟的AAC帧的数量。</strong></p>
<ol>
<li><p>采样率(sample rate)为 44100Hz，1秒钟有：44100 / 1024 = 43.066帧</p>
</li>
<li><p>采样率为48000Hz，1秒钟有：48000 / 1024 = 48000 / 1024 = 46.875帧</p>
</li>
</ol>
<p>所以，如果自己弄一个音频缓冲buffer，就需要每满4096字节就编码一帧，更简单的方式是用ffmpeg提供的AVAudioFifo，每次读取写入都是根据采样点的个数来的：</p>
<pre><code>    av_audio_fifo_write(m_pAudioFifo, (void **)frame-&gt;data, frame-&gt;nb_samples);

    av_frame_free(&amp;frame);
    RELEASE_CLASS(node);

    while(av_audio_fifo_size(m_pAudioFifo) &gt;= m_inputSamples)
    {
        av_audio_fifo_read(m_pAudioFifo, (void **)m_pInputData, m_inputSamples);
        ...
    }
</code></pre><h4 id="AAC的ADTS"><a href="#AAC的ADTS" class="headerlink" title="AAC的ADTS"></a>AAC的ADTS</h4><p>ADTS 头中相对有用的信息 采样率、声道数、帧长度。想想也是，我要是解码器的话，你给我一堆得AAC音频ES流我也解不出来。每一个带ADTS头信息的AAC流会清晰的告送解码器他需要的这些信息。</p>
<p>这里有个坑爹的情况，ffmpeg的2.5版本，编码出的AAC帧好像是带有ADTS的，但是最新的ffmpeg4.0没有ADTS，直接把编码的AAC帧扔给播放器是没有声音的，需要你自己加…想要了解ADTS相关信息的可以<a href="https://blog.csdn.net/andyhuabing/article/details/40983423" target="_blank" rel="noopener">看看这里</a>，我就贴下从gayhub上翻到的添加ADTS的相关代码：</p>
<pre><code>#define ADTS_HEADER_SIZE 7

const int avpriv_mpeg4audio_sample_rates[16] = {
    96000, 88200, 64000, 48000, 44100, 32000,
    24000, 22050, 16000, 12000, 11025, 8000, 7350
};

const uint8_t ff_mpeg4audio_channels[8] = {
    0, 1, 2, 3, 4, 5, 6, 8
};

static int GetSampleIndex(int sample_rate)
{
    for (int i = 0; i &lt; 16; i++)
    {
        if (sample_rate == avpriv_mpeg4audio_sample_rates[i])
        {
            return i;
        }
    }
    return -1;
}

void AudioEncoder::WriteADTSHeader(int Size, int sample_rate,int channels)
{
    if (ADTSHeader == nullptr)
    {
        ADTSHeader = (char*)av_malloc(ADTS_HEADER_SIZE);
    }
    memset(ADTSHeader,0, ADTS_HEADER_SIZE);

    int length = ADTS_HEADER_SIZE + Size;
    length &amp;= 0x1FFF;

    int sample_index = GetSampleIndex(sample_rate);
    int channel = 0;

    if (channels &lt; (int)FF_ARRAY_ELEMS(ff_mpeg4audio_channels))
        channel = ff_mpeg4audio_channels[channels];

    ADTSHeader[0] = (char)0xff;
    ADTSHeader[1] = (char)0xf1;
    ADTSHeader[2] = (char)(0x40 | (sample_index &lt;&lt; 2) | (channel &gt;&gt; 2));
    ADTSHeader[3] = (char)((channel &amp; 0x3) &lt;&lt; 6 | (length &gt;&gt; 11));
    ADTSHeader[4] = (char)(length &gt;&gt; 3) &amp; 0xff;
    ADTSHeader[5] = (char)(((length &amp; 0x7) &lt;&lt; 5) &amp; 0xff) | 0x1f;
    ADTSHeader[6] = (char)0xfc;
}

int AudioEncoder::ADTS(AVPacket *src, AVPacket **des)
{
    if (src == nullptr) {
        return -1;
    }
    if (des == nullptr) {
        return -1;
    }

    AVPacket *adtsPacket = av_packet_alloc();
    av_init_packet(adtsPacket);
    av_new_packet(adtsPacket, src-&gt;size + ADTS_HEADER_SIZE);
    WriteADTSHeader(src-&gt;size, m_pCoderCtx-&gt;sample_rate, m_pCoderCtx-&gt;channels);
    memcpy(adtsPacket-&gt;data, ADTSHeader, ADTS_HEADER_SIZE);
    memcpy(adtsPacket-&gt;data + ADTS_HEADER_SIZE, src-&gt;data, src-&gt;size);

    adtsPacket-&gt;pts = src-&gt;pts;
    adtsPacket-&gt;dts = src-&gt;dts;
    adtsPacket-&gt;duration = src-&gt;duration;
    adtsPacket-&gt;flags = src-&gt;flags;
    adtsPacket-&gt;stream_index = src-&gt;stream_index;
    adtsPacket-&gt;pos = src-&gt;pos;

    if (*des == src)
    {
        av_packet_unref(src);
        av_packet_move_ref(*des, adtsPacket);
    }
    else if (*des != nullptr)
    {
        av_packet_move_ref(*des, adtsPacket);
    }
    else
    {
        *des = adtsPacket;
    }

    return 0;
}
</code></pre><p>使用方法就是在初始化的时候调用下AudioEncoder::WriteADTSHeader；编码出来一个AAC帧的packet就调用下AudioEncoder::ADTS(packet, *packet);  播放器就可以愉快的播放啦~~</p>
<h3 id="重采样"><a href="#重采样" class="headerlink" title="重采样"></a>重采样</h3><p>先说下我碰到的问题，我的需求是将声卡采集后传输到另一个设备上播放，用swr_convert重采样的时候碰到个坑，我设置声卡的采样率为44100Hz的时候，如果编码采样率设置为48000Hz，每次要是扔给编码器4096的数据的话，编码出来的AAC帧拿去播放时间会变长，实时采集再播放的时候声音就会越来越慢，但是我也没有什么buffer存着数据，后来发现：</p>
<pre><code>/** Convert audio.
 *
 * in and in_count can be set to 0 to flush the last few samples out at the
 * end.
 *
 * If more input is provided than output space, then the input will be buffered.
 * You can avoid this buffering by using swr_get_out_samples() to retrieve an
 * upper bound on the required number of output samples for the given number of
 * input samples. Conversion will run directly without copying whenever possible.
 *
 * @param s         allocated Swr context, with parameters set
 * @param out       output buffers, only the first one need be set in case of packed audio
 * @param out_count amount of space available for output in samples per channel
 * @param in        input buffers, only the first one need to be set in case of packed audio
 * @param in_count  number of input samples available in one channel
 *
 * @return number of samples output per channel, negative value on error
 */
int swr_convert(struct SwrContext *s, uint8_t **out, int out_count,
                                const uint8_t **in , int in_count);
</code></pre><p>注释说到，如果提供的输入多于输出空间，则输入将被缓冲…应该是缓冲在这里了Orz…打印了下swrcontext的buffer：</p>
<pre><code>int fifo_size = swr_get_out_samples(m_pSwrCtx, 0);
qDebug() &lt;&lt; &quot;swr_get_out_samples&quot;  &lt;&lt; fifo_size;
</code></pre><p>确实在涨….emmm</p>
<p>看了下其他博客的<a href="https://blog.csdn.net/dancing_night/article/details/45642107" target="_blank" rel="noopener">重采样</a>，感觉是解码了AAC帧再重新采样编码，我的情况是想采集了(采集的帧只有448个采样点) 直接重采样编码，不想编码完了再重采样一遍。</p>
<p>回到上面关于数据大小的讨论，在采集44100-&gt;编码44100、采集48000-&gt;编码48000的情况下，采集和编码的数据量是相同的，在用swr_convert的时候，in_count、out_count相等就行：</p>
<pre><code>swr_convert(m_pSwrCtx, m_pDesFrame-&gt;data, m_pCoderCtx-&gt;frame_size, (const uint8_t**)m_pConvertData, m_pCoderCtx-&gt;frame_size);
</code></pre><p>那么，在44100-&gt;48000的情况下，out_count由于AAC帧需要，1024不变，设in_count为x，得到个等式：</p>
<pre><code>44100/x = 48000 /1024  =&gt;  x = 44100*1024/48000 =&gt;  x = 940.8
</code></pre><p>差不多就取个941，由于不是整数，out_count也要设置比1024大点：</p>
<pre><code>swr_convert(m_pSwrCtx, m_pDesFrame-&gt;data, 1040, (const uint8_t**)m_pInputData, 941);
</code></pre><p>swr的buffer差不多保持在38左右，不是很明白为啥是这个值，但是需求基本达到了.</p>
<p>不过反过来就不行了，48000-&gt;44100要是把in_count直接改成1114的话，程序会崩溃<em>(:з)∠)</em></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="https://blog.csdn.net/su_vast/article/details/78317584" target="_blank" rel="noopener">windows音频声卡采集</a></li>
<li><a href="https://blog.csdn.net/venice0708/article/details/80783870" target="_blank" rel="noopener">新版ffmpeg PCM编码到AAC</a></li>
<li><a href="https://blog.csdn.net/leixiaohua1020/article/details/39706721" target="_blank" rel="noopener">最简单的基于FFmpeg的AVDevice例子（屏幕录制)</a></li>
<li><a href="https://blog.csdn.net/dancing_night/article/details/46698853" target="_blank" rel="noopener">ffmpeg实现录屏+录音</a></li>
<li><a href="https://blog.csdn.net/andyhuabing/article/details/40983423" target="_blank" rel="noopener">AAC ADTS格式分析</a></li>
<li><a href="https://blog.csdn.net/zhuweigangzwg/article/details/51499123" target="_blank" rel="noopener">ffmpeg关于音频的总结(一)</a></li>
<li><a href="https://blog.csdn.net/dancing_night/article/details/45642107" target="_blank" rel="noopener">ffmpeg音频转码，采用swr_convert重取样</a></li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ffmpeg </tag>
            
            <tag> Audio </tag>
            
            <tag> Capture </tag>
            
            <tag> AAC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[超详细Windows + Python + PyQt5 + Pycharm 环境搭建]]></title>
      <url>https://longxuan.ren/2018/08/06/Windows-PyQt5-Pycharm/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>超详细Windows + Python + PyQt5 + Pycharm 环境搭建，走过路过不要错过~~ <a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<blockquote>
<p>之前一直用Qt写C++，最近想玩玩Python，参考了好几个教程，每个教程都有点坑。于是自己整理了下可能会碰到的问题，方便其他想用PyQt5 (GPL) 的小伙伴吧。如果想用PySide2 (LGPL) 过程也基本类似，就把PyQt5的相关内容替换下就行。</p>
</blockquote>
<h3 id="Python安装"><a href="#Python安装" class="headerlink" title="Python安装"></a>Python安装</h3><h4 id="Python主程序安装"><a href="#Python主程序安装" class="headerlink" title="Python主程序安装"></a>Python主程序安装</h4><h5 id="单个版本Python"><a href="#单个版本Python" class="headerlink" title="单个版本Python"></a>单个版本Python</h5><p><a href="https://www.python.org/downloads/" target="_blank" rel="noopener">Python官网下载地址</a>，目前最新的是Python3.7，我用的是Python3.6，没用最新的主要是担心PyQt那边没更新</p>
<h5 id="多个版本Python"><a href="#多个版本Python" class="headerlink" title="多个版本Python"></a>多个版本Python</h5><p>有的小伙伴可能需要安装多个版本的Python，在Linux和Mac上可能需要啥管理工具啥的，具体可以看看<a href="https://www.jianshu.com/p/60f361822a7e" target="_blank" rel="noopener">Python版本管理</a>。<strong>如果你是Windows，直接安装就可以了，具体要用哪个版本的Python只要加上对应的环境变量即可。</strong><br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Windows-PyQt5-Pycharm_01.png" alt="添加环境变量"></p>
<p>也不用装什么版本管理工具，就是这么简单。还有也可以<a href="https://www.zhihu.com/question/21653286" target="_blank" rel="noopener">通过命令行切换Python版本</a>，但是敲命令行有时候老是忘记，不折腾自己了，可以了解下。</p>
<h4 id="给Python添加镜像源"><a href="#给Python添加镜像源" class="headerlink" title="给Python添加镜像源"></a>给Python添加镜像源</h4><p>不管是用npm还是pip等包管理工具的时候，国内最好都是换下相关的镜像源，要不然你就只能龟速下载了…</p>
<h5 id="可用镜像源"><a href="#可用镜像源" class="headerlink" title="可用镜像源"></a>可用镜像源</h5><pre><code>清华：https://pypi.tuna.tsinghua.edu.cn/simple
阿里云：http://mirrors.aliyun.com/pypi/simple/
中国科技大学：https://pypi.mirrors.ustc.edu.cn/simple/
华中理工大学：http://pypi.hustunique.com/
山东理工大学：http://pypi.sdutlinux.org/
豆瓣：http://pypi.douban.com/simple/
</code></pre><h5 id="添加pip-ini"><a href="#添加pip-ini" class="headerlink" title="添加pip.ini"></a>添加pip.ini</h5><p>在<code>C:\Users\Administrator</code>下新建一个<code>pip</code>文件夹，在文件夹中新建一个pip.ini文件：<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Windows-PyQt5-Pycharm_02.png" alt="创建pip文件夹"></p>
<p>在pip.ini中添加以下内容，之后再用pip下载包就可以体验飞速下载了：<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Windows-PyQt5-Pycharm_03.png" alt="添加镜像源"></p>
<h3 id="PyQt5安装"><a href="#PyQt5安装" class="headerlink" title="PyQt5安装"></a>PyQt5安装</h3><p>环境变量加上了Python对应的文件夹后，就可以通过pip安装PyQt5。默认安装最新的版本，在命令行输入：</p>
<pre><code>pip install PyQt5
</code></pre><p>如果需要安装指定版本的QyQt5，改成输入：</p>
<pre><code>pip install PyQt5==5.10.1
</code></pre><h3 id="界面工具安装"><a href="#界面工具安装" class="headerlink" title="界面工具安装"></a>界面工具安装</h3><p>PyQt5只用到了Qt的designer.exe，这是用来设计界面的一个工具，生成的界面文件是.ui的，PyQt5的作用就是把这个ui文件转换成py文件。</p>
<h4 id="pyqt5-tools"><a href="#pyqt5-tools" class="headerlink" title="pyqt5-tools"></a>pyqt5-tools</h4><p>PyQt5有对应的<a href="https://pypi.org/project/pyqt5-tools/" target="_blank" rel="noopener">这个工具</a>，包含designer.exe。但是官方只更新到了Qt5.9的，而且我也装有Qt，就不考虑此方案了。</p>
<h4 id="Qt安装"><a href="#Qt安装" class="headerlink" title="Qt安装"></a>Qt安装</h4><p>安装哪个版本基本上都没啥差别，只要有designer.exe，可以生成ui文件就行。附上<a href="https://download.qt.io/" target="_blank" rel="noopener">Qt下载地址</a>。</p>
<h4 id="Pycharm安装"><a href="#Pycharm安装" class="headerlink" title="Pycharm安装"></a>Pycharm安装</h4><p>这个公司有很多IDE都挺好用的，而且还有一个非常好的福利，<strong>对于有教育邮箱的用户，可以免费使用一年</strong>。附上<a href="https://www.imsxm.com/2018/02/jetbrain-education-license.html" target="_blank" rel="noopener">通过教育邮箱激活Pycharm</a>。</p>
<h5 id="Pycharm配置"><a href="#Pycharm配置" class="headerlink" title="Pycharm配置"></a>Pycharm配置</h5><p>打开Pycharm，Files-&gt;Settings-&gt;External Tools，添加两个tools，Qt Designer、PyUIC：<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Windows-PyQt5-Pycharm_04.png" alt="添加Tools"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Windows-PyQt5-Pycharm_05.png" alt="添加Qt Designer"></p>
<ol>
<li><code>Programs:</code>的地方找到你自己的designer.exe所在的位置</li>
<li><code>Working directory:</code>的地方填上<code>$ProjectFileDir$</code> (填<code>$FileDir$</code>好像也行)。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Windows-PyQt5-Pycharm_06.png" alt="添加PyUIC"></p>
<ol>
<li><code>Programs:</code>的地方找到你自己的python.exe所在的位置</li>
<li><code>Arguments:</code>的地方填上<code>-m PyQt5.uic.pyuic  $FileName$ -o $FileNameWithoutExtension$.py</code></li>
<li><code>Working directory:</code>的地方填上<code>$FileDir$</code></li>
</ol>
<h4 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h4><p>环境搭建好了，来实际编写一个项目试试</p>
<h5 id="新建Python项目"><a href="#新建Python项目" class="headerlink" title="新建Python项目"></a>新建Python项目</h5><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Windows-PyQt5-Pycharm_07.png" alt="新建Python项目"></p>
<p>这里注意，上面的New environment using是在项目下添加一个Python的环境，如果要使用PyQt5的话要将底下两个勾选框勾上；也可以使用自己本地的Python，就选择底下的Existing interpreter，指定Python.exe位置即可。</p>
<h5 id="创建ui文件"><a href="#创建ui文件" class="headerlink" title="创建ui文件"></a>创建ui文件</h5><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Windows-PyQt5-Pycharm_08.png" alt="创建ui文件"></p>
<p>按照图示选择Qt Designer就会启动Qt的designer.exe了，你也可以直接到Qt的目录下运行程序。然后就是愉快的拖控件时间：<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Windows-PyQt5-Pycharm_09.png" alt="ui文件生成"></p>
<p>界面设计完毕，将ui文件保存到Python工程所在的目录下即可，PyCharm中的项目可以看到对应的ui文件。</p>
<h5 id="ui文件生成py文件"><a href="#ui文件生成py文件" class="headerlink" title="ui文件生成py文件"></a>ui文件生成py文件</h5><p>在ui文件上点击右键，External Tools-&gt;PyUIC，就能生成对应的py文件了：<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Windows-PyQt5-Pycharm_10.png" alt="生成py文件"></p>
<h5 id="添加main-py"><a href="#添加main-py" class="headerlink" title="添加main.py"></a>添加main.py</h5><p>给程序添加一个入口，在工程目录下新建一个main.py，在其中添加代码：</p>
<pre><code>import sys
import HelloWorld
from PyQt5.QtWidgets import QApplication, QMainWindow
if __name__ == &#39;__main__&#39;:
    app = QApplication(sys.argv)
    MainWindow = QMainWindow()
    ui = HelloWorld.Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Windows-PyQt5-Pycharm_11.png" alt="main.py"></p>
<h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><p>在main.py中，点击右键-&gt;Run main，即可运行程序。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Windows-PyQt5-Pycharm_12.png" alt="运行"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Windows-PyQt5-Pycharm_13.png" alt="运行界面"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>搭建PyQt5的相关环境其实也不复杂，这其中有很多可以根据自己的环境修改的地方，比如：</p>
<ul>
<li>你需要用PySide2，就换掉PyQt5的内容</li>
<li>你有Qt的话，就不用再额外安装designer.exe</li>
<li>IDE也不一定用PyCharm，你用<a href="https://blog.csdn.net/m0_37606112/article/details/78675610" target="_blank" rel="noopener">VS2017写Python</a>也行</li>
</ul>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul>
<li><a href="https://www.jianshu.com/p/344bdf61e69e" target="_blank" rel="noopener">Python3.6 PyQt5 pycharm 环境搭建</a></li>
<li><a href="https://www.jianshu.com/p/094928ac0b73" target="_blank" rel="noopener">Python3 PyQt5 pycharm 环境搭建</a></li>
<li><a href="https://www.qcgzxw.cn/2789.html" target="_blank" rel="noopener">PIP安装模块下载慢或者无法下载</a></li>
<li><a href="https://www.jianshu.com/p/042324342bf4" target="_blank" rel="noopener">PyCharm安装及使用</a></li>
<li><a href="https://www.imsxm.com/2018/02/jetbrain-education-license.html" target="_blank" rel="noopener">申请JetBrains学生免费注册码</a></li>
<li><a href="https://blog.csdn.net/leemboy/article/details/80490675" target="_blank" rel="noopener">PyCharm 无法识别PyQt5的两种解决办法</a></li>
<li><a href="https://blog.csdn.net/m0_37606112/article/details/78675610" target="_blank" rel="noopener">宇宙最强VisualStudio2017配置pyQt5用于python3.6的UI界面工具</a></li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> Python </tag>
            
            <tag> Windows </tag>
            
            <tag> PyQt5 </tag>
            
            <tag> Pycharm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt-Mingw-ffmpeg]]></title>
      <url>https://longxuan.ren/2018/07/27/Qt-Mingw-ffmpeg/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>介绍下在Qt下直接调用官方下载的动态库以及自己编译成静态库等，另外关于ffmpeg怎么用算LGPL谁知道的话求告知<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>


<h3 id="直接使用动态库"><a href="#直接使用动态库" class="headerlink" title="直接使用动态库"></a>直接使用动态库</h3><h4 id="官网下载"><a href="#官网下载" class="headerlink" title="官网下载"></a>官网下载</h4><p>如果没有特殊要求，可以直接在ffmpeg<a href="https://ffmpeg.zeranoe.com/builds/" target="_blank" rel="noopener">官网下载</a>编译好的库文件直接使用，自己编译还是相当麻烦的QAQ。选择自己操作系统相关的版本，下载shared和dev两个压缩包：<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Mingw-ffmpeg_01.png" alt="官网下载"></p>
<p>Static包含的是静态编译的ffmpeg.exe，Shared包含的是ffmpeg的动态库及ffmpeg.exe,Dev中包含的是加入到工程中的lib（使用的时候还是要添加动态库才能运行）。</p>
<h4 id="添加到工程"><a href="#添加到工程" class="headerlink" title="添加到工程"></a>添加到工程</h4><p>在pro文件中加上对应的libs，添加lib的时候不用写后缀名字：</p>
<pre><code>-L$$SDKs/ffmpeg/lib -L$$SDKs/ffmpeg/bin -lavutil -lavformat -lavcodec -lswscale -lavdevice -lswresample 
</code></pre><p>在要使用的文件中引用ffmpeg相关的头文件：<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Mingw-ffmpeg_02.png" alt="引用头文件"></p>
<h4 id="可能的问题"><a href="#可能的问题" class="headerlink" title="可能的问题"></a>可能的问题</h4><ul>
<li>最新的ffmpeg有把libfmx (使用intel的qsv硬编硬解，下面有说明) 编译进去，但是好像没有fmx的头文件，会报错。可以去<a href="https://github.com/lu-zero/mfx_dispatch/tree/master/mfx" target="_blank" rel="noopener">这里</a>下下来，放到ffmpeg的include目录下。</li>
<li>编译没问题记得要把dev中的dll拷贝到生成的exe目录下，否则运行不起来。</li>
<li>相关工程可以参考<a href="https://github.com/Longxr/ffmpegtest" target="_blank" rel="noopener">gayhub</a>的demo。</li>
</ul>
<h3 id="自定义编译"><a href="#自定义编译" class="headerlink" title="自定义编译"></a>自定义编译</h3><p>官网下载的ffmpeg动态库编译的configure里有一条是<code>--enable gpl</code>，我们用的时候是直接用的动态库，我也不确定这算不算LGPL，实在没辙的话只能自己编译了。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Mingw-ffmpeg_03.png" alt="license相关"></p>
<h4 id="IDE安装"><a href="#IDE安装" class="headerlink" title="IDE安装"></a>IDE安装</h4><p>本人安装的是Qt5.7.0的mingw32bit，<a href="http://download.qt.io/archive/qt/5.7/5.7.0/" target="_blank" rel="noopener">下载地址戳我</a></p>
<h3 id="msys2安装"><a href="#msys2安装" class="headerlink" title="msys2安装"></a>msys2安装</h3><p>因为要编译32bit的，下载选择msys2的32位版本，<a href="http://www.msys2.org/" target="_blank" rel="noopener">下载地址戳我</a><br>安装完成后找到msys2安装目录下的msys2_shell.cmd，将其中一行的注释去掉：<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Mingw-ffmpeg_04.png" alt="msys2_shell.cmd修改"></p>
<p>打开Qt的命令行工具，将目录切换到msys2的安装目录下，输入：<code>msys2_shell.cmd -mingw32</code><br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Mingw-ffmpeg_05.png" alt="命令行输入"></p>
<p>msys2就打开了，下一步是安装相关的软件包。</p>
<h3 id="软件包安装"><a href="#软件包安装" class="headerlink" title="软件包安装"></a>软件包安装</h3><p>在msys2中的包管理工具是pacman，安装命令如下：</p>
<pre><code>pacman -S make
pacman -S pkg-config
pacman -S nasm
pacman -S git
pacman -S automake autoconf perl libtool
</code></pre><h3 id="软编-编译libx264，这货是GPL的哈"><a href="#软编-编译libx264，这货是GPL的哈" class="headerlink" title="软编(编译libx264，这货是GPL的哈)"></a>软编(编译libx264，这货是GPL的哈)</h3><p>先下载源码，<code>git clone http://git.videolan.org/git/x264.git</code>,切换到x264仓库目录下：</p>
<pre><code>./configure \
 --prefix=/usr/local \
 --enable-shared \
 --disable-cli
 (loading...)

 ./make -j$(nproc)
 (loading...)

make install
 (loading...)
</code></pre><h3 id="硬编intel-qsv准备"><a href="#硬编intel-qsv准备" class="headerlink" title="硬编intel qsv准备"></a>硬编intel qsv准备</h3><p>需要libmfx库 ，下载源码，<code>git clone https://github.com/lu-zero/mfx_dispatch.git</code>,切换到对应目录下：</p>
<pre><code>autoreconf -i
 (loading...)

./configure --prefix=/usr/local
 (loading...)

make -j$(nproc)
 (loading...)

make install
 (loading...)
</code></pre><h3 id="硬编Nvidia-nvenc准备"><a href="#硬编Nvidia-nvenc准备" class="headerlink" title="硬编Nvidia nvenc准备"></a>硬编Nvidia nvenc准备</h3><p>添加nvidia codec头文件，<code>git clone https://git.videolan.org/git/ffmpeg/nv-codec-headers.git</code>,切换到目录下：</p>
<pre><code>make
make install
</code></pre><p>NVidia Video Codec SDK下载，<a href="https://developer.nvidia.com/nvidia-video-codec-sdk#Download" target="_blank" rel="noopener">下载地址戳我</a>, 解压后把里面的NvCodec下的库文件拷贝到/usr/local/lib、头文件拷贝到/usr/local/include下</p>
<h3 id="编译ffmpeg"><a href="#编译ffmpeg" class="headerlink" title="编译ffmpeg"></a>编译ffmpeg</h3><p>下载ffmpeg源码，<code>git clone https://git.ffmpeg.org/ffmpeg.git</code>,切换到对应目录下：</p>
<pre><code>PKG_CONFIG_PATH=&quot;/usr/local/lib/pkgconfig&quot;
./configure \
--prefix=/usr/local/ffmpeg \
--disable-static \
--enable-shared \
--enable-gpl \
--target-os=mingw32 \
--enable-libx264 \
--enable-libmfx \
--enable-encoder=h264_qsv \
--enable-decoder=h264_qsv \
--enable-nvenc \
--enable-cuda \
--enable-cuvid \
--enable-nonfree \
--extra-cflags=-I/usr/local/include \
--extra-ldflags=-L/usr/local/lib
 (loading...)

make -j$(nproc)
 (loading...)

make install
 (loading...)
</code></pre><p>编译好后的ffmpeg在/usr/local/ffmpeg，就是configure第一行指定的位置。<br>最后贴下各种文件的目录：<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Mingw-ffmpeg_06.png" alt="源码下载路径"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Mingw-ffmpeg_07.png" alt="ffmpeg添加的lib路径"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Mingw-ffmpeg_08.png" alt="ffmpeg 添加的include路径"></p>
<h3 id="可能的问题-1"><a href="#可能的问题-1" class="headerlink" title="可能的问题"></a>可能的问题</h3><ul>
<li>测试编译，没有把–enable gpl去掉，不确定去掉能不能编译哈，毕竟….x264是GPL的。</li>
<li>编译好后的ffmpeg可以在Qt下正常使用qsv、nvenc编码，解码暂时没用到不确定。</li>
<li>编译出来的ffmpeg.exe没法双击运行，提示无法定位程序输入点__gxx_personality_v0于动态链接库avcodec-58.dll上。</li>
<li>Nvidia的cuda硬解在mingw下貌似搞不了……<a href="https://stackoverflow.com/questions/5888908/cuda-with-mingw-updated" target="_blank" rel="noopener">相关问题</a></li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> ffmpeg </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt-NSIS]]></title>
      <url>https://longxuan.ren/2018/07/02/Qt-NSIS/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>用NSIS打包Qt程序<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<blockquote>
<p>写好了程序之后要关心的就是怎么将程序打包成一个安装包发给用户了，这里就推荐一个功能比较全面的打包脚本NSIS。在一般情况下，只要不是特别傻逼的需求 (纠结安装包字符串显示的大爷惹不起惹不起….) 都是能实现的。</p>
</blockquote>
<h2 id="Qt程序处理"><a href="#Qt程序处理" class="headerlink" title="Qt程序处理"></a>Qt程序处理</h2><h3 id="编译程序的release版"><a href="#编译程序的release版" class="headerlink" title="编译程序的release版"></a>编译程序的release版</h3><p>1.IDE版<br>构建方式换成Release，点击Qt Creator的运行按钮</p>
<p>2.命令行版(方便自动化构建)</p>
<pre><code>set PATH=c:\Qt\Qt5.7.0\5.7\mingw53_32\bin;%PATH%
set PATH=c:\Qt\Qt5.7.0\Tools\mingw530_32\bin;%PATH%
cd %~dp0
mingw32-make.exe clean
qmake.exe Demo.pro -spec win32-g++ &quot;CONFIG+=release&quot; &amp;&amp; mingw32-make.exe qmake_all
mingw32-make.exe -j4
</code></pre><h3 id="查找Qt程序需要的动态库文件"><a href="#查找Qt程序需要的动态库文件" class="headerlink" title="查找Qt程序需要的动态库文件"></a>查找Qt程序需要的动态库文件</h3><p>直接将Qt的release目录拷贝到一个没装Qt的电脑里，会发现无法运行，这是因为有的Qt核心的动态库并不会在构建的时候放到该目录下，需要额外添加，Qt给我们提供了一个方便的工具来查找程序需要的相关dll，windeployqt.exe。</p>
<ol>
<li>widget版：<pre><code>set PATH=c:\Qt\Qt5.7.0\5.7\mingw53_32\bin;%PATH%
set PATH=c:\Qt\Qt5.7.0\Tools\mingw530_32\bin;%PATH%
windeployqt.exe Demo.exe --dir %PRODUCT_DIR%
</code></pre>2.含有qml界面版：<pre><code>set PATH=c:\Qt\Qt5.7.0\5.7\mingw53_32\bin;%PATH%
set PATH=c:\Qt\Qt5.7.0\Tools\mingw530_32\bin;%PATH%
windeployqt.exe --qmldir   %QML_FILE_DIR% Demo.exe  --dir %PRODUCT_DIR%
</code></pre>3.莫名其妙缺少dll版：<br>上面通过windeployqt.exe查找后还是缺失的话，直接去Qt放dll的目录，把所有dll拷贝到release目录下，把你的程序运行起来，然后删除所有dll，提示占用不能删除留下来的就是你需要的。</li>
</ol>
<h3 id="NSIS打包"><a href="#NSIS打包" class="headerlink" title="NSIS打包"></a>NSIS打包</h3><p>NSIS有界面化的工具HM VNISEdit，不过一般都得改，就直接用文本编辑器手敲好了。可以先用工具生成一个默认的模板看看，下面主要讲下特殊需求怎么通过脚本实现。</p>
<p>1.安装/卸载程序互斥：同时只能开启一个安装/卸载程序：</p>
<pre><code>;安装程序互斥
!define Mutex_Install     &quot;Demo_Mutex_Install&quot;
!define Mutex_UnInstall   &quot;Demo_Mutex_UnInstall&quot;


Function CreateMutex
;检查安装互斥
ReCheck:
System::Call &#39;kernel32::CreateMutexA(i 0, i 0, t &quot;${Mutex_Install}&quot;) i .R1 ?e&#39;
Pop $R0
System::Call &#39;kernel32::CloseHandle(i R1) i.s&#39;
;检查卸载互斥
System::Call &#39;kernel32::CreateMutexA(i 0, i 0, t &quot;${Mutex_UnInstall}&quot;) i .R3 ?e&#39;
Pop $R2
System::Call &#39;kernel32::CloseHandle(i R3) i.s&#39;
;判断安装/卸载互斥的存在
${If} $R0 != 0
MessageBox MB_RetryCancel|MB_ICONEXCLAMATION &quot;$(MutexInstallMessage)&quot; IdRetry ReCheck
Quit
${ElseIf} $R2 != 0
MessageBox MB_RetryCancel|MB_ICONEXCLAMATION &quot;$(MutexUninstallMessage)&quot; IdRetry ReCheck
Quit
${Else}
;创建安装互斥
System::Call &#39;kernel32::CreateMutexA(i 0, i 0, t &quot;${Mutex_Install}&quot;) i .R1 ?e&#39;
Pop $R0
StrCmp $R0 0 +2
Quit
${EndIf}
FunctionEnd

Function Un.CreateMutex
;检查安装互斥
ReCheck:
System::Call &#39;kernel32::CreateMutexA(i 0, i 0, t &quot;${Mutex_Install}&quot;) i .R1 ?e&#39;
Pop $R0
System::Call &#39;kernel32::CloseHandle(i R1) i.s&#39;
;检查卸载互斥
CheckUnInstall:
System::Call &#39;kernel32::CreateMutexA(i 0, i 0, t &quot;${Mutex_UnInstall}&quot;) i .R3 ?e&#39;
Pop $R2
System::Call &#39;kernel32::CloseHandle(i R3) i.s&#39;
;判断安装/卸载互斥的存在
${If} $R0 != 0
MessageBox MB_RetryCancel|MB_ICONEXCLAMATION &quot;$(MutexInstallMessage)&quot; IdRetry ReCheck
Quit
${ElseIf} $R2 != 0
MessageBox MB_RetryCancel|MB_ICONEXCLAMATION &quot;$(MutexUninstallMessage)&quot; IdRetry ReCheck
Quit
${Else}
;创建卸载互斥
System::Call &#39;kernel32::CreateMutexA(i 0, i 0, t &quot;${Mutex_UnInstall}&quot;) i .R1 ?e&#39;
Pop $R0
StrCmp $R0 0 +2
Quit
${EndIf}
FunctionEnd

Function .onInit
Call CreateMutex
...
FunctionEnd
</code></pre><ol start="2">
<li><p>检测所安装的程序是否有在运行，在的话弹个框提示杀进程：</p>
<pre><code>...
Push $R0
CheckProc:
 Push &quot;${PRODUCT_MAIN_APP_EXE}&quot;
 ProcessWork::existsprocess
 Pop $R0
 IntCmp $R0 0 Done
 ; MessageBox MB_OKCANCEL|MB_ICONSTOP $(InstallWarningMessage) IDCANCEL Exit
 MessageBox MB_OKCANCEL|MB_ICONSTOP &quot;$(InstallWarningMessage)&quot; IDCANCEL Exit
 Push &quot;${PRODUCT_MAIN_APP_EXE}&quot;
 Processwork::KillProcess
 Sleep 1000
 Goto CheckProc
Exit:
  Abort
Done:
 Pop $R0
...
</code></pre></li>
<li><p>检测是否安装过旧版本，有的话提示卸载:</p>
</li>
</ol>
<pre><code>    var /GLOBAL UNINSTALL_PROG
    var /GLOBAL OLD_VER
    var /GLOBAL OLD_PATH

    ClearErrors
      ReadRegStr $UNINSTALL_PROG ${PRODUCT_UNINST_ROOT_KEY} ${PRODUCT_UNINST_KEY} &quot;UninstallString&quot;
      IfErrors  FinishInit

      ReadRegStr $OLD_VER ${PRODUCT_UNINST_ROOT_KEY} ${PRODUCT_UNINST_KEY} &quot;DisplayVersion&quot;
      MessageBox MB_YESNOCANCEL|MB_ICONQUESTION &quot;$(Uninstall_Old_Message)&quot; /SD IDYES IDYES UninstallOld IDNO FinishInit
      Abort

    UninstallOld:
      StrCpy $OLD_PATH $UNINSTALL_PROG -10

      ExecWait &#39;&quot;$UNINSTALL_PROG&quot; /S _?=$OLD_PATH&#39; $0
      DetailPrint &quot;uninst.exe returned $0&quot;
      Delete &quot;$UNINSTALL_PROG&quot;
      RMDir $OLD_PATH

    FinishInit:

</code></pre><ol start="4">
<li>安装包多语言:</li>
</ol>
<pre><code>; 语言选择窗口常量设置
!define MUI_LANGDLL_REGISTRY_ROOT &quot;${PRODUCT_UNINST_ROOT_KEY}&quot;
!define MUI_LANGDLL_REGISTRY_KEY &quot;${PRODUCT_UNINST_KEY}&quot;
!define MUI_LANGDLL_REGISTRY_VALUENAME &quot;NSIS:Language&quot;

!define MUI_LANGDLL_WINDOWTITLE &quot;$(LangDialog_Title)&quot;
!define MUI_LANGDLL_INFO &quot;$(LangDialog_Text)&quot;
!define MUI_LANGDLL_ALLLANGUAGES

; 安装界面包含的语言设置
!insertmacro MUI_LANGUAGE &quot;English&quot; ;first language is the default language
!insertmacro MUI_LANGUAGE &quot;SimpChinese&quot;


; 安装预释放文件
!insertmacro MUI_RESERVEFILE_LANGDLL
;!insertmacro MUI_RESERVEFILE_INSTALLOPTIONS

Function .onInit
 !insertmacro MUI_LANGDLL_DISPLAY 

FunctionEnd
</code></pre><ol start="5">
<li>界面美化<br>如果制作的安装包不需要多语言的设置的话，可以通过一些别人写好的插件进行界面美化，如：<a href="http://www.ggniu.cn/download.htm#" target="_blank" rel="noopener">nsNiuniuSkin</a><br>下载下来就带了2个demo，改改就能自己用了，比较方便。Demo图示：<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-NSIS_01.png" alt="Demo1.png"></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-NSIS_02.png" alt="Demo2.png"></p>
</the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> NSIS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[QtAddressBar]]></title>
      <url>https://longxuan.ren/2018/07/02/QtAddressBar/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>Qt仿Windows10地址栏<a id="more"></a></excerpt></p>
<p><the rest of contents | 余下全文></the></p>
<blockquote>
<p>windows10的地址栏挺有意思的，就是事件处理烦了点，欢迎大家测试下</p>
</blockquote>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/QtAddressBar_01.gif" alt="效果图"></p>
<h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2><p><a href="https://github.com/Longxr/QtAddressBar" target="_blank" rel="noopener">gayhub~</a></p>
]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QtAddressBar </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt-QSS]]></title>
      <url>https://longxuan.ren/2018/05/24/Qt-QSS/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>Qt常用QSS集合<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<blockquote>
<p>Qt拿来画控件还是很方便的，其中除了重写paint() 函数外，最常用的就是控件的样式表qss了。本文简单介绍下QSS，同时记录下各种QSS日常骚操作。</p>
</blockquote>
<h2 id="QSS介绍"><a href="#QSS介绍" class="headerlink" title="QSS介绍"></a>QSS介绍</h2><h3 id="QSS简介"><a href="#QSS简介" class="headerlink" title="QSS简介"></a>QSS简介</h3><p>QSS称为Qt Style Sheets也就是Qt样式表，它是Qt提供的一种用来自定义控件外观的机制。QSS大量参考了CSS的内容，只不过QSS的功能比CSS要弱很多，体现在选择器要少，可以使用的QSS属性也要少很多，并且并不是所有的属性都可以用在Qt的所有控件上。</p>
<h3 id="QSS的语法规则"><a href="#QSS的语法规则" class="headerlink" title="QSS的语法规则"></a>QSS的语法规则</h3><p>基本和CSS相同，只是有的属性QSS中没有，相当于CSS的子集。</p>
<h3 id="QSS的选择器类型"><a href="#QSS的选择器类型" class="headerlink" title="QSS的选择器类型"></a>QSS的选择器类型</h3><table>
<thead>
<tr>
<th>选择器</th>
<th>栗子</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>通配选择器</td>
<td>*</td>
<td>匹配所有的控件</td>
</tr>
<tr>
<td>类型选择器</td>
<td>QPushButton</td>
<td>匹配所有QPushButton和其子类的实例</td>
</tr>
<tr>
<td>属性选择器</td>
<td>QPushButton[flat=”false”]</td>
<td>匹配所有flat属性是false的QPushButton实例，注意该属性可以是自定义的属性，不一定非要是类本身具有的属性</td>
</tr>
<tr>
<td>类选择器</td>
<td>.QPushButton</td>
<td>匹配所有QPushButton的实例，但是并不匹配其子类</td>
</tr>
<tr>
<td>ID选择器</td>
<td>#myButton</td>
<td>匹配所有id为myButton的控件实例，这里的id实际上就是objectName指定的值</td>
</tr>
<tr>
<td>包含选择器</td>
<td>QDialog QPushButton</td>
<td>所有QDialog容器中包含的QPushButton，不管是直接的还是间接的</td>
</tr>
<tr>
<td>子选择器</td>
<td>QDialog &gt; QPushButton</td>
<td>所有QDialog容器下面的QPushButton，其中要求QPushButton的直接父容器是QDialog</td>
</tr>
</tbody>
</table>
<p>另外上面所有的这些选择器可以联合使用，并且支持一次设置多个选择器类型，用逗号隔开，同CSS一样。</p>
<h3 id="QSS子控件"><a href="#QSS子控件" class="headerlink" title="QSS子控件"></a>QSS子控件</h3><p>QSS为很多复杂的复合控件提供了子控件的定义，以方便对这些复合控件的各个部分进行样式设置，具体使用下面说明。</p>
<h3 id="QSS伪状态"><a href="#QSS伪状态" class="headerlink" title="QSS伪状态"></a>QSS伪状态</h3><p>QSS的伪状态选择器实际上与CSS中的类似，是以冒号开头的一个选择表达式，他限制了当控件在某一种状态下的时候才能应用QSS规则，伪状态只能描述一个控件的状态，或者是一个复合控件中的子控件的状态。下面列出常用的伪状态：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:active</td>
<td>当小部件驻留在活动窗口中时，将设置此状态</td>
</tr>
<tr>
<td>:checked</td>
<td>该控件被选中时候的状态</td>
</tr>
<tr>
<td>:hover</td>
<td>鼠标在控件上方</td>
</tr>
<tr>
<td>:pressed</td>
<td>该控件被按下时的状态</td>
</tr>
<tr>
<td>:disabled</td>
<td>该控件禁用时的状态</td>
</tr>
<tr>
<td>:first</td>
<td>该控件是第一个（列表中）</td>
</tr>
<tr>
<td>:focus</td>
<td>该控件有输入焦点时</td>
</tr>
<tr>
<td>:has-children</td>
<td>该控件有孩子。例如，QTreeView中包含子项目的控件</td>
</tr>
<tr>
<td>:open</td>
<td>该控件处于打开状态。例如，QTreeView中的扩展项，或打开菜单的QComboBox或QPushButton</td>
</tr>
<tr>
<td>:unchecked</td>
<td>该控件未被选中</td>
</tr>
</tbody>
</table>
<h2 id="QSS代码片段"><a href="#QSS代码片段" class="headerlink" title="QSS代码片段"></a>QSS代码片段</h2><h3 id="单个控件"><a href="#单个控件" class="headerlink" title="单个控件"></a>单个控件</h3><pre><code>QPushButton{        /*按钮上图标下文字*/
    text-align:bottom ;
    image-position:top;
    color: #666666;
    border:none;
    image: url(:xxxxx.png);
}

QPushButton{         /*按钮自适应拉伸背景*/
border-width: 2px 15px 2px 15px;
border-image: url(:/resource/icon/button_nomal.png) 2 15 2 15 repeat stretch;
color:#3288E8;
}

QPushButton{        /*按钮选中带下划线*/
border:none;
border-width:5;
border-bottom-style:solid;
border-color:transparent;
color:#666666;
}
QPushButton:checked{
color:#3288E8;
border-color: #3288E8;
}

QPushButton{      /*按钮左文字右图标*/
    background-image:url(:/resource/btn.png);
    background-repeat:norepeat;
    background-position:right;
    text-align:right;
    border:none;
    color:white;    
    padding-right:35px;
}



</code></pre><h3 id="含子控件"><a href="#含子控件" class="headerlink" title="含子控件"></a>含子控件</h3><pre><code>/**************************************CheckBox*********************************************/
QCheckBox::indicator:unchecked{
image: url(:/resource/chebox_off.png)
}

QCheckBox::indicator:checked{
image: url(:/resourcechebox_on.png)
}
/**************************************CheckBox*********************************************/


/**************************************QTabBar*********************************************/
QTabBar::tab {
    color: #666666; 
    height:40px; 
    width:100px;
} 
QTabBar::tab:selected {
    color: #333333; 
    font-weight:bold
}
 QTabBar::tab:hover {
    color: #666666;
}
/**************************************QTabBar*********************************************/


/**************************************滑动条*********************************************/
QSlider {
    background: rgb(170, 170, 170);
    padding: 2px;
    height: 40px;
}
QSlider::groove:horizontal {
    subcontrol-origin: content;
    background: rgb(76, 76, 76);

    /* the groove expands to the size of the slider by default. 
    by giving it a height, it has a fixed size */
    height: 20px;
}
QSlider::handle:horizontal {
    background-color: rgb(50, 50, 50);
    width: 40px;
    border-radius: 20px;

    /* handle is placed by default on the contents rect of the groove. 
    Expand outside the groove */
    margin: -10px 0;
}
QSlider::sub-page:horizontal {
    background: #999;
    margin: 5px;
    border-radius: 5px;
}
QSlider::add-page:horizontal {
    background: #666;
    margin: 5px;
    border-radius: 5px;
}
/**************************************滑动条*********************************************/


/**************************************下拉框*********************************************/
QComboBox{
border:0px; 
background-color:transparent;
color:#333333; 
}
QComboBox::down-arrow{
image:none;
}
QComboBox::drop-down{
width:0px; 
border:0px;
}
QComboBox QAbstractItemView {
color:#333333;
border: 1px solid #DDDDDD;
background-color:white;
selection-color:white;
selection-background-color: rgb(0, 102, 96);
}
/**************************************下拉框*********************************************/


/**************************************滚动条*********************************************/
QScrollBar:horizontal {
    height: 16px;
    border-width: 0px 10px 0px 10px;
    border-image: url(:/img/horizontal-track.png) 0 10 0 10 repeat stretch;
    margin-left: 6px;
    margin-right: 16px;
    padding-right: 4px;
}
QScrollBar::handle:horizontal {
    min-width: 40px;
    border-width: 0 17px 0 17px;
    border-image: url(:/img/horizontal-handle.png) 0 17 0 17 repeat repeat;
}
QScrollBar::sub-line:horizontal {
    width: 20px;
    height: 17px;
    subcontrol-position: left;
    subcontrol-origin: margin;
    background-image: url(:/img/horizontal-sub-line.png)
}
QScrollBar::add-line:horizontal {
    width: 20px;
    height: 17px;
    subcontrol-position: right;
    subcontrol-origin: border;
    background-image: url(:/img/horizontal-add-line.png)
}
QScrollBar:vertical {
    width: 16px;
    border-width: 10px 0px 10px 0px;
    border-image: url(:/img/vertical-track.png) 10 0 10 0 repeat repeat;
    margin-top: 6px;
    margin-bottom: 16px;
    padding-bottom: 6px;
}
QScrollBar::handle:vertical {
    min-height: 40px;
    border-width: 17px 0px 17px 0px;
    border-image: url(:/img/vertical-handle.png) 17 0 17 0 repeat repeat;
}
QScrollBar::sub-line:vertical {
    width: 17px;
    height: 22px;
    subcontrol-position: top left;
    subcontrol-origin: margin;
    background-image: url(:/img/vertical-sub-line.png)
}
QScrollBar::add-line:vertical {
    width: 17px;
    height: 22px;
    subcontrol-position: bottom;
    subcontrol-origin: border;
    background-image: url(:/img/vertical-add-line.png)
}
/**************************************滚动条*********************************************/
</code></pre><p>持续更新ing…</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.cnblogs.com/wangqiguo/p/4960776.html" target="_blank" rel="noopener">QSS总结以及最近做的Qt项目</a></li>
<li><a href="https://qtdebug.com/qtbook-qss/" target="_blank" rel="noopener">Qss</a></li>
<li><a href="https://blog.csdn.net/liang19890820/article/details/51691212" target="_blank" rel="noopener">Qt之QSS（样式表语法）</a></li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt-TsFileTranslateTool]]></title>
      <url>https://longxuan.ren/2018/04/13/Qt-TsFileTranslateTool/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>Qt翻译文件处理工具,根据源文本生成excel文件，可调用有道云自动翻译<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<blockquote>
<p>Qt项目在国际化方面使用的是自带的语言家工具，将代码中需要翻译的字符串抽出再进行翻译工作。然后在最后一步的时候….iOS和android可以直接把包含翻译文本的文件给翻译人员，Qt的话还要教别人装上Qt语言家，还只能一条一条的翻译，有点麻烦…于是抽空做了个处理翻译文件的小工具。</p>
</blockquote>
<h2 id="生成翻译文件"><a href="#生成翻译文件" class="headerlink" title="生成翻译文件"></a>生成翻译文件</h2><ul>
<li>在代码中将需要翻译的文本用<code>tr(&quot;&quot;)</code>包含起来</li>
<li>真正显示的文本可能会需要更改，所以在代码中我是保存了一个显示文本的字符串key值，以后更新只用修改translation即可</li>
<li>在.pro文件中加上<code>TRANSLATIONS += Localizations/string_zh.ts</code>来告诉Qt生成的翻译文件搁哪儿</li>
<li>选择：工具-&gt;外部-&gt;Qt语言家-&gt;更新翻译，则会生成对应的ts文件<br>这个生成翻译文件的过程有点慢，而且中间还没提示….可以打开任务管理器qtcreator.exe下的lupdate.exe还在就说明仍在抽字符串</li>
</ul>
<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><h3 id="生成待翻译字符串的excel文件"><a href="#生成待翻译字符串的excel文件" class="headerlink" title="生成待翻译字符串的excel文件"></a>生成待翻译字符串的excel文件</h3><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-TsFileTranslateTool_01.gif" alt="生成excel文件"></p>
<p>.ts文件中的源文本作为excel的第一列key值，翻译文本(如果有的话)在抽出的时候放在第三列，没有则为空<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-TsFileTranslateTool_02.png" alt="excel截图.png"></p>
<p>因为我加入了一列key值，一般情况生成的话key就是你原来的源文本，如果要使用自动翻译功能，将第一列拷贝一份到第二列即可；也可以像我这样代码里代码里不写实际的文本，另外生成一个中文的翻译文件(ts)，将translation放上中文，需要其他语言的翻译的时候将中文拷贝到第二列即可</p>
<h3 id="更新翻译文件-ts"><a href="#更新翻译文件-ts" class="headerlink" title="更新翻译文件(.ts)"></a>更新翻译文件(.ts)</h3><ul>
<li>如果有专门负责翻译的人的话，可以将excel第二列放源文本后给别人，让他把翻译好的字符串放在第三列。翻译好后，选择好excel文件和ts文件，点击<em>译文写入</em>按钮就可以愉快地导入翻译内容了</li>
<li>部分包含标点符号的地方可能有点小问题，可以打开Qt语言家检查下</li>
</ul>
<h3 id="自动翻译"><a href="#自动翻译" class="headerlink" title="自动翻译"></a>自动翻译</h3><ul>
<li>将要翻译的excel文件第二列放要翻译的文本（重要！！！）</li>
<li>自动翻译功能调用的<a href="http://ai.youdao.com/index.s" target="_blank" rel="noopener">有道智云的API</a>，需要使用的话自己去注册一个账号，免费送100元体验金。注册好后添加自己的翻译实例和应用，并将你的应用ID和应用密钥填到程序代码的:<code>TSFileEditor\Source\MainApps\TSFileEditor\TranslateWorker.cpp</code>上边<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-TsFileTranslateTool_03.png" alt="有道智云"></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-TsFileTranslateTool_04.png" alt="填写位置"></p>
<p>以后有时间我再加个在主界面填写这个ID和密钥的地方(￣▽￣)”（懒得改….）</p>
<ul>
<li>下面是中文翻译成日文的栗子：<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-TsFileTranslateTool_05.gif" alt="translate.gif"></li>
</ul>
<p>点击<em>excel生成</em>按钮后，就可以得到翻译好的excel了：<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-TsFileTranslateTool_06.png" alt="翻译结果"></p>
<ul>
<li>然后可以结合功能二来更新翻译文件(ts)，之后就可以愉快地发布出(qm)给程序用了</li>
</ul>
<h2 id="小工具代码下载地址"><a href="#小工具代码下载地址" class="headerlink" title="小工具代码下载地址"></a>小工具代码下载地址</h2><p>github仓库-&gt;<a href="https://github.com/Longxr/TSFileEditor/releases" target="_blank" rel="noopener">下载地址</a> ，喜欢的话给个star吧~<br>  ​</p>
</the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> translate </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt-AutoLayout]]></title>
      <url>https://longxuan.ren/2018/02/28/Qt-AutoLayout/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>Qt之自动布局<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<blockquote>
<p>每月一更差点忘了emmmmmm，新年第一更</p>
</blockquote>
<h2 id="Qt的布局类"><a href="#Qt的布局类" class="headerlink" title="Qt的布局类"></a>Qt的布局类</h2><p>比较常用的有QHBoxLayout、QVBoxLayout、QGridLayout、QButtonGroup等。</p>
<table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>QBoxLayout</td>
<td>水平或垂直排列控件</td>
</tr>
<tr>
<td>QButtonGroup</td>
<td>组织按钮的容器</td>
</tr>
<tr>
<td>QFormLayout</td>
<td>管理输入控件和其相关的标签</td>
</tr>
<tr>
<td>QGraphicsAnchor</td>
<td>表示在QGraphicsAnchorLayout中两个项目之间的锚</td>
</tr>
<tr>
<td>QGraphicsAnchorLayout</td>
<td>在图形视图中可以将锚连接到一起</td>
</tr>
<tr>
<td>QGridLayout</td>
<td>网格布局（多行多列）</td>
</tr>
<tr>
<td>QGroupBox</td>
<td>带标题的分组框</td>
</tr>
<tr>
<td>QHBoxLayout</td>
<td>水平排列控件</td>
</tr>
<tr>
<td>QVBoxLayout</td>
<td>垂直排列控件</td>
</tr>
<tr>
<td>QLayout</td>
<td>几何管理器的基类</td>
</tr>
<tr>
<td>QLayoutItem</td>
<td>抽象的操作布局Item</td>
</tr>
<tr>
<td>QSizePolicy</td>
<td>描述水平和垂直大小调整的策略</td>
</tr>
<tr>
<td>QSpacerItem</td>
<td>布局中的空间隔</td>
</tr>
<tr>
<td>QStackedLayout</td>
<td>切换控件，同一时间只有一个控件可见</td>
</tr>
<tr>
<td>QStackedWidget</td>
<td>切换控件，同一时间只有一个控件可见</td>
</tr>
<tr>
<td>QWidgetItem</td>
<td>表示一个控件的布局项</td>
</tr>
</tbody>
</table>
<h2 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><blockquote>
<ol>
<li>所有的widgets将根据他们的QWidget::sizePolicy()和QWidget::sizeHint()被初始化一定数量的空间。</li>
<li>如果一个widget有stretch factors(值大于0的)要设置，那么就会为他们分配这些空间。</li>
<li>如果其他widgets都不在需要空间了，那么就会把剩余的空间都给那些stretch factors为0的widget。那些设置了QSizePolicy::Expanding的优先分配。</li>
<li>那些设置了最小大小却还没有被分配到他们的最小值的widgets会被分配空间直到他们的最小值。</li>
<li>那些设置了最大大小却分配空间多于了这个最大值的widgets会被分配空间直到他们的最大值。</li>
</ol>
</blockquote>
<h3 id="SizePolicy属性"><a href="#SizePolicy属性" class="headerlink" title="SizePolicy属性"></a>SizePolicy属性</h3><p>控件的sizePolicy说明控件在布局管理中的缩放方式。Qt提供的控件都有一个合理的缺省sizePolicy，但是这个缺省值有时不能适合所有的布局，开发人员经常需要改变窗体上的某些控件的sizePolicy。一个QSizePolicy的所有变量对水平方向和垂直方向都适用。下面列举了一些最长用的值：</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Fixed</td>
<td>控件不能放大或者缩小，控件的大小就是它的sizeHint</td>
</tr>
<tr>
<td>Minimum</td>
<td>控件的sizeHint为控件的最小尺寸。控件不能小于这个sizeHint，但是可以放大</td>
</tr>
<tr>
<td>Maximum</td>
<td>控件的sizeHint为控件的最大尺寸，控件不能放大，但是可以缩小到它的最小的允许尺寸</td>
</tr>
<tr>
<td>Preferred</td>
<td>控件的sizeHint是它的sizeHint，但是可以放大或者缩小</td>
</tr>
<tr>
<td>Expandint</td>
<td>控件可以自行增大或者缩小</td>
</tr>
</tbody>
</table>
<p>注：sizeHint（布局管理中的控件默认尺寸，如果控件不在布局管理中就为无效的值）</p>
<h3 id="layoutStretch属性"><a href="#layoutStretch属性" class="headerlink" title="layoutStretch属性"></a>layoutStretch属性</h3><p>布局中的layoutStretch表明了在该布局中的控件所占比例的分配，默认是0。当设置了大于0的数字后，其余为0的控件默认只占最小的大小，剩下的空间则按照比例分配给数字大于0的控件。举个栗子，在一个水平布局中有3个控件，控件的SizePolicy属性都是<em>Preferred</em>，布局的layoutStretch属性为：<em>0，0，1</em>，那么前2个控件占有最小大小，最后一个控件占满剩下的空间。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-AutoLayout_01.png" alt="布局栗子"></p>
<h2 id="代码中使用自动布局"><a href="#代码中使用自动布局" class="headerlink" title="代码中使用自动布局"></a>代码中使用自动布局</h2><h3 id="将控件加入布局"><a href="#将控件加入布局" class="headerlink" title="将控件加入布局"></a>将控件加入布局</h3><p>在代码中将一个控件加入布局主要用:<br><code>void QBoxLayout::addWidget([QWidget](qwidget.html) *widget, int  stretch = 0, [Qt::Alignment](../qtcore/qt.html#AlignmentFlag-enum)  alignment = Qt::Alignment())</code></p>
<p>QGridLayout要多2个参数,定义控件所占单元格大小：<br><code>void QGridLayout::addWidget([QWidget](qwidget.html) *widget, int  fromRow, int  fromColumn, int  rowSpan, int  columnSpan, [Qt::Alignment](../qtcore/qt.html#AlignmentFlag-enum)  alignment = Qt::Alignment())</code></p>
<h3 id="将布局加入布局"><a href="#将布局加入布局" class="headerlink" title="将布局加入布局"></a>将布局加入布局</h3><p>布局也可以嵌套，将布局加入到另一个布局中。<br><code>void QBoxLayout::addLayout([QLayout](qlayout.html#QLayout) *layout, int  stretch = 0)</code></p>
<pre><code>    m_pGridLayout = new QGridLayout();

    m_pSoftwareName = new QLabel(this);
    m_pSoftwareVer = new QLabel(this);
    m_pLicenseNum = new QLabel(this);
    m_pLicenseTime = new QLabel(this);

    pGridLayout-&gt;addWidget(m_pSoftwareName, 1, 0, 1, -1, Qt::AlignLeft|Qt::AlignVCenter);
    pGridLayout-&gt;addWidget(m_pSoftwareVer, 2, 0, 1, -1, Qt::AlignLeft|Qt::AlignVCenter);
    pGridLayout-&gt;addWidget(m_pLicenseNum, 1, 0, 1, -1, Qt::AlignLeft|Qt::AlignVCenter);
    pGridLayout-&gt;addWidget(m_pLicenseTime, 2, 0, 1, -1, Qt::AlignLeft|Qt::AlignVCenter);

    QVBoxLayout *mainLayout = new QVBoxLayout();
    setLayout(mainLayout);
    mainLayout-&gt;addLayout(m_pGridLayout);
    mainLayout-&gt;addStretch(1);
    mainLayout-&gt;setContentsMargins(0, 0, 0, 0);
</code></pre><h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><ol>
<li>将控件加入布局后还要记得设置放置控件的Widget的布局，调用<em>setLayout函数</em>。</li>
<li>在布局空白部分留白，空白占满剩余空间，布局最后加上<em>addStretch(1)</em>。</li>
</ol>
<h2 id="ui中使用自动布局"><a href="#ui中使用自动布局" class="headerlink" title="ui中使用自动布局"></a>ui中使用自动布局</h2><ol>
<li><p>在Qt设计师界面上方，选中多个控件后点击即可：<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-AutoLayout_02.png" alt="布局按钮"></p>
</li>
<li><p>加入布局后还要注意设置Widget的布局：<img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-AutoLayout_03.png" alt="注意Widget布局"></p>
</li>
<li><p>控件在布局中的对齐方式：<br>控件上右键-&gt;Layout Alignment-&gt;…(选择对齐方式)</p>
</li>
</ol>
<p>4.设置Widget的布局，选中需要布局的Widget，在空白处右键-&gt;布局。</p>
<ol start="5">
<li>默认的水平布局等有一个默认的间距，不需要改成0即可：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-AutoLayout_04.png" alt="Layout间距"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><p><a href="http://www.cnblogs.com/emouse/archive/2013/05/19/3087708.html" target="_blank" rel="noopener">Qt Creator 窗体控件自适应窗口大小布局</a></p>
</li>
<li><p><a href="http://blog.csdn.net/xuguangsoft/article/details/8544827" target="_blank" rel="noopener">Qt 布局管理器</a></p>
</li>
<li><p><a href="http://blog.csdn.net/liang19890820/article/details/51517002" target="_blank" rel="noopener">Qt之布局管理器</a></p>
<p>​</p>
</li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> Layout </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt多项目管理]]></title>
      <url>https://longxuan.ren/2018/01/29/MultiProjectManage/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>Qt多项目管理，pro相关设置<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>



<blockquote>
<p>在做Qt的开发的时候，除了一个生成可执行程序的项目外，有时会将一些独立的模块编译成静态或动态库的形式来调用，方便后期集成到其他项目中。</p>
</blockquote>
<h2 id="项目类型"><a href="#项目类型" class="headerlink" title="项目类型"></a>项目类型</h2><ul>
<li>应用程序 : Application-&gt;Qt Widgets Application</li>
<li>库 : Library-&gt;C++ Library</li>
<li>子目录项目 : 其他项目-&gt;子目录项目</li>
</ul>
<p>首先是先新建一个子目录项目，再根据需要在子目录项目中添加一个应用程序项目以及多个库的项目，子目录项目默认就只有一个.pro文件。<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/MultiProjectManage_01.png" alt="工程目录"></p>
<h2 id="pro文件配置"><a href="#pro文件配置" class="headerlink" title="pro文件配置"></a>pro文件配置</h2><h3 id="pro配置"><a href="#pro配置" class="headerlink" title="pro配置"></a>pro配置</h3><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>从“#”开始，到这一行结束。</p>
<h4 id="TEMPLATE"><a href="#TEMPLATE" class="headerlink" title="TEMPLATE"></a>TEMPLATE</h4><p>模板变量告诉qmake为这个应用程序生成哪种makefile。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>app</td>
<td>创建一个用于构建应用程序的Makefile（默认）。</td>
</tr>
<tr>
<td>lib</td>
<td>创建一个用于构建库的Makefile。</td>
</tr>
<tr>
<td>subdirs</td>
<td>创建一个用于构建目标子目录的Makefile，子目录使用SUBDIRS变量指定。</td>
</tr>
<tr>
<td>aux</td>
<td>创建一个不建任何东西的Makefile。如果没有编译器需要被调用来创建目标，比如你的项目使用解释型语言写的，使用此功能。注：此模板类型只能用于Makefile-based生成器。特别是，它不会工作在vcxproj和Xcode生成器。</td>
</tr>
<tr>
<td>vcapp</td>
<td>仅适用于Windows。创建一个Visual Studio应用程序项目。</td>
</tr>
<tr>
<td>vclib</td>
<td>仅适用于Windows。创建一个Visual Studio库项目。</td>
</tr>
</tbody>
</table>
<h4 id="CONFIG"><a href="#CONFIG" class="headerlink" title="CONFIG"></a>CONFIG</h4><p>指定编译器选项和项目配置，值由qmake内部识别并具有特殊意义。</p>
<p>以下配置值控制编译标志：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>release</td>
<td>项目以release模式构建。如果也指定了debug，那么最后一个生效。</td>
</tr>
<tr>
<td>debug</td>
<td>项目以debug模式构建。</td>
</tr>
<tr>
<td>debug_and_release</td>
<td>项目准备以debug和release两种模式构建。</td>
</tr>
<tr>
<td>debug_and_release_target</td>
<td>此选项默认设置。如果也指定了debug_and_release，最终的debug和release构建在不同的目录。</td>
</tr>
<tr>
<td>build_all</td>
<td>如果指定了debug_and_release，默认情况下，该项目会构建为debug和release模式。</td>
</tr>
<tr>
<td>autogen_precompile_source</td>
<td>自动生成一个.cpp文件，包含在.pro中指定的预编译头文件。</td>
</tr>
<tr>
<td>ordered</td>
<td>使用subdirs模板时，此选项指定应该按照目录列表的顺序处理它们。</td>
</tr>
<tr>
<td>precompile_header</td>
<td>可以在项目中使用预编译头文件的支持。</td>
</tr>
<tr>
<td>warn_on</td>
<td>编译器应该输出尽可能多的警告。如果也指定了warn_off，最后一个生效。</td>
</tr>
<tr>
<td>warn_off</td>
<td>编译器应该输出尽可能少的警告。</td>
</tr>
<tr>
<td>exceptions</td>
<td>启用异常支持。默认设置。</td>
</tr>
<tr>
<td>exceptions_off</td>
<td>禁用异常支持。</td>
</tr>
<tr>
<td>rtti</td>
<td>启用RTTI支持。默认情况下，使用编译器默认。</td>
</tr>
<tr>
<td>rtti_off</td>
<td>禁用RTTI支持。默认情况下，使用编译器默认。</td>
</tr>
<tr>
<td>stl</td>
<td>启用STL支持。默认情况下，使用编译器默认。</td>
</tr>
<tr>
<td>stl_off</td>
<td>禁用STL支持。默认情况下，使用编译器默认。</td>
</tr>
<tr>
<td>thread</td>
<td>启用线程支持。当CONFIG包括qt时启用，这是缺省设置。</td>
</tr>
<tr>
<td>c++11</td>
<td>启用c++11支持。如果编译器不支持c++11这个选项，没有影响。默认情况下，支持是禁用的。</td>
</tr>
<tr>
<td>c++14</td>
<td>启用c++14支持。如果编译器不支持c++14这个选项，没有影响。默认情况下，支持是禁用的。</td>
</tr>
</tbody>
</table>
<h4 id="DEFINES"><a href="#DEFINES" class="headerlink" title="DEFINES"></a>DEFINES</h4><p>qmake添加这个变量的值作为编译器C预处理器宏(-D选项)。</p>
<h4 id="INCLUDEPATH"><a href="#INCLUDEPATH" class="headerlink" title="INCLUDEPATH"></a>INCLUDEPATH</h4><p>指定编译项目时应该被搜索的#include目录。</p>
<h4 id="DEPENDPATH"><a href="#DEPENDPATH" class="headerlink" title="DEPENDPATH"></a>DEPENDPATH</h4><p>指定程序编译时依赖的相关路径。</p>
<h4 id="DESTDIR"><a href="#DESTDIR" class="headerlink" title="DESTDIR"></a>DESTDIR</h4><p>指定在何处放置目标文件。</p>
<h4 id="TARGET"><a href="#TARGET" class="headerlink" title="TARGET"></a>TARGET</h4><p>指定目标文件的名称。默认情况下包含的项目文件的基本名称。</p>
<h4 id="OUT-PWD"><a href="#OUT-PWD" class="headerlink" title="OUT_PWD"></a>OUT_PWD</h4><p>指定构建目录。</p>
<h4 id="MOC-DIR"><a href="#MOC-DIR" class="headerlink" title="MOC_DIR"></a>MOC_DIR</h4><p>指定来自moc的所有中间文件放置的目录（含Q_OBJECT宏的头文件转换成标准.h文件的存放目录）。</p>
<h4 id="OBJECTS-DIR"><a href="#OBJECTS-DIR" class="headerlink" title="OBJECTS_DIR"></a>OBJECTS_DIR</h4><p>指定所有中间文件.o（.obj）放置的目录。</p>
<h4 id="RCC-DIR"><a href="#RCC-DIR" class="headerlink" title="RCC_DIR"></a>RCC_DIR</h4><p>指定Qt资源编译器输出文件的目录（.qrc文件转换成qrc_*.h文件的存放目录）。</p>
<h4 id="LIBS"><a href="#LIBS" class="headerlink" title="LIBS"></a>LIBS</h4><p>指定链接到项目中的库列表。-L后是库文件的目录，-l后是具体的库的名字(后缀不用加)。例如：<br><code>LIBS += -L$$PWD/../../../ThirdLib/winapi  -lWSock32</code></p>
<h4 id="RC-ICONS"><a href="#RC-ICONS" class="headerlink" title="RC_ICONS"></a>RC_ICONS</h4><p>仅适用于Windows，指定的图标应该包含在一个生成的.rc文件里。如果RC_FILE 和RES_FILE变量都没有设置这才可利用。</p>
<h4 id="TRANSLATIONS"><a href="#TRANSLATIONS" class="headerlink" title="TRANSLATIONS"></a>TRANSLATIONS</h4><p>指定包含用户界面翻译文本的翻译(.ts)文件列表。</p>
<h4 id="平台相关性处理"><a href="#平台相关性处理" class="headerlink" title="平台相关性处理"></a>平台相关性处理</h4><p>为Windows平台加的依赖平台的文件的简单的作用域看起来就像这样：<br><code>win32 { SOURCES += hello_win.cpp }</code></p>
<h3 id="子项目pro文件"><a href="#子项目pro文件" class="headerlink" title="子项目pro文件"></a>子项目pro文件</h3><p>每次添加一个子项目就会在SUBDIRS项目加上一个项目名，子目录项目的<em>TEMPLATE = subdirs</em>。<em>CONFIG += ordered</em>是让项目按照顺序编译，由于主程序依赖于对应的库，一般都是把MainApp放在SUBDIRS的最后。</p>
<h3 id="pri文件"><a href="#pri文件" class="headerlink" title="pri文件"></a>pri文件</h3><p>对于一些库和主程序都需要的目录设置 (构建目录、obj生成目录、moc文件生成目录等)，可以统一写在一个pri文件中：</p>
<pre><code>CONFIG(release, debug|release) {
    BuildType=release
    CONFIG += warn_off
} else {
    BuildType=debug
    DEFINES += __DEBUG
}

INTERMEDIATE_DIR = $$PWD/../Intermediate/$$BuildType

DESTDIR         = $$PWD/../RunImage/$$BuildType
OUT_PWD         = $$INTERMEDIATE_DIR/$$TARGET
MOC_DIR         = $$INTERMEDIATE_DIR/$$TARGET
OBJECTS_DIR     = $$INTERMEDIATE_DIR/$$TARGET
RCC_DIR         = $$INTERMEDIATE_DIR/$$TARGET
UI_DIR          = $$INTERMEDIATE_DIR/$$TARGET
</code></pre><p>在需要引用的pro文件中：<br><code>include($$PWD/../../../Path.pri)</code></p>
<h3 id="主程序pro文件"><a href="#主程序pro文件" class="headerlink" title="主程序pro文件"></a>主程序pro文件</h3><p>主程序的<em>TEMPLATE = app</em>。除了常规的pro设置外，要记得将自己编的库的头文件目录加上，并将生成的dll通过LIBS链接：</p>
<pre><code>#library
INCLUDEPATH += \
    $$PWD/../../Libraries \

LIBS += \
    -L$$DESTDIR -lComponent -lcommonLibs \
</code></pre><h3 id="库pro文件"><a href="#库pro文件" class="headerlink" title="库pro文件"></a>库pro文件</h3><p>库的<em>TEMPLATE = lib</em>。库在通过Creator新建的时候会生成一个xxx_global.h，定义了导出库的相关信息：</p>
<pre><code>#include &lt;QtCore/qglobal.h&gt;

#if defined(TESTLIB_LIBRARY)
#  define TESTLIBSHARED_EXPORT Q_DECL_EXPORT
#else
#  define TESTLIBSHARED_EXPORT Q_DECL_IMPORT
#endif
</code></pre><p>在库中要作为接口的类记得加上对应的宏：<br><code>class TESTLIBSHARED_EXPORT TestLib : public QObject</code><br>静态库貌似不需要这个，待测试…</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://blog.csdn.net/liang19890820/article/details/51774724" target="_blank" rel="noopener">Qt之pro配置详解</a></li>
<li><a href="http://blog.csdn.net/adriano119/article/details/5878169" target="_blank" rel="noopener">QT中PRO文件写法的详细介绍</a></li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> pro </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt自定义进度条]]></title>
      <url>https://longxuan.ren/2017/11/16/Qt-CustomProgressbar/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要> Qt真的是一个绘图软件emmmmm<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="瞎扯"><a href="#瞎扯" class="headerlink" title="瞎扯"></a>瞎扯</h2><blockquote>
<p>转眼已经折腾Qt（画图软件23333）快5个月了，C++的东西没学到多少，各种软件绘图技巧倒是折腾了不少。在刚开始工作的时候看到设计稿的软件界面还是一脸懵逼的，现在发现没有什么是Qt的paint()和<a href="https://baike.baidu.com/item/ADOBE%20PHOTOSHOP/2297297?fromtitle=photoshop&amp;fromid=133866" target="_blank" rel="noopener">PS</a>解决不了的，如果有，再加个<a href="https://baike.baidu.com/item/Adobe%20After%20Effects/5452364?fromtitle=ae&amp;fromid=1368576" target="_blank" rel="noopener">Ae</a>~ o(<em>￣▽￣</em>)ブ</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在需要按比例显示数据的时候，进度条是必不可少的。Qt中有一个进度条相关的类QProgressBar，这个类提供了简单的水平或垂直的进度条，可以通过修改qss简单的改变下样式:<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-CustomProgressbar_01.png" alt="自带进度条"></p>
<p>简单使用的话自带的样式就够看了，但是也有时候设计非要搞些酷炫的效果，没办法只能折腾下了……比如，设计稿非要整个两端椭圆的进度条，qss就没辙了。这篇文章主要总结下Qt在绘制控件方面的经验，画都能画出来了，其他骚操作就随便搞了，下面是折腾出来的栗子：<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-CustomProgressbar_02.gif" alt="各种进度条"></p>
<h2 id="各种进度条"><a href="#各种进度条" class="headerlink" title="各种进度条"></a>各种进度条</h2><h3 id="重绘paint之两端圆角进度条-继承QProgressbar"><a href="#重绘paint之两端圆角进度条-继承QProgressbar" class="headerlink" title="重绘paint之两端圆角进度条(继承QProgressbar)"></a>重绘paint之两端圆角进度条(继承QProgressbar)</h3><p>图中第一个，其实也可以直接继承QWidget的，就少写个设置百分比和最小最大值的函数，主要还是重写paint函数，画出进度条底图和根据当前value值画出蓝色进度条：</p>
<pre><code>void RadiusProgressBar::paintEvent(QPaintEvent *)
{
    QPainter p(this);
    QRect rect = QRect(0, 0, width(), height()/2);
    QRect textRect = QRect(0, height()/2, width(), height()/2);

    const double k = (double)(value() - minimum()) / (maximum()-minimum());
    int x = (int)(rect.width() * k);
    QRect fillRect = rect.adjusted(0, 0, x-rect.width(), 0);

    QString valueStr = QString(&quot;%1%&quot;).arg(QString::number(value()));
    QPixmap buttomMap = QPixmap(&quot;:/resource/radius_back.png&quot;);
    QPixmap fillMap = QPixmap(&quot;:/resource/radius_front.png&quot;);

    //画进度条
    p.drawPixmap(rect, buttomMap);
    p.drawPixmap(fillRect, fillMap, fillRect);

    //画文字
    QFont f = QFont(&quot;Microsoft YaHei&quot;, 15, QFont::Bold);
    p.setFont(f);
    p.setPen(QColor(&quot;#555555&quot;));
    p.drawText(textRect, Qt::AlignCenter, valueStr);
}
</code></pre><h3 id="重绘paint之纯色圆环进度条-继承QWidget"><a href="#重绘paint之纯色圆环进度条-继承QWidget" class="headerlink" title="重绘paint之纯色圆环进度条(继承QWidget)"></a>重绘paint之纯色圆环进度条(继承QWidget)</h3><p>图中第二个，这是单纯用程序画出来的，没有贴图，在画出底图的圆以及上层的圆弧后，在上层再画一个透明的圆，相当于遮罩：</p>
<pre><code>void RingsProgressbar::paintEvent(QPaintEvent *)
{
    QPainter p(this);
    p.setRenderHint(QPainter::Antialiasing);

    m_rotateAngle = 360*m_persent/100;

    int side = qMin(width(), height());
    QRectF outRect(0, 0, side, side);
    QRectF inRect(20, 20, side-40, side-40);
    QString valueStr = QString(&quot;%1%&quot;).arg(QString::number(m_persent));

    //画外圆
    p.setPen(Qt::NoPen);
    p.setBrush(QBrush(QColor(97, 117, 118)));
    p.drawEllipse(outRect);
    p.setBrush(QBrush(QColor(255, 107, 107)));
    p.drawPie(outRect, (90-m_rotateAngle)*16, m_rotateAngle*16);
    //画遮罩
    p.setBrush(palette().window().color());
    p.drawEllipse(inRect);
    //画文字
    QFont f = QFont(&quot;Microsoft YaHei&quot;, 15, QFont::Bold);
    p.setFont(f);
    p.setFont(f);
    p.setPen(QColor(&quot;#555555&quot;));
    p.drawText(inRect, Qt::AlignCenter, valueStr);
}
</code></pre><h3 id="重绘paint之贴图圆环进度条-继承QWidget"><a href="#重绘paint之贴图圆环进度条-继承QWidget" class="headerlink" title="重绘paint之贴图圆环进度条(继承QWidget)"></a>重绘paint之贴图圆环进度条(继承QWidget)</h3><p>图中第三个，在玩第二种进度条的时候，意外发现drawPie()设置笔刷后可以直接画圆弧，这种骚操作 不试试还真不知道：</p>
<pre><code>void RingsMapProgressbar::paintEvent(QPaintEvent *)
{
    QPainter p(this);
    p.setRenderHint(QPainter::Antialiasing);

    m_rotateAngle = 360*m_persent/100;

    int side = qMin(width(), height());
    QRectF outRect(0, 0, side, side);
    QRectF inRect(20, 20, side-40, side-40);
    QString valueStr = QString(&quot;%1%&quot;).arg(QString::number(m_persent));

    //画底圆
    p.setPen(Qt::NoPen);
    QPixmap backMap = QPixmap(&quot;:/resource/progress_back.png&quot;);
    p.drawPixmap(outRect, backMap, outRect);
    //画内弧
    QPixmap frontMap = QPixmap(&quot;:/resource/progress_front.png&quot;);
    p.setBrush(QBrush(frontMap));
    p.drawPie(outRect, (90-m_rotateAngle)*16, m_rotateAngle*16);
    //画文字
    QFont f = QFont(&quot;Microsoft YaHei&quot;, 15, QFont::Bold);
    p.setFont(f);
    p.setPen(QColor(&quot;#DDDDDD&quot;));
    p.drawText(inRect, Qt::AlignCenter, valueStr);
}
</code></pre><h3 id="重绘paint之属性动画进度条-继承QWidget"><a href="#重绘paint之属性动画进度条-继承QWidget" class="headerlink" title="重绘paint之属性动画进度条(继承QWidget)"></a>重绘paint之属性动画进度条(继承QWidget)</h3><p>图中第4个，上面3个都是用程序控制显示进度的，最后一个是直接将进度条动画导出成序列帧图片，播放动画的形式来画进度条。这种方式主要是在某些等待操作以及需要进度条动画有曲线的时候用的，前提是你要会做动画和导出序列帧哦(⊙o⊙)：</p>
<pre><code>AnimationProgressbar::AnimationProgressbar(QWidget *parent) : QWidget(parent),
    m_animaindex(0),
    m_animaTotal(30),
    m_persent(0)
{
    QPixmap aniMap(&quot;:/resource/sequence_animate.png&quot;);

    for(int i=0; i&lt;m_animaTotal; i++){
        m_animalist &lt;&lt; aniMap.copy(i*(aniMap.width()/m_animaTotal), 0, aniMap.width()/m_animaTotal, aniMap.height());
    }

    m_animation=new QPropertyAnimation(this,&quot;&quot;);
    m_animation-&gt;setStartValue(0);
    m_animation-&gt;setEndValue(m_animaTotal - 1);
    m_animation-&gt;setDuration(2000);
    m_animation-&gt;setLoopCount(-1);
    connect(m_animation,SIGNAL(valueChanged(QVariant)),this,SLOT(slot_valuechange(QVariant)));
}

void AnimationProgressbar::startAnimation()
{
    update();

    m_animation-&gt;start();
}

void AnimationProgressbar::paintEvent(QPaintEvent *)
{
    QPainter p(this);
    p.setRenderHint(QPainter::SmoothPixmapTransform);

    int side = qMin(width(), height());
    QRect outRect(0, 0, side, side);
    QRect inRect(20, 20, side-40, side-40);
    QString valueStr = QString(&quot;%1%&quot;).arg(QString::number(m_persent));

    //画圆环
    p.drawPixmap(outRect, m_animalist.at(m_animaindex));

    //画文字
    QFont f = QFont(&quot;Microsoft YaHei&quot;, 15, QFont::Bold);
    p.setFont(f);
    p.setPen(QColor(&quot;#555555&quot;));
    p.drawText(inRect, Qt::AlignCenter, valueStr);
}

void AnimationProgressbar::slot_valuechange(QVariant var)
{
    m_animaindex = var.toInt();
    m_persent = m_animaindex*100 / m_animaTotal;

    update();
}
</code></pre><h2 id="进度条栗子"><a href="#进度条栗子" class="headerlink" title="进度条栗子"></a>进度条栗子</h2><p>代码仓库在这里-&gt;<a href="https://github.com/Longxr/QtCustomProgressbar" target="_blank" rel="noopener">Github链接地址</a>，喜欢的话点下star哦~</p>
</the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QProgressbar </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt之动画效果]]></title>
      <url>https://longxuan.ren/2017/08/16/Qt-Animation/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要> Qt自带的动画框架用来做简单的控件动画效果是比较简单易用的，像是对控件的位移、缩放、不透明度这些来做动画效果。<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="动画框架结构"><a href="#动画框架结构" class="headerlink" title="动画框架结构"></a>动画框架结构</h2><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Animation_01.png" alt="动画框架结构"></p>
<p>动画框架由基类QAbstractAnimation以及它的两个子类QVariantAnimation、QAnimationGroup组成。基础动画由QVariantAnimation的子类QPropertyAnimation来设置，再通过将多个QPropertyAnimation和QPauseAnimation组合成为动画组（QParallelAnimationGroup、QSequentialAnimationGroup），完成一个连续的动画。</p>
<h2 id="QPropertyAnimation"><a href="#QPropertyAnimation" class="headerlink" title="QPropertyAnimation"></a>QPropertyAnimation</h2><p>QPropertyAnimation类能够修改Qt的属性值，如pos、geometry等属性。设置好动画的初值和末值，以及持续的时间后，一个属性动画就基本完成了。</p>
<h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p>通过修改控件的geometry属性可以实现缩放效果，也可以实现位移的动画，该属性的前两个值确定了控件左上角的位置，后两个值确定了控件的大小。</p>
<pre><code>//scale
    QPropertyAnimation *pScaleAnimation1 = new QPropertyAnimation(ui-&gt;scaleButton, &quot;geometry&quot;);
    pScaleAnimation1-&gt;setDuration(1000);
    pScaleAnimation1-&gt;setStartValue(QRect(190, 230, 0, 0));
    pScaleAnimation1-&gt;setEndValue(QRect(120, 160, 140, 140));
</code></pre><h3 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h3><p>如果只是需要位移动画的话，修改控件的pos属性即可。pos属性就是控件的左上角所在的位置。</p>
<pre><code>//pos
    QPropertyAnimation *pPosAnimation1 = new QPropertyAnimation(ui-&gt;posButton, &quot;pos&quot;);
    pPosAnimation1-&gt;setDuration(1000);
    pPosAnimation1-&gt;setStartValue(QPoint(360, 160));
    pPosAnimation1-&gt;setEndValue(QPoint(360, 350));
    pPosAnimation1-&gt;setEasingCurve(QEasingCurve::InOutQuad);
</code></pre><h3 id="不透明度"><a href="#不透明度" class="headerlink" title="不透明度"></a>不透明度</h3><p>Qt的控件没有单独的透明度属性，要修改控件的透明度可以通过QGraphicsOpacityEffect类来实现。</p>
<pre><code>    //opacity
    QGraphicsOpacityEffect *pButtonOpacity = new QGraphicsOpacityEffect(this);
    pButtonOpacity-&gt;setOpacity(1);
    ui-&gt;opasityButton-&gt;setGraphicsEffect(pButtonOpacity);

    QPropertyAnimation *pOpacityAnimation1 = new QPropertyAnimation(pButtonOpacity, &quot;opacity&quot;);
    pOpacityAnimation1-&gt;setDuration(1000);
    pOpacityAnimation1-&gt;setStartValue(1);
    pOpacityAnimation1-&gt;setEndValue(0);
</code></pre><h3 id="动画曲线"><a href="#动画曲线" class="headerlink" title="动画曲线"></a>动画曲线</h3><p>动画还可以设置时间的插值曲线，默认是linear，即线性运动，通过设置QEasingCurve即可。Qt提供了40种已经定义好的曲线（如果有需要也可以自定义曲线）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Animation_02.png" alt="动画曲线"></p>
<pre><code>pScaleAnimation1-&gt;setEasingCurve(QEasingCurve::InOutQuad);
</code></pre><h2 id="QSequentialAnimationGroup"><a href="#QSequentialAnimationGroup" class="headerlink" title="QSequentialAnimationGroup"></a>QSequentialAnimationGroup</h2><h3 id="串行动画分组"><a href="#串行动画分组" class="headerlink" title="串行动画分组"></a>串行动画分组</h3><p>通过将QPropertyAnimation或者QPauseAnimation加入，构成一个按加入顺序依次播放的动画组，动画组的总时长是各个加入动画的总和。</p>
<pre><code>    QSequentialAnimationGroup *pPosGroup = new QSequentialAnimationGroup(this);
    pPosGroup-&gt;addPause(500);
    pPosGroup-&gt;addAnimation(pPosAnimation1);
</code></pre><h3 id="往返运动"><a href="#往返运动" class="headerlink" title="往返运动"></a>往返运动</h3><p>Qt的动画可以设置循环次数，默认的循环是从头再播放一遍，往返运动可以在一个串行动画组中加入初值末值相反的一组动画来实现。</p>
<h2 id="QParallelAnimationGroup"><a href="#QParallelAnimationGroup" class="headerlink" title="QParallelAnimationGroup"></a>QParallelAnimationGroup</h2><h3 id="并行动画组"><a href="#并行动画组" class="headerlink" title="并行动画组"></a>并行动画组</h3><p>加入并行动画组的动画会同时播放，动画组的总时长是最长的动画所需的时间。</p>
<pre><code>    m_group = new QParallelAnimationGroup(this);
    m_group-&gt;addAnimation(pScaleGroup);
    m_group-&gt;addAnimation(pPosGroup);
    m_group-&gt;addAnimation(pOpacityGroup);
</code></pre><h3 id="延时播放"><a href="#延时播放" class="headerlink" title="延时播放"></a>延时播放</h3><p>在串行动画组的开始先加入一个QPauseAnimation，再将Pause不同的串行动画组加入并行动画组就可以实现延时效果了。</p>
<h3 id="动画方向"><a href="#动画方向" class="headerlink" title="动画方向"></a>动画方向</h3><p>默认动画是从开始到结束这个方向播放的， 可以设置为从结束到开始播放。</p>
<pre><code>m_group-&gt;setDirection(QAbstractAnimation::Backward);
</code></pre><h2 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h2><p>综合几个小栗子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-Animation_03.gif" alt="动画效果"></p>
<p>举个栗子:-&gt;<a href="https://github.com/Longxr/QtAnimationDemo" target="_blank" rel="noopener">Github链接地址</a></p>
</the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QPropertyAnimation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt之QListView使用]]></title>
      <url>https://longxuan.ren/2017/08/10/Qt-ListView/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>记录下使用QListView遇到的各种问题<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<p>QListView可以用来以列表的形式展示数据，在Qt中使用model/View结构来管理数据与视图的关系，model负责数据的存取，数据的交互通过delegate来实现。</p>
<h2 id="添加数据模型"><a href="#添加数据模型" class="headerlink" title="添加数据模型"></a>添加数据模型</h2><blockquote>
<p>QT提供了一些现成的models用于处理数据项：<br>QStringListModel 用于存储简单的QString列表。<br>QStandardItemModel 管理复杂的树型结构数据项，每项都可以包含任意数据。<br>QDirModel  提供本地文件系统中的文件与目录信息。<br>QSqlQueryModel, QSqlTableModel,QSqlRelationTableModel用来访问数据库。</p>
</blockquote>
<p>使用Qt自带的模型类<code>QStandardItemModel</code>即可。模型中的每个数据项都有一个与之对应的role来存储某一类数据。需要存取自定义数据可以使用UserRole，UserRole+1…</p>
<p>对于自定义数据类型，如果要使用QVariant，就必须使用Q_DECLARE_METATYPE注册。</p>
<pre><code>struct ItemData{
    QString name;
    QString tel;
};

Q_DECLARE_METATYPE(ItemData)
</code></pre><h3 id="单一数据存取"><a href="#单一数据存取" class="headerlink" title="单一数据存取"></a>单一数据存取</h3><pre><code>//存
Item-&gt;setData(itemStatus,Qt::UserRole);  // 单一存取

//取
ItemStatus status = (ItemStatus)(index.data(Qt::UserRole).toInt());
</code></pre><h3 id="结构体数据存取"><a href="#结构体数据存取" class="headerlink" title="结构体数据存取"></a>结构体数据存取</h3><pre><code>//存
Item-&gt;setData(QVariant::fromValue(itemData),Qt::UserRole+1);//整体存取

//取
QVariant variant = index.data(Qt::UserRole+1);
ItemData data = variant.value&lt;ItemData&gt;();
</code></pre><h2 id="自定义delegate"><a href="#自定义delegate" class="headerlink" title="自定义delegate"></a>自定义delegate</h2><p>模型的交互和绘制通过自定义delegate来实现，暂时没用到交互，先说下item的绘制。继承了QStyledItemDelegate后，重写paint函数处理item的样式，以及sizeHint函数返回item的大小：</p>
<h3 id="绘制item"><a href="#绘制item" class="headerlink" title="绘制item"></a>绘制item</h3><pre><code>void ItemDelegate::paint(QPainter *painter, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const
{


    if(index.isValid())
    {
        painter-&gt;save();

        ItemStatus status = (ItemStatus)(index.data(Qt::UserRole).toInt());

        QVariant variant = index.data(Qt::UserRole+1);
        ItemData data = variant.value&lt;ItemData&gt;();

        QStyleOptionViewItem viewOption(option);//用来在视图中画一个item

        QRectF rect;
        rect.setX(option.rect.x());
        rect.setY(option.rect.y());
        rect.setWidth( option.rect.width()-1);
        rect.setHeight(option.rect.height()-1);

        //QPainterPath画圆角矩形
        const qreal radius = 7;
        QPainterPath path;
        path.moveTo(rect.topRight() - QPointF(radius, 0));
        path.lineTo(rect.topLeft() + QPointF(radius, 0));
        path.quadTo(rect.topLeft(), rect.topLeft() + QPointF(0, radius));
        path.lineTo(rect.bottomLeft() + QPointF(0, -radius));
        path.quadTo(rect.bottomLeft(), rect.bottomLeft() + QPointF(radius, 0));
        path.lineTo(rect.bottomRight() - QPointF(radius, 0));
        path.quadTo(rect.bottomRight(), rect.bottomRight() + QPointF(0, -radius));
        path.lineTo(rect.topRight() + QPointF(0, radius));
        path.quadTo(rect.topRight(), rect.topRight() + QPointF(-radius, -0));

        if(option.state.testFlag(QStyle::State_Selected))
        {
            painter-&gt;setPen(QPen(Qt::blue));
            painter-&gt;setBrush(QColor(229, 241, 255));
            painter-&gt;drawPath(path);
        }
        else if(option.state.testFlag(QStyle::State_MouseOver))
        {
            painter-&gt;setPen(QPen(Qt::green));
            painter-&gt;setBrush(Qt::NoBrush);
            painter-&gt;drawPath(path);
        }
        else{
            painter-&gt;setPen(QPen(Qt::gray));
            painter-&gt;setBrush(Qt::NoBrush);
            painter-&gt;drawPath(path);
        }

        //绘制数据位置
        QRect NameRect = QRect(rect.left() +10, rect.top()+10, rect.width()-30, 20);
        QRect circle = QRect(NameRect.right(), rect.top()+10, 10, 10);
        QRect telRect = QRect(rect.left() +10, rect.bottom()-25, rect.width()-10, 20);


        switch (status) {
        case S_RED:
            painter-&gt;setBrush(Qt::red);
            painter-&gt;setPen(QPen(Qt::red));
            break;
        case S_BLUE:
            painter-&gt;setBrush(Qt::blue);
            painter-&gt;setPen(QPen(Qt::blue));
            break;
        case S_YELLOW:
            painter-&gt;setBrush(Qt::yellow);
            painter-&gt;setPen(QPen(Qt::yellow));
            break;
        }

        painter-&gt;drawEllipse(circle);     //画圆圈

        painter-&gt;setPen(QPen(Qt::black));
        painter-&gt;setFont(QFont(&quot;Times&quot;, 12, QFont::Bold));
        painter-&gt;drawText(NameRect,Qt::AlignLeft,data.name); //绘制名字

        painter-&gt;setPen(QPen(Qt::gray));
        painter-&gt;setFont(QFont(&quot;Times&quot;, 10));
        painter-&gt;drawText(telRect,Qt::AlignLeft,data.tel); //绘制电话

        painter-&gt;restore();
    }
}

QSize ItemDelegate::sizeHint(const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const
{
    return QSize(160, 60);
}
</code></pre><h3 id="设置item不同状态下的样式"><a href="#设置item不同状态下的样式" class="headerlink" title="设置item不同状态下的样式"></a>设置item不同状态下的样式</h3><p>在paint函数中，还可以获得当前item的状态，并设置不同的样式：</p>
<pre><code> if(option.state.testFlag(QStyle::State_Selected)) //选中状态
        {
            painter-&gt;setPen(QPen(Qt::blue));
            painter-&gt;setBrush(QColor(229, 241, 255));
            painter-&gt;drawPath(path);
        }
        else if(option.state.testFlag(QStyle::State_MouseOver))//鼠标划过状态
        {
            painter-&gt;setPen(QPen(Qt::green));
            painter-&gt;setBrush(Qt::NoBrush);
            painter-&gt;drawPath(path);
        }
        else{
            painter-&gt;setPen(QPen(Qt::gray));
            painter-&gt;setBrush(Qt::NoBrush);
            painter-&gt;drawPath(path);
        }
</code></pre><p>设置好模型后，再对QListView进行下属性设置：</p>
<pre><code>    ui-&gt;listView-&gt;setItemDelegate(m_delegate);       //为视图设置委托
    ui-&gt;listView-&gt;setSpacing(15);                   //为视图设置控件间距
    ui-&gt;listView-&gt;setModel(m_model);                  //为委托设置模型
    ui-&gt;listView-&gt;setViewMode(QListView::IconMode); //设置Item图标显示
    ui-&gt;listView-&gt;setDragEnabled(false); 
</code></pre><p>模型的数据和展示都处理好后，运行效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-ListView_01.png" alt="listview展示"></p>
<h2 id="过滤item"><a href="#过滤item" class="headerlink" title="过滤item"></a>过滤item</h2><p>Qt中提供了一个方便处理模型排序和过滤的类<code>QSortFilterProxyModel</code>，通过他可以非常方便的处理我们的model。将QListView展示的model设置成代理模型：</p>
<pre><code>    ui-&gt;listView-&gt;setItemDelegate(m_delegate);       //为视图设置委托
    ui-&gt;listView-&gt;setSpacing(15);                   //为视图设置控件间距
    m_proxyModel = new QSortFilterProxyModel(ui-&gt;listView);
    m_proxyModel-&gt;setSourceModel(m_model);
    m_proxyModel-&gt;setFilterRole(Qt::UserRole);
    m_proxyModel-&gt;setDynamicSortFilter(true);
    ui-&gt;listView-&gt;setModel(m_proxyModel);                  //为委托设置模型
    ui-&gt;listView-&gt;setViewMode(QListView::IconMode); //设置Item图标显示
    ui-&gt;listView-&gt;setDragEnabled(false);            //控件不允许拖动
</code></pre><p>其中，<code>m_proxyModel-&gt;setFilterRole(Qt::UserRole);</code>设置根据模型的某一项数据来处理模型的过滤。proxyModel可以设置过滤的方式，根据QString或者正则表达式来过滤：</p>
<pre><code>m_proxyModel-&gt;setFilterFixedString(QString::number(S_RED));//根据字符串过滤
m_proxyModel-&gt;setFilterRegExp(QRegExp(&quot;^[0|2]$&quot;)); //根据正则表达式过滤
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-ListView_02.png" alt="过滤模型"></p>
<h2 id="获取选中item"><a href="#获取选中item" class="headerlink" title="获取选中item"></a>获取选中item</h2><p>对于列表中item的操作，可以是在delegate中处理交互事件，也可以通过QListView获取到所有选中item的QModelIndex，然后对模型本身进行修改。这里我选择的后者:</p>
<pre><code>QModelIndexList modelIndexList = ui-&gt;listView-&gt;selectionModel()-&gt;selectedIndexes();

</code></pre><h3 id="设置多选"><a href="#设置多选" class="headerlink" title="设置多选"></a>设置多选</h3><p>将QListView的<code>selectionBehavior</code>设置成<code>MultiSelection</code>即可。</p>
<p>对于多选的时候，模型的修改有一个坑。在设置了代理模型后，由于开启了动态排序模式，如果修改代理模型的数据，在第一个item修改数据后可能就不在当前过滤模型中，会被过滤掉，后面的item的QModelIndex就会变化，导致后续的修改失败。</p>
<blockquote>
<p>dynamicSortFilter : bool<br>This property holds whether the proxy model is dynamically sorted and filtered whenever the contents of the source model change.<br>Note that you should not update the source model through the proxy model when dynamicSortFilter is true. For instance, if you set the proxy model on a QComboBox, then using functions that update the model, e.g., addItem(), will not work as expected. An alternative is to set dynamicSortFilter to false and call sort() after adding items to the QComboBox.<br>The default value is true.</p>
</blockquote>
<p>有两个方法处理这个坑，一是不修改代理模型，修改源模型的数据。二是在修改模型数据的时候关闭代理模型的动态排序功能。</p>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><pre><code>QModelIndexList sourceIndexList;
    foreach (QModelIndex modelIndex, modelIndexList){
        sourceIndexList&lt;&lt;m_proxyModel-&gt;mapToSource(modelIndex); //获取源model的modelIndex
    }

//    g_proxyModel-&gt;setDynamicSortFilter(false);
    foreach (QModelIndex sourceIndex, sourceIndexList){
        ItemStatus status = (ItemStatus)(sourceIndex.data(Qt::UserRole).toInt());
        qDebug() &lt;&lt; &quot;Index : &quot; &lt;&lt; sourceIndex.row();

        switch (status) {
            case S_RED:
                redNum--;
                break;
            case S_BLUE:
                blueNum--;
                break;
            case S_YELLOW:
                yellowNum--;
                break;
        }

        status = S_RED;
        redNum++;

        m_model-&gt;setData(sourceIndex,status,Qt::UserRole);
    }
//    g_proxyModel-&gt;setDynamicSortFilter(true);
</code></pre><p>弄完大概是酱紫的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-ListView_03.gif" alt="最终效果"></p>
<p>Demo在这里:-&gt;<a href="https://github.com/Longxr/QListViewDemo" target="_blank" rel="noopener">Github链接地址</a>。</p>
</the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QListView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt自定义Dialog]]></title>
      <url>https://longxuan.ren/2017/07/29/Qt-CustomDialog/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>自定义Qt对话框Demo<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>



<h2 id="默认对话框"><a href="#默认对话框" class="headerlink" title="默认对话框"></a>默认对话框</h2><p>Qt默认的对话框是系统自带的样式，不同版本的windows也有些许不同，如果希望风格统一的话，这时候就需要自定义一个属于自己的对话框了</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-CustomDialog_01.png" alt="系统自带"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-CustomDialog_02.png" alt="自定义样式"></p>
<h2 id="新建Qt设计师类"><a href="#新建Qt设计师类" class="headerlink" title="新建Qt设计师类"></a>新建Qt设计师类</h2><p>虽然是自定义界面，但是有一个.ui文件放置按钮还是要方便些，如果是直接新建一个C++类文件就需要在代码中添加相关的控件了</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-CustomDialog_03.png" alt="新建设计师类"></p>
<h2 id="去除默认的样式"><a href="#去除默认的样式" class="headerlink" title="去除默认的样式"></a>去除默认的样式</h2><p>在构造函数中加上：</p>
<pre><code>setAttribute(Qt::WA_TranslucentBackground, true);
        setWindowFlags(Qt::Window | Qt::FramelessWindowHint
                       | Qt::WindowSystemMenuHint | Qt::WindowMinimizeButtonHint
                       | Qt::WindowMaximizeButtonHint);
</code></pre><p>就把默认的标题栏、背景等给去掉了。现在运行的话背景是透明的，除了自己加的控件外，其他啥也没有。</p>
<h2 id="重写paintEvent"><a href="#重写paintEvent" class="headerlink" title="重写paintEvent"></a>重写paintEvent</h2><p>自己对于Dialog的界面有什么需求，可以在paintEvent函数中添加。例如，我想设置边框为圆角，在文本输入框上下各有一条分割线：</p>
<pre><code>void LoginDialog::paintEvent(QPaintEvent *event)
{
    QPainterPath path;
    path.setFillRule(Qt::WindingFill);
    QRect rect = QRect(0, 0, this-&gt;width(), this-&gt;height());
    path.addRoundRect(rect,10,10);

    QPainter painter(this);
    painter.setRenderHint(QPainter::Antialiasing, true);
    painter.fillPath(path, QBrush(Qt::white));
    painter.setPen(Qt::gray);
    painter.drawPath(path);

    painter.drawLine(rect.left()+40, 60, rect.right()-40, 60);
    painter.drawLine(rect.left()+40, rect.bottom()-70, rect.right()-40, rect.bottom()-70);
}
</code></pre><h1 id="重写鼠标事件"><a href="#重写鼠标事件" class="headerlink" title="重写鼠标事件"></a>重写鼠标事件</h1><p>由于默认的情况被我们去掉了，此时对话框是不能移动的，需要重写鼠标事件，函数声明：</p>
<pre><code>void mousePressEvent(QMouseEvent *event) Q_DECL_OVERRIDE;
void mouseReleaseEvent(QMouseEvent *event) Q_DECL_OVERRIDE;
void mouseMoveEvent(QMouseEvent *event) Q_DECL_OVERRIDE;
</code></pre><p>具体实现：</p>
<pre><code>void LoginDialog::paintEvent(QPaintEvent *event)
{
    QPainterPath path;
    path.setFillRule(Qt::WindingFill);
    QRect rect = QRect(0, 0, this-&gt;width(), this-&gt;height());
    path.addRoundRect(rect,10,10);

    QPainter painter(this);
    painter.setRenderHint(QPainter::Antialiasing, true);
    painter.fillPath(path, QBrush(Qt::white));
    painter.setPen(Qt::gray);
    painter.drawPath(path);

    painter.drawLine(rect.left()+40, 60, rect.right()-40, 60);
    painter.drawLine(rect.left()+40, rect.bottom()-70, rect.right()-40, rect.bottom()-70);
}

void LoginDialog::mousePressEvent(QMouseEvent *event)
{

    if( event-&gt;button() == Qt::LeftButton){
        m_Press = event-&gt;globalPos();
        leftBtnClk = true;
    }
    event-&gt;ignore();//表示继续向下传递事件，其他的控件还可以去获取
}

void LoginDialog::mouseReleaseEvent(QMouseEvent *event)
{

    if( event-&gt;button() == Qt::LeftButton ){
        leftBtnClk = false;
    }
    event-&gt;ignore();
}

void LoginDialog::mouseMoveEvent(QMouseEvent *event)
{
    if( leftBtnClk ){
        m_Move = event-&gt;globalPos();
        this-&gt;move( this-&gt;pos() + m_Move - m_Press );
        m_Press = m_Move;
    }
    event-&gt;ignore();
}
</code></pre><h2 id="添加自己的控件"><a href="#添加自己的控件" class="headerlink" title="添加自己的控件"></a>添加自己的控件</h2><p>之后就像是在用默认的Dialog一样，在.ui中添加需要的控件，以及需要的信号/槽函数这些了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Qt-CustomDialog_04.png" alt="界面设计"></p>
<p>除了重绘的背景之外，其他的控件都可以在ui文件里添加。附上<a href="https://github.com/Longxr/QDialogDemo" target="_blank" rel="noopener">Github链接地址</a>。</p>
</the>]]></content>
      
        <categories>
            
            <category> Qt </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QDialog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Qt环境搭建]]></title>
      <url>https://longxuan.ren/2017/07/29/QtEnvironmentConstruction/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>在工作之前也是没有想过会用到Qt，既然任务交待下来了也没辙了╰（￣ ￣）╭<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>不管用哪种安装方法，装的时候都要登录下Qt的账号，所以还是先去<a href="https://login.qt.io/register" target="_blank" rel="noopener">官网注册</a>一个账号吧</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>下载这里就比较蛋疼了，官网找开源版本之前点来点去找了一圈，因为有针对企业的版本拿来卖的，开源版还要填什么协议啥的</p>
<h3 id="最新版本下载"><a href="#最新版本下载" class="headerlink" title="最新版本下载"></a>最新版本下载</h3><p>这里是<a href="https://www.qt.io/download-open-source/" target="_blank" rel="noopener">下载地址</a>，可以点最下面的<code>View All Downloads</code>展开不同平台的版本：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/QtEnvironmentConstruction_01.png" alt="最新版下载"></p>
<p>再选择自己要的版本就好了。这里要吐槽下，Online是在线安装，真心慢….</p>
<h3 id="历史版本下载"><a href="#历史版本下载" class="headerlink" title="历史版本下载"></a>历史版本下载</h3><blockquote>
<p>在和其他人协作的时候，就需要开发环境什么的保持一致了，要不然指不定报个什么鬼错出来…</p>
</blockquote>
<p>这里是<a href="http://download.qt.io/official_releases/qt/" target="_blank" rel="noopener">下载地址</a>，目前常用的版本都在这里吧，选自己需要的就行：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/QtEnvironmentConstruction_02.png" alt="历史版本下载"></p>
<h3 id="windows版本选择"><a href="#windows版本选择" class="headerlink" title="windows版本选择"></a>windows版本选择</h3><p>windows根据编译器的不同有两个选项，一个是VS，另一个是MinGw：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/QtEnvironmentConstruction_03.png" alt="windows版本选择"></p>
<h4 id="VS版"><a href="#VS版" class="headerlink" title="VS版"></a>VS版</h4><p>除了安装Qt，还要装好VS，另外还要<a href="http://download.qt.io/official_releases/vsaddin/" target="_blank" rel="noopener">下载vs-addin</a>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/QtEnvironmentConstruction_04.png" alt="相关下载"></p>
<p>作为一个懒人，我选择了底下这种更方便的方式….</p>
<h3 id="MinGw版"><a href="#MinGw版" class="headerlink" title="MinGw版"></a>MinGw版</h3><p>如果是第一次安装的话，推荐MinGw版，自带编译器，装上就能用，不需要额外配置：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/QtEnvironmentConstruction_05.png" alt="MinGw版"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载好后，点击安装会提示登录你的Qt账号，登录后就可以安装了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/QtEnvironmentConstruction_06.png" alt="安装"></p>
<p>Qt会自动将文档也装好的，可以在开始菜单下看到文档助手Assistant：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/QtEnvironmentConstruction_07.png" alt="文件目录"></p>
<p>也可以在写代码的时候在相关类名上按下F1，也会跳到相关文档（这个有时候不好使，在助手里搜比较方便）</p>
</the>]]></content>
      
        <categories>
            
            <category> 环境搭建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[AE操作小技巧-曲线篇]]></title>
      <url>https://longxuan.ren/2017/06/26/AE-Skills-Curves/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>咸鱼正式开始工作啦～好久都没写博客了，随便来点个人笔记的内容吧<a id="more"></a></excerpt></p>
<p><the rest of contents | 余下全文></the></p>
<h2 id="关键帧类型"><a href="#关键帧类型" class="headerlink" title="关键帧类型"></a>关键帧类型</h2><ol>
<li>默认情况下是菱形，代表关键帧直接动画的速度为匀速</li>
<li>漏斗型关键帧,两关键帧速度由零到快又到零 </li>
<li>右箭头关键帧,速度到这个关键帧缓缓变为零;左箭头关键帧则是速度从这个关键帧由零缓缓升高</li>
<li>圆形关键帧,是指三个关键帧中间那个为圆形的话会将这三个关键帧形成的两段不同速度进行柔缓连接 </li>
<li>正方形关键帧,停滞关键帧，需要设置冻结画面时间的时候会用到</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/AE-Skills-Curves_01.jpg" alt="关键帧类型"></p>
<p>还有一些少见的类型，可以对半看，菱形的一半就是线性运动，漏斗的一半就是缓入或缓出，正方形的一半就是这半边运动停滞，举个栗子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/AE-Skills-Curves_02.jpg" alt="组合类型"></p>
<p>这两个关键帧右边都是停止状态，左边分别是缓入和线性运动，组合起来1就是缓入再停止，2是匀速运动再停止</p>
<h2 id="关键帧操作-动画原理12则"><a href="#关键帧操作-动画原理12则" class="headerlink" title="关键帧操作(动画原理12则)"></a>关键帧操作(动画原理12则)</h2><blockquote>
<p>教科书般的教程，对于物体运动的原理非常值得看看，<a href="http://www.bilibili.com/video/av512214/" target="_blank" rel="noopener">B站地址戳这里</a></p>
</blockquote>
<ol>
<li>物体各个运动之间，关键帧要合理搭配，例如文字和摄像机移动，为了让观众看清文字，摄像机停留在文字上的时间要大于摄像机移动到下一个文字出现的时间</li>
<li>对于物体的运动，要制造一种渐入渐出的感觉，可以使用动作超过一点点再返回原处(弹性表达式)</li>
<li>预备动作，在要进行某个动作的时候，先反方向运动一点，快动作需要更长的预备动作方便观众知道接下来发生的动作，慢动作需要的预备动作较短</li>
<li>挤压和拉伸可以制造物体运动的形变效果，在运动过程中，顺着速度方向减少物体宽度，增加长度，保持体积不变，制造速度感；在运动结束的时候，顺着速度方向增加物体的宽度，减少长度，保持体积不变</li>
<li>夸张处理，例如约束感，调整图层，膨胀负值</li>
<li>动作跟随和重叠动作，多个物体运动，父物体带动子物体位置移动，调整子物体的旋转值，模拟现实中物体的保持惯性；另外，跟随动作是主对象影响子对象，要有一定的延迟</li>
<li>连续动作法，逐步设置关键帧，局部设置，设置即为最终效果<br>动作对应法，选一个能总览全局的视图，设置主要动作的关键帧，再返回原视图细调</li>
<li>二次动作强化主动作，考验创造力了233，根据自己物体的运动，想象一下物体某部分由于运动断裂、分离、抛出什么的</li>
<li>调位置曲线分离XYZ轴，尽量用最少的关键帧，保持曲线的平滑，分离还有一个好处就是将各个方向分解后可以使得关键帧偏移，将每个方向的动作在不同时刻发生</li>
</ol>
<h2 id="拉曲线"><a href="#拉曲线" class="headerlink" title="拉曲线"></a>拉曲线</h2><ol>
<li>关键帧差值为自动贝塞尔和连续贝塞尔的时候，两个句柄只能在同一直线上，如果要单独调整两边(一般都要，否则调一边影响另一边)，需要改为贝塞尔曲线(F9)</li>
<li>拉动句柄时，请不要点击曲线编辑器中的线，点击线会选中线两端两个关键帧，这时拉动句柄会对此线段之外两边的曲线还产生弯曲</li>
<li>位置没有XYZ三轴单独之前，遮罩变化和形状层变化(K路径的时候)，没有数值曲线可供调整，右键位置-&gt;单独尺寸，可以分离3个轴</li>
<li>要调不同物体的曲线需要另一个曲线作为参考的时候可以点击码表右边的曲线，使得曲线常驻曲线编辑器</li>
<li>位置XYZ轴对应曲线编辑器曲线red，green，blue三种颜色</li>
<li>Ctrl+鼠标左键，可以添加、删除锚点</li>
<li>选中位置关键帧后，Ctrl+Alt+拖动会拖出曲线手柄</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 影视后期 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo使用Travis CI自动化部署]]></title>
      <url>https://longxuan.ren/2017/05/10/Hexo-Travis-CI/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>通过使用Travis CI自动化部署，换电脑发布文章无需安装Hexo<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="偷懒是第一生产力"><a href="#偷懒是第一生产力" class="headerlink" title="偷懒是第一生产力"></a>偷懒是第一生产力</h2><p>使用Hexo写博客挺简单的，<code>hexo new &quot;articleName&quot;</code>在生成的md文件中就可以开始自己的写作了。不过每次都要进行发布的三部曲还是略显麻烦：</p>
<pre><code>hexo clean
hexo g
hexo d
</code></pre><p>这时候就到<code>Travis CI</code>出场的时候了，通过<code>Travis CI</code>可以实现当你将<code>commit</code>提交到Github后，会自动帮你进行这3步，你需要的就只是写文章-&gt;提交到Github，剩下的都是自动完成。</p>
<h2 id="Travis-CI使用"><a href="#Travis-CI使用" class="headerlink" title="Travis CI使用"></a>Travis CI使用</h2><blockquote>
<p><strong>Travis CI</strong>是在软件开发领域中的一个在线的，分布式的持续集成服务，用来构建及测试在GitHub托管的代码 。</p>
</blockquote>
<h3 id="登录Travis-CI"><a href="#登录Travis-CI" class="headerlink" title="登录Travis CI"></a>登录Travis CI</h3><p>使用Github账号登录<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI官网</a>，登录后在主界面点击<code>My Repositories</code>旁边的”+”号:<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Hexo-Travis-CI_01.png" alt="点击加号"></p>
<p>选择你在Github的放博客源码的仓库，打开左侧的开关：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Hexo-Travis-CI_02.png" alt="仓库选择"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Hexo-Travis-CI_03.png" alt="打开开关"></p>
<p>然后点下仓库那里的设置图标，进入设置的界面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Hexo-Travis-CI_04.png" alt="设置选项"></p>
<p>现在我们就设置好了需要构建的仓库了，Github的仓库指定的分支有commit后就会触发构建，但是目前还没有权限将构建的结果push到Github的仓库，这就需要在Github配置下Access Token了</p>
<h3 id="配置Github的Access-Token"><a href="#配置Github的Access-Token" class="headerlink" title="配置Github的Access Token"></a>配置Github的Access Token</h3><p>转到<a href="https://github.com/" target="_blank" rel="noopener">Github页面</a>，在<code>Setting</code>界面下选择<code>Personal access tokens</code>:</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Hexo-Travis-CI_05.png" alt="Personal access tokens"></p>
<p>生成一个新的tokens，设置如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Hexo-Travis-CI_06.png" alt="token配置"></p>
<blockquote>
<p>生成的时候先别急着关页面，配置信息随时可以更改，但是token只在这时候显示一次，页面关了之后找不到的，要的话只能重新生成一个</p>
</blockquote>
<p>将复制的token添加到<code>Travis CI</code>的环境变量中：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Hexo-Travis-CI_07.png" alt="添加环境变量"></p>
<p>这样<code>Travis CI</code>就有了访问Github的权限了</p>
<h3 id="配置-travis-yml"><a href="#配置-travis-yml" class="headerlink" title="配置.travis.yml"></a>配置.travis.yml</h3><p>我们设置了自动部署，但是具体要怎么部署还没有告诉<code>Travis CI</code>，接下来就来设置下相关的配置文件</p>
<h4 id="Github的仓库分支"><a href="#Github的仓库分支" class="headerlink" title="Github的仓库分支"></a>Github的仓库分支</h4><blockquote>
<p>如果将源码和生成的博客页面文件放在同一个分支也是可以的，不过每次一提交之后，<code>Travis CI</code>会自动化构建然后再push到这个分支。这样会显得比较乱 ，跟默认用hexo三部曲提交到Github差不多，想换台电脑编辑的时候不好找博客源代码，分成两个分支是不错的选择。</p>
</blockquote>
<p>由于Github的要求，要作为博客显示的分支必须是master，所以源码就另起了一个分支<code>blog</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Hexo-Travis-CI_08.png" alt="另一分支"></p>
<h4 id="添加-travis-yml文件"><a href="#添加-travis-yml文件" class="headerlink" title="添加.travis.yml文件"></a>添加.travis.yml文件</h4><p>在blog根目录新建一个.travis.yml文件，添加如下内容：</p>
<pre><code>language: node_js   #设置语言
node_js: stable     #设置相应的版本
cache:
    directories:
        - node_modules    #据说可以减少travis构建时间
before_install:
  - npm install -g hexo
  - npm install -g hexo-cli
install:
  - npm install   #安装hexo及插件
before_script:
  - npm install -g mocha
  - git clone --branch master https://github.com/Longxr/Longxr.github.io.git public
script:
  - hexo cl   #清除
  - hexo g   #生成
after_script:
  - cd ./public
  - git init
  - git config user.name &quot;longxr&quot;   #修改成自己的github用户名
  - git config user.email &quot;longxuanren@gmail.com&quot;   #修改成自己的GitHub邮箱
  - git add .
  - git commit -m &quot;update by Travis-CI&quot;
  - git push --force --quiet &quot;https://${GH_TOKEN}@${GH_REF}&quot; master:master #GH_token就是在travis中设置的token
branches:
  only:
  - blog  #只监测这个分支，一有动静就开始构建
env:
    global:
        - GH_REF: github.com/Longxr/Longxr.github.io.git
</code></pre><p>修改成你的仓库的配置就行了。设置完毕，就可以新建一篇文章测试下了～以后发文章的流程就是:<code>写文章-&gt;提交到Github</code>搞定！</p>
<h2 id="逼格添加"><a href="#逼格添加" class="headerlink" title="逼格添加"></a>逼格添加</h2><p>自动化构建服务还可以在README.md中加上一个构建状态的图标：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Hexo-Travis-CI_09.png" alt="build Stauts"></p>
<p>在自己的README.md中加一行：<br><code>[![Build Status](https://travis-ci.org/Longxr/Longxr.github.io.svg?branch=blog)](https://travis-ci.org/Longxr/Longxr.github.io)</code></p>
<blockquote>
<p>branch后设置为监测的分支，链接地址设置为<code>Travis CI</code>的仓库地址</p>
</blockquote>
<p>也可以在界面点击仓库名后面的状态图标获取链接代码，默认是master分支，记得改成你监测的分支，不然就会显示<code>unknown</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Hexo-Travis-CI_11.png" alt="获取状态图标链接"></p>
<blockquote>
<p>补充说明: blog分支README.md放在根目录就行，master分支README.md要放在博客目录的/source中</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://notes.iissnan.com/2016/publishing-github-pages-with-travis-ci/" target="_blank" rel="noopener">使用 Travis CI 自动更新 GitHub Pages</a></li>
<li><a href="https://xin053.github.io/2016/06/05/Travis%20CI自动部署Hexo博客到Github/" target="_blank" rel="noopener">Travis CI自动部署Hexo博客到Github</a></li>
<li><a href="https://chuyun.github.io/2016/10/06/Hexo-Travis-Automated%20build/" target="_blank" rel="noopener">Hexo使用TravisCI自动化构建</a></li>
<li><a href="http://blog.smallmuou.xyz/git/2016/03/22/可持续化集成Travis-CI入门教程.html" target="_blank" rel="noopener">可持续化集成Travis-CI入门教程</a></li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Travis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[bilibili区域限制解除的三种方法]]></title>
      <url>https://longxuan.ren/2017/05/08/BilibiliAreaRestriction/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>有的番由于某些原因，例如大陆禁播啦～版权被其他网站抢啦～B站的思路也是有意思，就买台湾地区的版权，大陆要看还得绕一圈<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<p>默认只给个界面（╯’ - ‘)╯︵ ┻━┻（B站：番我买了，会不会看就看你自己了）<br><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/BilibiliAreaRestriction_01.png" alt="默认是酱紫"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/BilibiliAreaRestriction_02.png" alt="莫名喜感"></p>
<h2 id="方法一-：安装浏览器脚本（PC）"><a href="#方法一-：安装浏览器脚本（PC）" class="headerlink" title="方法一 ：安装浏览器脚本（PC）"></a>方法一 ：安装浏览器脚本（PC）</h2><p>这个比较方便，去<a href="https://greasyfork.org/zh-CN/scripts/25718-解除b站区域限制" target="_blank" rel="noopener">下脚本的地方</a>，根据提示，先安装对应浏览器的脚本扩展：XXXmonkey</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/BilibiliAreaRestriction_03.png" alt="安装扩展"></p>
<p>扩展装好后就可以安装脚本了，第一次打开B站网页会提示授权啥的，同意下就好了</p>
<h2 id="方法二：安装哔哩聚合（PC、爪机）"><a href="#方法二：安装哔哩聚合（PC、爪机）" class="headerlink" title="方法二：安装哔哩聚合（PC、爪机）"></a>方法二：安装哔哩聚合（PC、爪机）</h2><p>这个也比较方便，尤其是爪机也有啊，<a href="https://www.bili.info" target="_blank" rel="noopener">下载地址戳这里</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/BilibiliAreaRestriction_04.png" alt="网站截图"></p>
<h2 id="方法三：挂VPN"><a href="#方法三：挂VPN" class="headerlink" title="方法三：挂VPN"></a>方法三：挂VPN</h2><p>这招虽然最稳，但是比较蛋疼的是得挂台湾的VPN，偏偏我用的SS没有台湾节点，墙都翻出去了，还看不到，淡淡的忧伤啊QAQ，所以要挂VPN的朋友注意看有没有台湾节点哈（从弹幕截图来看，倒是都在推荐天行和green这俩VPN，想试试的可以去看看）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/BilibiliAreaRestriction_05.png" alt="视频截图"></p>
</the>]]></content>
      
        <categories>
            
            <category> 操作技巧 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bilibili </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git使用ssh多账号配置]]></title>
      <url>https://longxuan.ren/2017/05/05/Git-ssh-MultiAccount/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>git通过ssh登录时，设置不同的登录账号<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="生成SSH-KEY"><a href="#生成SSH-KEY" class="headerlink" title="生成SSH KEY"></a>生成SSH KEY</h2><p> 终端输入：<code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code></p>
<p>然后会提示输入公钥的名字，一般就xxx_rsa就行(github_rsa)，生成SSH KEY的时候还要求输入私钥密码<code>&quot;│Enter passphrase (empty for no passphrase)</code>，没有特殊需求的话直接回车。密钥的密码什么的完全记不住，设置了以后八成是要重新生成一个密钥了</p>
<blockquote>
<p>有时候会把密钥生成到～／.ssh 的同级目录，最好将密钥移到.ssh文件夹里 </p>
</blockquote>
<h2 id="将SSH-私钥增加到ssh-agent"><a href="#将SSH-私钥增加到ssh-agent" class="headerlink" title="将SSH 私钥增加到ssh-agent"></a>将SSH 私钥增加到ssh-agent</h2><p><code>ssh-add ~/.ssh/github_rsa</code>， 这里会提示输入一次私钥的密码;提示文件不存在的话:</p>
<ol>
<li>记得去.ssh同级目录找找密钥是不是错放那儿了； </li>
<li>不识别～，改成全路径：<code>User/username/.ssh/github_rsa</code></li>
</ol>
<p>查看已经add的SSH KEY： <code>ssh-add -l；</code> </p>
<h2 id="将公钥粘贴到自己的github网页设置-服务器"><a href="#将公钥粘贴到自己的github网页设置-服务器" class="headerlink" title="将公钥粘贴到自己的github网页设置(服务器)"></a>将公钥粘贴到自己的github网页设置(服务器)</h2><ol>
<li><p>登录网页账号，点击头像-&gt;Setting-&gt;SSH and GPG key，将拷贝的公钥内容粘贴到New key的key里，顺便起个自己能区分的Label </p>
</li>
<li><p>当有多个账号需要登录服务器或者需要登录多个服务器时，就需要配置SSH的配置文件 </p>
</li>
</ol>
<h2 id="ssh的配置文件"><a href="#ssh的配置文件" class="headerlink" title="ssh的配置文件"></a>ssh的配置文件</h2><p>ssh client有两个配置文件，/etc/ssh/ssh_config和~/.ssh/config，前者是对所有用户，后者是针对某个用户，两个文件的格式是一样的 </p>
<pre><code>Host 名称(自己决定，方便输入记忆的) 
    HostName 主机名 
    User 登录的用户名 
</code></pre><p>假设有两个SSH帐号，一个是github的，一个是bitbucket的，私钥分别是github_rsa、bitbucket_rsa，可以这样写： </p>
<pre><code>#————GitHub————— 
Host longxr-github 
    HostName github.com 
    User longxr 
    IdentifyFile ~/.ssh/github_rsa 

#————Bitbucket———— 
Host longxr-bitbucket 
    HostName bitbucket.org 
    User longxr 
    IdentifyFile ~/.ssh/bitbucket_rsa 
</code></pre><blockquote>
<p>win10直接~/.ssh/github_rsa 就行，~是/c/Users/,没有冒号，也不用反斜杠….win7过来被坑人士</p>
</blockquote>
<h2 id="登录测试"><a href="#登录测试" class="headerlink" title="登录测试"></a>登录测试</h2><pre><code>ssh -T git@github.com 
ssh -T git@bitbucket.org 
</code></pre><p>bitbucket还可以：<code>ssh -T longxr-bitbucket</code>，<code>ssh -T git@longxr-bitbucket</code><br>github不能直接输Host，只能<code>ssh -T git@longxr-github</code> </p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><pre><code>ssh -T git@longxr-bitbucket 
logged in as longxr. 
ssh -T git@longxr-github 
Hi Longxr! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 
</code></pre></the>]]></content>
      
        <categories>
            
            <category> 环境搭建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
            <tag> ssh </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[oh-my-zsh git]]></title>
      <url>https://longxuan.ren/2017/04/25/oh-my-zsh-git/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>git Alias<a id="more"></a></excerpt></p>
<p><the rest of contents | 余下全文></the></p>
<blockquote>
<p>git是zsh自带插件，在~/.zshrc 中，加上plugins=(git)就能用</p>
</blockquote>
<h2 id="Aliases"><a href="#Aliases" class="headerlink" title="Aliases"></a>Aliases</h2><table>
<thead>
<tr>
<th style="text-align:left">Alias</th>
<th style="text-align:left">Command</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">g</td>
<td style="text-align:left">git</td>
</tr>
<tr>
<td style="text-align:left">ga</td>
<td style="text-align:left">git add</td>
</tr>
<tr>
<td style="text-align:left">gaa</td>
<td style="text-align:left">git add –all</td>
</tr>
<tr>
<td style="text-align:left">gapa</td>
<td style="text-align:left">git add –patch</td>
</tr>
<tr>
<td style="text-align:left">gb</td>
<td style="text-align:left">git branch</td>
</tr>
<tr>
<td style="text-align:left">gba</td>
<td style="text-align:left">git branch -a</td>
</tr>
<tr>
<td style="text-align:left">gbl</td>
<td style="text-align:left">git blame -b -w</td>
</tr>
<tr>
<td style="text-align:left">gbnm</td>
<td style="text-align:left">git branch –no-merged</td>
</tr>
<tr>
<td style="text-align:left">gbr</td>
<td style="text-align:left">git branch –remote</td>
</tr>
<tr>
<td style="text-align:left">gbs</td>
<td style="text-align:left">git bisect</td>
</tr>
<tr>
<td style="text-align:left">gbsb</td>
<td style="text-align:left">git bisect bad</td>
</tr>
<tr>
<td style="text-align:left">gbsg</td>
<td style="text-align:left">git bisect good</td>
</tr>
<tr>
<td style="text-align:left">gbsr</td>
<td style="text-align:left">git bisect reset</td>
</tr>
<tr>
<td style="text-align:left">gbss</td>
<td style="text-align:left">git bisect start</td>
</tr>
<tr>
<td style="text-align:left">gc</td>
<td style="text-align:left">git commit -v</td>
</tr>
<tr>
<td style="text-align:left">gc!</td>
<td style="text-align:left">git commit -v –amend</td>
</tr>
<tr>
<td style="text-align:left">gca</td>
<td style="text-align:left">git commit -v -a</td>
</tr>
<tr>
<td style="text-align:left">gcam</td>
<td style="text-align:left">git commit -a -m</td>
</tr>
<tr>
<td style="text-align:left">gca!</td>
<td style="text-align:left">git commit -v -a –amend</td>
</tr>
<tr>
<td style="text-align:left">gcan!</td>
<td style="text-align:left">git commit -v -a -s –no-edit –amend</td>
</tr>
<tr>
<td style="text-align:left">gcb</td>
<td style="text-align:left">git checkout -b</td>
</tr>
<tr>
<td style="text-align:left">gcf</td>
<td style="text-align:left">git config –list</td>
</tr>
<tr>
<td style="text-align:left">gcl</td>
<td style="text-align:left">git clone –recursive</td>
</tr>
<tr>
<td style="text-align:left">gclean</td>
<td style="text-align:left">git clean -df</td>
</tr>
<tr>
<td style="text-align:left">gcm</td>
<td style="text-align:left">git checkout master</td>
</tr>
<tr>
<td style="text-align:left">gcd</td>
<td style="text-align:left">git checkout develop</td>
</tr>
<tr>
<td style="text-align:left">gcmsg</td>
<td style="text-align:left">git commit -m</td>
</tr>
<tr>
<td style="text-align:left">gco</td>
<td style="text-align:left">git checkout</td>
</tr>
<tr>
<td style="text-align:left">gcount</td>
<td style="text-align:left">git shortlog -sn</td>
</tr>
<tr>
<td style="text-align:left">gcp</td>
<td style="text-align:left">git cherry-pick</td>
</tr>
<tr>
<td style="text-align:left">gcpa</td>
<td style="text-align:left">git cherry-pick –abort</td>
</tr>
<tr>
<td style="text-align:left">gcpc</td>
<td style="text-align:left">git cherry-pick –continue</td>
</tr>
<tr>
<td style="text-align:left">gcs</td>
<td style="text-align:left">git commit -S</td>
</tr>
<tr>
<td style="text-align:left">gd</td>
<td style="text-align:left">git diff</td>
</tr>
<tr>
<td style="text-align:left">gdca</td>
<td style="text-align:left">git diff –cached</td>
</tr>
<tr>
<td style="text-align:left">gdt</td>
<td style="text-align:left">git diff-tree –no-commit-id –name-only -r</td>
</tr>
<tr>
<td style="text-align:left">gdw</td>
<td style="text-align:left">git diff –word-diff</td>
</tr>
<tr>
<td style="text-align:left">gf</td>
<td style="text-align:left">git fetch</td>
</tr>
<tr>
<td style="text-align:left">gfa</td>
<td style="text-align:left">git fetch –all –prune</td>
</tr>
<tr>
<td style="text-align:left">gfo</td>
<td style="text-align:left">git fetch origin</td>
</tr>
<tr>
<td style="text-align:left">gg</td>
<td style="text-align:left">git gui citool</td>
</tr>
<tr>
<td style="text-align:left">gga</td>
<td style="text-align:left">git gui citool –amend</td>
</tr>
<tr>
<td style="text-align:left">ghh</td>
<td style="text-align:left">git help</td>
</tr>
<tr>
<td style="text-align:left">ggpull</td>
<td style="text-align:left">ggl</td>
</tr>
<tr>
<td style="text-align:left">ggpur</td>
<td style="text-align:left">ggu</td>
</tr>
<tr>
<td style="text-align:left">ggpush</td>
<td style="text-align:left">ggp</td>
</tr>
<tr>
<td style="text-align:left">ggsup</td>
<td style="text-align:left">git branch –set-upstream-to = origin/$(current_branch)</td>
</tr>
<tr>
<td style="text-align:left">gpsup</td>
<td style="text-align:left">git push –set-upstream origin $(current_branch)</td>
</tr>
<tr>
<td style="text-align:left">gignore</td>
<td style="text-align:left">git update-index –assume-unchanged</td>
</tr>
<tr>
<td style="text-align:left">git-svn-dcommit-push</td>
<td style="text-align:left">git svn dcommit &amp;&amp; git push github master:svntrunk</td>
</tr>
<tr>
<td style="text-align:left">gk</td>
<td style="text-align:left">\gitk –all –branches</td>
</tr>
<tr>
<td style="text-align:left">gke</td>
<td style="text-align:left">\gitk –all $(git log -g –pretty = format:%h)</td>
</tr>
<tr>
<td style="text-align:left">gl</td>
<td style="text-align:left">git pull</td>
</tr>
<tr>
<td style="text-align:left">glg</td>
<td style="text-align:left">git log –stat –color</td>
</tr>
<tr>
<td style="text-align:left">glgg</td>
<td style="text-align:left">git log –graph –color</td>
</tr>
<tr>
<td style="text-align:left">glgga</td>
<td style="text-align:left">git log –graph –decorate –all</td>
</tr>
<tr>
<td style="text-align:left">glgm</td>
<td style="text-align:left">git log –graph –max-count = 10</td>
</tr>
<tr>
<td style="text-align:left">glgp</td>
<td style="text-align:left">git log –stat –color -p</td>
</tr>
<tr>
<td style="text-align:left">glo</td>
<td style="text-align:left">git log –oneline –decorate –color</td>
</tr>
<tr>
<td style="text-align:left">glog</td>
<td style="text-align:left">git log –oneline –decorate –color –graph</td>
</tr>
<tr>
<td style="text-align:left">glol</td>
<td style="text-align:left">git log –graph –pretty = format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit</td>
</tr>
<tr>
<td style="text-align:left">glola</td>
<td style="text-align:left">git log –graph –pretty = format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit –all</td>
</tr>
<tr>
<td style="text-align:left">glp</td>
<td style="text-align:left">_git_log_prettily</td>
</tr>
<tr>
<td style="text-align:left">gm</td>
<td style="text-align:left">git merge</td>
</tr>
<tr>
<td style="text-align:left">gmom</td>
<td style="text-align:left">git merge origin/master</td>
</tr>
<tr>
<td style="text-align:left">gmt</td>
<td style="text-align:left">git mergetool –no-prompt</td>
</tr>
<tr>
<td style="text-align:left">gmtvim</td>
<td style="text-align:left">git mergetool –no-prompt –tool = vimdiff</td>
</tr>
<tr>
<td style="text-align:left">gmum</td>
<td style="text-align:left">git merge upstream/master</td>
</tr>
<tr>
<td style="text-align:left">gp</td>
<td style="text-align:left">git push</td>
</tr>
<tr>
<td style="text-align:left">gpd</td>
<td style="text-align:left">git push –dry-run</td>
</tr>
<tr>
<td style="text-align:left">gpoat</td>
<td style="text-align:left">git push origin –all &amp;&amp; git push origin –tags</td>
</tr>
<tr>
<td style="text-align:left">gpristine</td>
<td style="text-align:left">git reset –hard &amp;&amp; git clean -dfx</td>
</tr>
<tr>
<td style="text-align:left">gpu</td>
<td style="text-align:left">git push upstream</td>
</tr>
<tr>
<td style="text-align:left">gpv</td>
<td style="text-align:left">git push -v</td>
</tr>
<tr>
<td style="text-align:left">gr</td>
<td style="text-align:left">git remote</td>
</tr>
<tr>
<td style="text-align:left">gra</td>
<td style="text-align:left">git remote add</td>
</tr>
<tr>
<td style="text-align:left">grb</td>
<td style="text-align:left">git rebase</td>
</tr>
<tr>
<td style="text-align:left">grba</td>
<td style="text-align:left">git rebase –abort</td>
</tr>
<tr>
<td style="text-align:left">grbc</td>
<td style="text-align:left">git rebase –continue</td>
</tr>
<tr>
<td style="text-align:left">grbi</td>
<td style="text-align:left">git rebase -i</td>
</tr>
<tr>
<td style="text-align:left">grbm</td>
<td style="text-align:left">git rebase master</td>
</tr>
<tr>
<td style="text-align:left">grbs</td>
<td style="text-align:left">git rebase –skip</td>
</tr>
<tr>
<td style="text-align:left">grh</td>
<td style="text-align:left">git reset HEAD</td>
</tr>
<tr>
<td style="text-align:left">grhh</td>
<td style="text-align:left">git reset HEAD –hard</td>
</tr>
<tr>
<td style="text-align:left">grmv</td>
<td style="text-align:left">git remote rename</td>
</tr>
<tr>
<td style="text-align:left">grrm</td>
<td style="text-align:left">git remote remove</td>
</tr>
<tr>
<td style="text-align:left">grset</td>
<td style="text-align:left">git remote set-url</td>
</tr>
<tr>
<td style="text-align:left">gru</td>
<td style="text-align:left">git reset –</td>
</tr>
<tr>
<td style="text-align:left">grup</td>
<td style="text-align:left">git remote update</td>
</tr>
<tr>
<td style="text-align:left">grv</td>
<td style="text-align:left">git remote -v</td>
</tr>
<tr>
<td style="text-align:left">gsb</td>
<td style="text-align:left">git status -sb</td>
</tr>
<tr>
<td style="text-align:left">gsd</td>
<td style="text-align:left">git svn dcommit</td>
</tr>
<tr>
<td style="text-align:left">gsi</td>
<td style="text-align:left">git submodule init</td>
</tr>
<tr>
<td style="text-align:left">gsps</td>
<td style="text-align:left">git show –pretty = short –show-signature</td>
</tr>
<tr>
<td style="text-align:left">gsr</td>
<td style="text-align:left">git svn rebase</td>
</tr>
<tr>
<td style="text-align:left">gss</td>
<td style="text-align:left">git status -s</td>
</tr>
<tr>
<td style="text-align:left">gst</td>
<td style="text-align:left">git status</td>
</tr>
<tr>
<td style="text-align:left">gsta</td>
<td style="text-align:left">git stash save</td>
</tr>
<tr>
<td style="text-align:left">gstaa</td>
<td style="text-align:left">git stash apply</td>
</tr>
<tr>
<td style="text-align:left">gstd</td>
<td style="text-align:left">git stash drop</td>
</tr>
<tr>
<td style="text-align:left">gstl</td>
<td style="text-align:left">git stash list</td>
</tr>
<tr>
<td style="text-align:left">gstp</td>
<td style="text-align:left">git stash pop</td>
</tr>
<tr>
<td style="text-align:left">gstc</td>
<td style="text-align:left">git stash clear</td>
</tr>
<tr>
<td style="text-align:left">gsts</td>
<td style="text-align:left">git stash show –text</td>
</tr>
<tr>
<td style="text-align:left">gsu</td>
<td style="text-align:left">git submodule update</td>
</tr>
<tr>
<td style="text-align:left">gts</td>
<td style="text-align:left">git tag -s</td>
</tr>
<tr>
<td style="text-align:left">gunignore</td>
<td style="text-align:left">git update-index –no-assume-unchanged</td>
</tr>
<tr>
<td style="text-align:left">gup</td>
<td style="text-align:left">git pull –rebase</td>
</tr>
<tr>
<td style="text-align:left">gupv</td>
<td style="text-align:left">git pull –rebase -v</td>
</tr>
<tr>
<td style="text-align:left">glum</td>
<td style="text-align:left">git pull upstream master</td>
</tr>
<tr>
<td style="text-align:left">gvt</td>
<td style="text-align:left">git verify-tag</td>
</tr>
<tr>
<td style="text-align:left">gwch</td>
<td style="text-align:left">git whatchanged -p –abbrev-commit –pretty = medium</td>
</tr>
<tr>
<td style="text-align:left">gwip</td>
<td style="text-align:left">git add -A; git rm $(git ls-files –deleted) 2&gt; /dev/null; git commit -m “–wip–”</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> 操作技巧 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
            <tag> 快捷键 </tag>
            
            <tag> zsh </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Sublime插件React-Native篇]]></title>
      <url>https://longxuan.ren/2017/04/24/Sublime-React-Native/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>作为一个秒开的编辑器，用了就不想换呀，插件库也很强大，稍作配置就可以用了<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<blockquote>
<p>作为一个秒开的编辑器，用了就不想换呀，插件库也很强大，稍作配置就可以用了</p>
</blockquote>
<h2 id="本体"><a href="#本体" class="headerlink" title="本体"></a>本体</h2><p>Sublime免费的，只是偶尔弹窗一下,所以别折腾什么破解版了<br><a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">官网地址</a>,根据你的系统选择下载</p>
<h2 id="Package-Control"><a href="#Package-Control" class="headerlink" title="Package Control"></a>Package Control</h2><p>安装插件之前要先装下Package Control</p>
<h3 id="自动安装"><a href="#自动安装" class="headerlink" title="自动安装"></a>自动安装</h3><p>使用Ctrl+`快捷键或者通过View-&gt;Show Console菜单打开终端，粘贴如下代码：</p>
<pre><code>import urllib.request,os,hashlib; h = &#39;df21e130d211cfc94d9b0905775a7c0f&#39; + &#39;1e3d39e33b79698005270310898eea76&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &#39;http://packagecontrol.io/&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &#39;wb&#39; ).write(by)
</code></pre><p>如果终端安装报错的话，就改用手动安装</p>
<h3 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h3><ol>
<li>点击<code>Preferences &gt; Browse Packages</code>菜单</li>
<li>进入打开的目录的上层目录，然后再进入<code>Installed Packages/</code>目录</li>
<li>下载<a href="https://packagecontrol.io/Package%20Control.sublime-package" target="_blank" rel="noopener">Package Control.sublime-package</a>并复制到<code>Installed Packages/</code>目录</li>
<li>重启Sublime Text</li>
</ol>
<h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><blockquote>
<p>支持ES6， React.js, jsx代码高亮，对 JavaScript, jQuery 也有很好的扩展</p>
</blockquote>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>PC：Ctrl+shift+p<br>Mac：Cmd+shift+p<br>输入：<code>pci</code>，选择Package <code>Control:install package</code><br>加载出插件列表后，输入babel进行安装</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ol>
<li>打开.js, .jsx 后缀的文件;</li>
<li>找到菜单栏的view -&gt; Syntax -&gt; Open all with current extension as… -&gt; Babel -&gt; JavaScript (Babel)，选择babel为默认 javascript 打开syntax</li>
</ol>
<h3 id="React-ES6-Snippets"><a href="#React-ES6-Snippets" class="headerlink" title="React ES6 Snippets"></a>React ES6 Snippets</h3><blockquote>
<p>为react语法提示，sublime-react-es6支持es6语法, 另一个类似的插件ReactJS貌似是ES5的，敲出来的代码块方法都有function</p>
</blockquote>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>PC：Ctrl+shift+p<br>Mac：Cmd+shift+p<br>输入：<code>pci</code>，选择<code>Package Control:install package</code><br>加载出插件列表后，输入<code>React ES6 Snippets</code>进行安装</p>
<h4 id="支持的代码片段"><a href="#支持的代码片段" class="headerlink" title="支持的代码片段"></a>支持的代码片段</h4><pre><code>cdm→  componentDidMount: fn() { ... } 
cdup→  componentDidUpdate: fn(pp, ps) { ... } 
cs→  var cx = React.addons.classSet; 
cwm→  componentWillMount: fn() { ... } 
cwr→  componentWillReceiveProps: fn(np) { ... } 
cwu→  componentWillUpdate: fn(np, ns) { ... } 
cwun→  componentWillUnmount: fn() { ... } 
cx→  cx({ ... }) 
fdn→  React.findDOMNode(...) 
fup→  forceUpdate(...) 
gdp→  getDefaultProps: fn() { return {...} } 
gis→  getInitialState: fn() { return {...} } 
ism→  isMounted() 
props→  this.props. 
pt→  propTypes { ... } 
rcc→  component skeleton 
refs→  this.refs. 
ren→  render: fn() { return ... } 
scu→  shouldComponentUpdate: fn(np, ns) { ... } 
sst→  this.setState({ ... }) 
state→  this.state. 
</code></pre><h3 id="jsfmt"><a href="#jsfmt" class="headerlink" title="jsfmt"></a>jsfmt</h3><blockquote>
<p>格式化JS代码，jsformat也支持jsx格式化，但是在import的地方老是换行挺烦</p>
</blockquote>
<h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><p>PC：Ctrl+shift+p<br>Mac：Cmd+shift+p<br>输入：<code>pci</code>，选择<code>Package Control:install package</code><br>加载出插件列表后，输入<code>jsfmt</code>进行安装</p>
<h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><ul>
<li><p>添加jsx的相关配置</p>
<pre><code>cd ~/Library/Application\ Support/Sublime\ Text\ 3/Packages/jsfmt/
npm i esformatter@latest esformatter-jsx@latest
</code></pre></li>
<li><p>Preferences -&gt; Package Settings -&gt; Sublime JSFMT，<a href="https://github.com/ionutvmi/sublime-jsfmt" target="_blank" rel="noopener">添加代码</a>：</p>
<pre><code>{
// autoformat on save
&quot;autoformat&quot;: true,

// array of extensions for autoformat
&quot;extensions&quot;: [
  &quot;js&quot;,
  &quot;jsx&quot;,
  &quot;sublime-settings&quot;
],

// options for jsfmt
&quot;options&quot;: {
  &quot;preset&quot;: &quot;jquery&quot;,
  &quot;indent&quot;: {
    &quot;value&quot;: &quot;    &quot;
  },
  // plugins included
  &quot;plugins&quot;: [
    &quot;esformatter-jsx&quot;,
  ]
},

&quot;jsx&quot;: {
  &quot;formatJSX&quot;: true,
  // change these to your preferred values
  // refer to https://github.com/royriojas/esformatter-jsx#best-configuration for more options
  &quot;attrsOnSameLineAsTag&quot;: false,
  &quot;maxAttrsOnTag&quot;: 1,
  &quot;firstAttributeOnSameLine&quot;: false,
  &quot;alignWithFirstAttribute&quot;: true
},
// other esformatter options
&quot;options-JSON&quot;: {
  &quot;plugins&quot;: [
    &quot;esformatter-quotes&quot;
  ],
  &quot;quotes&quot;: {
    &quot;type&quot;: &quot;double&quot;
  }
},
&quot;alert-errors&quot;: true,
// path to nodejs
&quot;node-path&quot;: &quot;node&quot;,
// if true it will format the whole file even if you have a selection active
&quot;ignore-selection&quot;: false
}
</code></pre></li>
</ul>
<h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><p>打开 Preferences -&gt; Key Bindings - User，添加代码：<br><code>{&quot;keys&quot;:[&quot;ctrl+q&quot;],&quot;command&quot;:&quot;format_javascript&quot;}</code></p>
<h3 id="SublimeLinter-ESLint"><a href="#SublimeLinter-ESLint" class="headerlink" title="SublimeLinter-ESLint"></a>SublimeLinter-ESLint</h3><blockquote>
<p>ESLint 由 JavaScript 红宝书 作者 Nicholas C. Zakas 编写， 2013 年发布第一个版本。 NCZ 的初衷不是重复造一个轮子，而是在实际需求得不到 JSHint 团队响应 的情况下做出的选择：以可扩展、每条规则独立、不内置编码风格为理念编写一个 lint 工具</p>
</blockquote>
<h4 id="安装eslint"><a href="#安装eslint" class="headerlink" title="安装eslint"></a>安装eslint</h4><p>终端输入：</p>
<pre><code>npm install -g eslint@latest 
npm install -g babel-eslint@latest 
npm install -g eslint-plugin-react 
</code></pre><p>验证是否安装成功：<br><code>eslint -v</code></p>
<h4 id="ESLint配置rules"><a href="#ESLint配置rules" class="headerlink" title="ESLint配置rules"></a>ESLint配置rules</h4><p>在home目录(windows下即为：c:\usrs\用户名 )下新建 .eslintrc,添加代码：</p>
<pre><code>{
// I want to use babel-eslint for parsing!
&quot;parser&quot;: &quot;babel-eslint&quot;,
&quot;env&quot;: {
 // I write for browser
 &quot;browser&quot;: true,
 // in CommonJS
 &quot;node&quot;: true
},
// To give you an idea how to override rule options:
&quot;rules&quot;: {

    ////////////////
    // 可能的错误  //
    ////////////////
    // 禁止条件表达式中出现赋值操作符
    &quot;no-cond-assign&quot;: 2,
    // 禁用 console
    &quot;no-console&quot;: 0,
    // 禁止在条件中使用常量表达式
    // if (false) {
    //     doSomethingUnfinished();
    // } //cuowu
    &quot;no-constant-condition&quot;: 2,
    // 禁止在正则表达式中使用控制字符 ：new RegExp(&quot;\x1f&quot;)
    &quot;no-control-regex&quot;: 2,
    // 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号，
    // always-multiline：多行模式必须带逗号，单行模式不能带逗号
    //&quot;comma-dangle&quot;: [1, &quot;never&quot;],
    // 禁用 debugger
    &quot;no-debugger&quot;: 2,
    // 禁止 function 定义中出现重名参数
    &quot;no-dupe-args&quot;: 2,
    // 禁止对象字面量中出现重复的 key
    &quot;no-dupe-keys&quot;: 2,
    // 禁止重复的 case 标签
    &quot;no-duplicate-case&quot;: 2,
    // 禁止空语句块
    &quot;no-empty&quot;: 2,
    // 禁止在正则表达式中使用空字符集 (/^abc[]/)
    &quot;no-empty-character-class&quot;: 2,
    // 禁止对 catch 子句的参数重新赋值
    &quot;no-ex-assign&quot;: 2,
    // 禁止不必要的布尔转换
    &quot;no-extra-boolean-cast&quot;: 2,
    //  禁止不必要的括号 //(a * b) + c;//报错
    &quot;no-extra-parens&quot;: 0,
    // 禁止不必要的分号
    &quot;no-extra-semi&quot;: 2,
    // 禁止对 function 声明重新赋值
    &quot;no-func-assign&quot;: 2,
    //  禁止在嵌套的块中出现 function 或 var 声明
    &quot;no-inner-declarations&quot;: [2, &quot;functions&quot;],
    // 禁止 RegExp 构造函数中无效的正则表达式字符串
    &quot;no-invalid-regexp&quot;: 2,
    // 禁止在字符串和注释之外不规则的空白
    &quot;no-irregular-whitespace&quot;: 2,
    // 禁止在 in 表达式中出现否定的左操作数
    &quot;no-negated-in-lhs&quot;: 2,
    //   禁止把全局对象 (Math 和 JSON) 作为函数调用  错误：var math = Math();
    &quot;no-obj-calls&quot;: 2,
    // 禁止直接使用 Object.prototypes 的内置属性
    &quot;no-prototype-builtins&quot;:0,
    // 禁止正则表达式字面量中出现多个空格
    &quot;no-regex-spaces&quot;: 2,
    // 禁用稀疏数组
    &quot;no-sparse-arrays&quot;: 2,
    // 禁止出现令人困惑的多行表达式
    &quot;no-unexpected-multiline&quot;: 2,
    // 禁止在return、throw、continue 和 break语句之后出现不可达代码
    /*
        function foo() {
        return true;
        console.log(&quot;done&quot;);
        }//错误
    */
    &quot;no-unreachable&quot;: 2,
    // 要求使用 isNaN() 检查 NaN
    &quot;use-isnan&quot;: 2,
    // 强制使用有效的 JSDoc 注释
    &quot;valid-jsdoc&quot;: 1,
    // 强制 typeof 表达式与有效的字符串进行比较
    // typeof foo === &quot;undefimed&quot; 错误
    &quot;valid-typeof&quot;: 2,

    //////////////
    // 风格指南  //
    //////////////

     //&quot;quotes&quot;: [2, &quot;single&quot;],
     &quot;eol-last&quot;: [0],
     &quot;no-mixed-requires&quot;: [0],
     &quot;no-underscore-dangle&quot;: [0],

     //////////////
    // ES6.相关 //
    //////////////

    //&quot;arrow-spacing&quot;:[2,{ &quot;before&quot;: true, &quot;after&quot;: true }],
    // 强制在子类构造函数中用super()调用父类构造函数，TypeScrip的编译器也会提示
    &quot;constructor-super&quot;: 0,
    // 强制 generator 函数中 * 号周围使用一致的空格
    &quot;generator-star-spacing&quot;: [2, { &quot;before&quot;: true, &quot;after&quot;: true }],
    // 禁止修改类声明的变量
    &quot;no-class-assign&quot;:2,
    // 不允许箭头功能，在那里他们可以混淆的比较
    &quot;no-confusing-arrow&quot;:0,
    // 禁止修改 const 声明的变量
    &quot;no-const-assign&quot;:2,
    // 禁止类成员中出现重复的名称
    &quot;no-dupe-class-members&quot;:2,
    // 不允许复制模块的进口
    &quot;no-duplicate-imports&quot;:0,
    // 禁止 Symbol  的构造函数
    &quot;no-new-symbol&quot;:2,
    // 允许指定模块加载时的进口
    &quot;no-restricted-imports&quot;:0,
    // 禁止在构造函数中，在调用 super() 之前使用 this 或 super
    &quot;no-this-before-super&quot;: 2,
    // 禁止不必要的计算性能键对象的文字
    &quot;no-useless-computed-key&quot;:0,
    // 要求使用 let 或 const 而不是 var
    &quot;no-var&quot;: 0,
    // 要求或禁止对象字面量中方法和属性使用简写语法
    &quot;object-shorthand&quot;: 0,
    // 要求使用箭头函数作为回调
    &quot;prefer-arrow-callback&quot;:0,
    // 要求使用 const 声明那些声明后不再被修改的变量
    &quot;prefer-const&quot;: 0,
    // 要求在合适的地方使用 Reflect 方法
    &quot;prefer-reflect&quot;:0,
    // 要求使用扩展运算符而非 .apply()
    &quot;prefer-spread&quot;:0,
    // 要求使用模板字面量而非字符串连接
    &quot;prefer-template&quot;:0,
    // Suggest using the rest parameters instead of arguments
    &quot;prefer-rest-params&quot;:0,
    // 要求generator 函数内有 yield
    &quot;require-yield&quot;:0,
    // enforce spacing between rest and spread operators and their expressions
    &quot;rest-spread-spacing&quot;:0,
    // 强制模块内的 import 排序
    &quot;sort-imports&quot;:0,
    // 要求或禁止模板字符串中的嵌入表达式周围空格的使用
    &quot;template-curly-spacing&quot;:1,
    // 强制在 yield* 表达式中 * 周围使用空格
    &quot;yield-star-spacing&quot;:2

},
&quot;plugins&quot;:[
&quot;react&quot;
]
}
</code></pre><h4 id="Sublime配置"><a href="#Sublime配置" class="headerlink" title="Sublime配置"></a>Sublime配置</h4><p>安装插件<br>PC：Ctrl+shift+p<br>Mac：Cmd+shift+p<br>输入：<code>pci</code>，选择<code>Package Control:install package</code><br>输入<code>SublimeLinter</code>进行安装<br>输入<code>SublimeLinter-contrib-eslint</code>进行安装</p>
<h4 id="default-path设置"><a href="#default-path设置" class="headerlink" title="default path设置"></a>default path设置</h4><p>Preferences -&gt; Package Settings -&gt; Sublime Linter.sublime-settings<br>，添加代码：</p>
<pre><code>&quot;paths&quot;: { 
            &quot;osx&quot;: [ 
                &quot;/usr/local/lib&quot; 
            ] 
        }, 
        &quot;python_paths&quot;: { 
            &quot;osx&quot;: [ 
                &quot;/usr/local/lib&quot; 
            ] 
        }, 
</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.jianshu.com/p/ecf6c802fdc5" target="_blank" rel="noopener">Sublime Text3关于react的插件——react语法提示&amp;代码格式化</a></p>
<p><a href="https://segmentfault.com/a/1190000003698071" target="_blank" rel="noopener">Sublime Text 3 搭建 React.js 开发环境</a></p>
<p><a href="http://blog.guowenfh.com/2016/08/07/ESLint-Rules/" target="_blank" rel="noopener">详解 ESLint 规则，规范你的代码</a></p>
<p><a href="http://www.jianshu.com/p/b2985ba08ec9" target="_blank" rel="noopener">Sublime text3 jsx支持（eslint）</a></p>
</the>]]></content>
      
        <categories>
            
            <category> 环境搭建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Sublime </tag>
            
            <tag> React-Native </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python学习笔记]]></title>
      <url>https://longxuan.ren/2017/04/21/PythonLearn/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>教练，我要写爬虫！<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<blockquote>
<p>Python是动态语言，本身变量类型不固定 </p>
</blockquote>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="输入、输出："><a href="#输入、输出：" class="headerlink" title="输入、输出："></a>输入、输出：</h3><ul>
<li>input()函数：<code>name = input(“请输入...&quot;)</code> </li>
<li>print()函数：输出括号中的指定字符串，可以输出多个字符串，用逗号”,”隔开<br>格式化输出：%d:整数; %f:浮点数; %s:字符串; %x:十六进制数 </li>
</ul>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>通常全部用大写的变量名表示常量，只是习惯，不是规定，仍然可以改<br><code>PI = 3.14159265359</code> </p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul>
<li>list, 有序可变列表: l = [’Tom’, ‘Micheal’] </li>
<li>tuple, 有序不可变元组: t = (’Tom’, ‘Jhon’) </li>
</ul>
<h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><pre><code>def my_abs(x): 
if x &gt;= 0: 
        return x 
    else: 
        return -x 
</code></pre><ul>
<li><p>位置参数：<code>def power(x, n):</code> </p>
</li>
<li><p>默认参数：<code>def power(x, n=2):</code> </p>
</li>
<li><p>可变参数：<code>def calc(*numbers):</code>  接收的参数是tuple </p>
</li>
<li><p>关键字参数：<code>def person(name, age, **kw):</code>  接收的参数是dict  </p>
</li>
<li><p>命名关键字参数：<code>def person(name, age, *, city, job):</code>  限制关键字参数名字为city和job </p>
</li>
</ul>
<pre><code> print(name, age, city, job) 
&gt;&gt;&gt; person(‘Jack’, 24, city=‘Beijing’, job=‘Engineer’) 
</code></pre><blockquote>
<p>Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。 </p>
</blockquote>
<blockquote>
<p>默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！ </p>
</blockquote>
<blockquote>
<p>要注意定义可变参数和关键字参数的语法： </p>
</blockquote>
<blockquote>
<p>*args是可变参数，args接收的是一个tuple； </p>
</blockquote>
<blockquote>
<p>**kw是关键字参数，kw接收的是一个dict。 </p>
</blockquote>
<blockquote>
<p>以及调用函数时如何传入可变参数和关键字参数的语法： </p>
</blockquote>
<blockquote>
<p>可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过<em>args传入：func(</em>(1, 2, 3))； </p>
</blockquote>
<blockquote>
<p>关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过<strong>kw传入：func(</strong>{‘a’: 1, ‘b’: 2})。 </p>
</blockquote>
<blockquote>
<p>使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。 </p>
</blockquote>
<blockquote>
<p>命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。 </p>
</blockquote>
<blockquote>
<p>定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。 </p>
</blockquote>
<h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><pre><code>&gt;&gt;&gt;L[:10]        前10个数 
&gt;&gt;&gt;L[:10:2]     前10个数，每2个取一个 
</code></pre><h3 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h3><pre><code>&gt;&gt;&gt; list(range(1, 11)) 
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 
&gt;&gt;&gt; [x * x for x in range(1, 11)] 
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 
&gt;&gt;&gt; [m + n for m in ‘ABC’ for n in ‘XYZ’] 
[‘AX’, ‘AY’, ‘AZ’, ‘BX’, ‘BY’, ‘BZ’, ‘CX’, ‘CY’, ‘CZ’] 
</code></pre><h3 id="斐波那契数列：-列表生成式-函数"><a href="#斐波那契数列：-列表生成式-函数" class="headerlink" title="斐波那契数列：(列表生成式+函数)"></a>斐波那契数列：(列表生成式+函数)</h3><pre><code>def fib(max): 
    n, a, b = 0, 0, 1 
while n &lt; max: 
        print(b) 
        a, b = b, a + b 
        n = n + 1 
return &#39;done&#39; 
</code></pre><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回<br>map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。 </p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p>reduce()把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：<br><code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code></p>
<h4 id="结合起来写个字符串转数字的函数："><a href="#结合起来写个字符串转数字的函数：" class="headerlink" title="结合起来写个字符串转数字的函数："></a>结合起来写个字符串转数字的函数：</h4><pre><code>from functools import reduce 

def str2int(s): 
def fn(x, y): 
return x * 10 + y 
    def char2num(s): 
return {&#39;0&#39;: 0, &#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4, &#39;5&#39;: 5, &#39;6&#39;: 6, &#39;7&#39;: 7, &#39;8&#39;: 8, &#39;9&#39;: 9}[s] 
    return reduce(fn, map(char2num, s)) 
</code></pre><h3 id="fliter"><a href="#fliter" class="headerlink" title="fliter()"></a>fliter()</h3><p>filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素</p>
<h4 id="生成1000以内的素数"><a href="#生成1000以内的素数" class="headerlink" title="生成1000以内的素数"></a>生成1000以内的素数</h4><pre><code>def _odd_iter():  #生成一个从3开始的奇数序列
    n = 1
    while True:
        n = n + 2
        yield n

def _not_divisible(n):  ##定义一个筛选函数
    return lambda x: x % n &gt; 0

def primes():
    yield 2
    it = _odd_iter() #初始序列
    while True:
        n = next(it) #返回序列的第一个数
        yield n
        it = filter(_not_divisible(n), it)

for n in primes():
    if n &lt; 1000:
        print(n)
    else:
        break
</code></pre><h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a>sorted()</h3><p>内置排序算法，默认是升序</p>
<blockquote>
<p>key指定的函数将作用于list的每一个元素上</p>
</blockquote>
<pre><code>&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]
</code></pre><blockquote>
<p>要进行反向排序，不必改动key函数，可以传入第三个参数<code>reverse=True</code></p>
</blockquote>
<pre><code>&gt;&gt;&gt; sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key=str.lower, reverse=True)
[&#39;Zoo&#39;, &#39;Credit&#39;, &#39;bob&#39;, &#39;about&#39;]
</code></pre><h3 id="匿名函数lambda"><a href="#匿名函数lambda" class="headerlink" title="匿名函数lambda"></a>匿名函数lambda</h3><p><code>lambda x: x * x</code>等价于：</p>
<pre><code>def f(x):
    return x * x
</code></pre><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><blockquote>
<p>假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）</p>
</blockquote>
<h4 id="利用decorator打印出函数调用前和调用后的日志"><a href="#利用decorator打印出函数调用前和调用后的日志" class="headerlink" title="利用decorator打印出函数调用前和调用后的日志"></a>利用decorator打印出函数调用前和调用后的日志</h4><pre><code>import functools

def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print(&quot;%s begin call %s()&quot; % (text, func.__name__))
            ret = func(*args, **kw)
            print(&quot;%s end call %s()&quot; % (text, func.__name__))
            return ret
        return wrapper
    if isinstance(text, str):
        return decorator
    else:
        f = text
        text = &#39;&#39;
        return decorator(f)

@log#(&#39;excute&#39;)
def f():
    print(&quot;soso!&quot;)
f()
</code></pre><h3 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h3><blockquote>
<p>Python的functools模块提供了很多有用的功能，其中一个就是偏函数(Partial function).functools.partial就是帮助我们创建一个偏函数的.</p>
</blockquote>
<pre><code>&gt;&gt;&gt; import functools
&gt;&gt;&gt; int2 = functools.partial(int, base=2)
&gt;&gt;&gt; int2(&#39;1000000&#39;)
64
&gt;&gt;&gt; int2(&#39;1010101&#39;)
85
</code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><blockquote>
<p>在Python中，一个.py文件就称之为一个模块（Module）</p>
</blockquote>
<h3 id="模块标准模版"><a href="#模块标准模版" class="headerlink" title="模块标准模版"></a>模块标准模版</h3><pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#39; a test module &#39;

__author__ = &#39;Longxr&#39;
</code></pre><h3 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h3><blockquote>
<p>Python Imaging Library，这是Python下非常强大的处理图像的工具库</p>
</blockquote>
<h4 id="安装PIL库"><a href="#安装PIL库" class="headerlink" title="安装PIL库"></a>安装PIL库</h4><p><code>pip install Pillow</code></p>
<h4 id="生成缩略图"><a href="#生成缩略图" class="headerlink" title="生成缩略图"></a>生成缩略图</h4><pre><code>&gt;&gt;&gt; from PIL import Image
&gt;&gt;&gt; im = Image.open(&#39;test.png&#39;)
&gt;&gt;&gt; print(im.format, im.size, im.mode)
PNG (400, 300) RGB
&gt;&gt;&gt; im.thumbnail((200, 100))
&gt;&gt;&gt; im.save(&#39;thumb.jpg&#39;, &#39;JPEG&#39;)
</code></pre><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><blockquote>
<p>在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数</p>
</blockquote>
<pre><code>class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score

    def print_score(self):
        print(&#39;%s: %s&#39; % (self.name, self.score))
</code></pre><h3 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h3><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<strong>，在Python中，实例的变量名如果以</strong>开头，就变成了一个私有变量（private）</p>
<blockquote>
<p>在Python中，变量名类似<strong>xxx</strong>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<strong>name</strong>、<strong>score</strong>这样的变量名。<br>有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<strong>name是因为Python解释器对外把</strong>name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量</p>
</blockquote>
<h3 id="使用property"><a href="#使用property" class="headerlink" title="使用property"></a>使用property</h3><pre><code>class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError(&#39;score must be an integer!&#39;)
        if value &lt; 0 or value &gt; 100:
            raise ValueError(&#39;score must between 0 ~ 100!&#39;)
        self._score = value
</code></pre><p>不能直接访问属性，会调用对应的getter()、setter()方法</p>
<pre><code>&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)
&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()
60
&gt;&gt;&gt; s.score = 9999
Traceback (most recent call last):
  ...
ValueError: score must between 0 ~ 100!
</code></pre><h2 id="错误、调试、测试"><a href="#错误、调试、测试" class="headerlink" title="错误、调试、测试"></a>错误、调试、测试</h2><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>try…except…finally…</p>
<blockquote>
<p>当我们认为某些代码可能会出错时，就可以用try来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即except语句块，执行完except后，如果有finally语句块，则执行finally语句块，至此，执行完毕</p>
</blockquote>
<pre><code>try:
    print(&#39;try...&#39;)
    r = 10 / 0
    print(&#39;result:&#39;, r)
except ZeroDivisionError as e:
    print(&#39;except:&#39;, e)
finally:
    print(&#39;finally...&#39;)
print(&#39;END&#39;)
</code></pre><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><h4 id="print"><a href="#print" class="headerlink" title="print()"></a>print()</h4><p>打印出变量的信息</p>
<h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p>凡是用print()来辅助查看的地方，都可以用断言（assert）来替代。在启动Python解释器时可以用-o参数来关闭assert，<code>assert</code>语句会被当成<code>pass</code>看</p>
<h4 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h4><p>把print()替换为logging是第3种方式，和assert比，logging不会抛出错误，而且可以输出到文件</p>
<h4 id="单步调试"><a href="#单步调试" class="headerlink" title="单步调试"></a>单步调试</h4><ul>
<li>qdb</li>
<li>IDE，比如<a href="http://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">PyCharm</a></li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li>单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作</li>
<li>Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试。<br>doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候，可以用…表示中间一大段烦人的输出</li>
</ul>
</the>]]></content>
      
        <categories>
            
            <category> 语法学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[AE蛋疼插件问题记录]]></title>
      <url>https://longxuan.ren/2017/04/20/AE-Plugns-Notes/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>重装插件总是一件蛋疼的事情，下次做个快照好了…<a id="more"></a></excerpt></p>
<p><the rest of contents | 余下全文></the></p>
<h2 id="AE插件的安装路径"><a href="#AE插件的安装路径" class="headerlink" title="AE插件的安装路径"></a>AE插件的安装路径</h2><blockquote>
<p>提示什么特效副本副本重复的时候三个路径找找删掉不要的版本</p>
</blockquote>
<ul>
<li>免安装插件：X:\Adobe\Adobe After Effects CC\Support Files\Plug-ins(有时候在前一个目录)</li>
<li>需安装插件：C:\Program Files\Adobe\Common\Plug-ins\7.0\MediaCore</li>
<li>C:\Program Files\Adobe\Adobe After Effects CC\Support Files\Plug-ins</li>
</ul>
<h2 id="问题：缺少XXX-dll文件"><a href="#问题：缺少XXX-dll文件" class="headerlink" title="问题：缺少XXX.dll文件"></a>问题：缺少XXX.dll文件</h2><p>解决：下载<a href="http://download.csdn.net/detail/vbcom/8651973" target="_blank" rel="noopener">DirectX修复工具</a>修复下</p>
<h2 id="问题：安装了Trapcode-Suite插件套装后，3D-stroke预设点了什么反应都没有"><a href="#问题：安装了Trapcode-Suite插件套装后，3D-stroke预设点了什么反应都没有" class="headerlink" title="问题：安装了Trapcode Suite插件套装后，3D stroke预设点了什么反应都没有"></a>问题：安装了Trapcode Suite插件套装后，3D stroke预设点了什么反应都没有</h2><p>解决：找到3D stroke的安装路径D:\Adobe\Adobe After Effects CC\Support Files\Plug-ins\Trapecode Suite\Trapcode Suite 64bit，在当前目录新建一个Trapcode文件夹，把SVG文件夹放到里面，预设就能用了<em>(:з」∠)</em></p>
<h2 id="Twitch插件问题"><a href="#Twitch插件问题" class="headerlink" title="Twitch插件问题"></a>Twitch插件问题</h2><p>把插件放到D:\Adobe\Adobe After Effects CC\Support Files目录下(不要放到Plug-ins下)，预设扔到Presets里即可</p>
<h2 id="E3D插件还有模型安装"><a href="#E3D插件还有模型安装" class="headerlink" title="E3D插件还有模型安装"></a>E3D插件还有模型安装</h2><p>安装的第一个路径选择是插件路径，第二个路径是模型路径。插件路径一般是：D:\Adobe\Adobe After Effects CC\Support Files\Plug-ins\，模型路径随意<br>E3D的2.2.0是2.0.7的升级版，首先要先安装2.0.0才行。如果装过1.6.X的安装前要将之前的版本软件本体以及注册信息(在C:\ProgramData\VideoCopilot)全部删掉</p>
<p>##E3D插件 AE报错：could not be loaded (126)：无法加载增效工具（48：46）<br>解决：显卡问题，更新显卡驱动</p>
<h2 id="中英文切换"><a href="#中英文切换" class="headerlink" title="中英文切换"></a>中英文切换</h2><p>修改中文配置文件名：<br>CC2015:    Adobe After Effects CC 2015\Support Files\zdictionaries\after_effects_zh-Hans.dat<br>CC2017:    Adobe After Effects CC 2017\Support Files\zdictionaries\after_effects_zh_CN.dat</p>
<h2 id="中文版表达式切换回英文"><a href="#中文版表达式切换回英文" class="headerlink" title="中文版表达式切换回英文"></a>中文版表达式切换回英文</h2><p>修改zdictionaries中的aftre_effects_zh_Hans.dat<br>“$$$/AE/Effect/Name/CheckboxControl=Checkbox Control”<br>“$$$/AE/Effect/Name/ColorControl=Color Control”<br>“$$$/AE/Effect/Name/Fill=Fill”<br>“$$$/AE/Fill/LStr/0002=Color”<br>“$$$/AE/Motion_Tile/LStr/0001=Tile Center”<br>“$$$/AE/Slider_Control/LStr/0001=Slider”<br>“$$$/AE/Slider_Control/LStr/0002=Angle”<br>“$$$/AE/Slider_Control/LStr/0003=Checkbox”<br>“$$$/AE/Slider_Control/LStr/0004=Color”<br>“$$$/AE/Slider_Control/LStr/0005=Point”<br>“$$$/AE/Slider_Control/LStr/0006=Layer”</p>
]]></content>
      
        <categories>
            
            <category> 影视后期 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac操作小技巧]]></title>
      <url>https://longxuan.ren/2017/04/13/Mac-Skills/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>常用快捷键<br>文件用Sublime打开<br>Finder与终端交互<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>

<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><blockquote>
<p>有些事情自带快捷键就能做到，不用去配置服务、终端敲代码、另外下软件什么的</p>
</blockquote>
<h3 id="快捷键图标"><a href="#快捷键图标" class="headerlink" title="快捷键图标"></a>快捷键图标</h3><p>⌘——Command ()<br>⌃ ——Control<br>⌥——Option (Alt)<br>⇧——Shift<br>⇪——Caps Lock</p>
<h4 id="终端清屏：command＋K"><a href="#终端清屏：command＋K" class="headerlink" title="终端清屏：command＋K"></a>终端清屏：command＋K</h4><h4 id="文件预览：空格"><a href="#文件预览：空格" class="headerlink" title="文件预览：空格"></a>文件预览：空格</h4><h4 id="中文输入法中英文切换：CapsLock"><a href="#中文输入法中英文切换：CapsLock" class="headerlink" title="中文输入法中英文切换：CapsLock"></a>中文输入法中英文切换：CapsLock</h4><h4 id="拷贝文件路径：Command-Option-C"><a href="#拷贝文件路径：Command-Option-C" class="headerlink" title="拷贝文件路径：Command + Option + C"></a>拷贝文件路径：Command + Option + C</h4><h4 id="显示-隐藏文件：Command-Shift"><a href="#显示-隐藏文件：Command-Shift" class="headerlink" title="显示/隐藏文件：Command + Shift + ."></a>显示/隐藏文件：Command + Shift + .</h4><h4 id="全屏截图：Command-Shift-3"><a href="#全屏截图：Command-Shift-3" class="headerlink" title="全屏截图：Command+Shift+3"></a>全屏截图：Command+Shift+3</h4><h4 id="指定区域截图：Command-Shift-4"><a href="#指定区域截图：Command-Shift-4" class="headerlink" title="指定区域截图：Command+Shift+4"></a>指定区域截图：Command+Shift+4</h4><h4 id="指定窗口截图：Command-Shift-4，空格-鼠标单击指定窗口"><a href="#指定窗口截图：Command-Shift-4，空格-鼠标单击指定窗口" class="headerlink" title="指定窗口截图：Command+Shift+4，空格+鼠标单击指定窗口"></a>指定窗口截图：Command+Shift+4，空格+鼠标单击指定窗口</h4><h4 id="剪切移动文件：Command-C-拷贝文件，Command-Option-V-剪切文件"><a href="#剪切移动文件：Command-C-拷贝文件，Command-Option-V-剪切文件" class="headerlink" title="剪切移动文件：Command+C 拷贝文件，Command+Option+V 剪切文件"></a>剪切移动文件：Command+C 拷贝文件，Command+Option+V 剪切文件</h4><h2 id="文件用Sublime打开"><a href="#文件用Sublime打开" class="headerlink" title="文件用Sublime打开"></a>文件用Sublime打开</h2><blockquote>
<p>经常面对各种格式的文本文件，分别设置打开方式太麻烦，统一用Sublime打开，添加到右键菜单功能</p>
</blockquote>
<ol>
<li><p>打开 <code>Automator</code> 这个程序（Finder应用程序中找或者Spotlight直接搜索），在弹出的菜单中选择 <strong>服务</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Mac-Skills_01.png" alt="打开.png"></p>
</li>
<li><p>在左上角的搜索框搜索 Finder 把打开Finder项目拖动到右边：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Mac-Skills_02.png" alt="拖动.png"></p>
</li>
<li><p>右上角服务设置如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Mac-Skills_03.png" alt="服务设置.png"></p>
</li>
</ol>
<p>4.效果图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Mac-Skills_04.png" alt="右键菜单.png"></p>
<p>  如果设置的服务出现在二级菜单，可以在<code>系统偏好设置</code>-&gt;<code>键盘</code>-&gt;<code>快捷键</code>-&gt;<code>服务</code>中去掉不需要的选项</p>
<h2 id="Finder与终端交互"><a href="#Finder与终端交互" class="headerlink" title="Finder与终端交互"></a>Finder与终端交互</h2><h3 id="终端到Finder"><a href="#终端到Finder" class="headerlink" title="终端到Finder"></a>终端到Finder</h3><p>  终端目录下输入：<code>open .</code></p>
<h3 id="Finder到终端"><a href="#Finder到终端" class="headerlink" title="Finder到终端"></a>Finder到终端</h3><blockquote>
<p>默认的系统偏好设置中的服务中有一个在文件夹当前位置打开终端的选项，但是因为换了<a href="https://www.iterm2.com" target="_blank" rel="noopener">iTerm2</a>，所以并不适用</p>
</blockquote>
<p>  使用软件：<a href="http://zipzapmac.com/Go2Shell" target="_blank" rel="noopener">Go2shell</a><br>  下载后安装，选择你使用的终端，点下  <code>install Go2Shell from Finder</code> 即可:</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Mac-Skills_05.png" alt="安装.png"></p>
<p>  <img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Mac-Skills_06.png" alt="gotoshell.png"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.jianshu.com/p/e2f897933c56" target="_blank" rel="noopener">把Sublime添加到Mac右键菜单</a></p>
<p><a href="http://www.rxna.cn/post/wiki/finderyu-iterm2hu-xiang-da-kai-de-fang-fa" target="_blank" rel="noopener">Finder与iTerm2互相打开的方法</a></p>
</the>]]></content>
      
        <categories>
            
            <category> 操作技巧 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mac </tag>
            
            <tag> 快捷键 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo博客搭建中的坑]]></title>
      <url>https://longxuan.ren/2017/04/11/Hexo-Notes/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>记录坑爹瞬间<a id="more"></a></excerpt></p>
<p><the rest of contents | 余下全文></the></p>
<h3 id="问题：Travis-Ci自动构建图标build-status-unknown"><a href="#问题：Travis-Ci自动构建图标build-status-unknown" class="headerlink" title="问题：Travis-Ci自动构建图标build status unknown"></a>问题：Travis-Ci自动构建图标build status unknown</h3><p>解决：原因是构建的分支不是master分支，默认显示缺省分支master的状态，修改图标链接<code>svg?branch=master</code>为<code>svg?branch=blog</code></p>
<h3 id="问题：各种在设置-config-yml后出现的问题"><a href="#问题：各种在设置-config-yml后出现的问题" class="headerlink" title="问题：各种在设置_config.yml后出现的问题"></a>问题：各种在设置_config.yml后出现的问题</h3><p>解决：检查冒号后面的空格！！！检查冒号后面的空格！！！检查冒号后面的空格！！！</p>
<h3 id="问题：自定义域名在blog根目录添加CNAME后，使用hexo-d-g不上传CNAME"><a href="#问题：自定义域名在blog根目录添加CNAME后，使用hexo-d-g不上传CNAME" class="headerlink" title="问题：自定义域名在blog根目录添加CNAME后，使用hexo d -g不上传CNAME"></a>问题：自定义域名在blog根目录添加CNAME后，使用hexo d -g不上传CNAME</h3><p>解决：将需要上传的文件放到blog/source</p>
<h3 id="问题：执行-hexo-deploy-后-出现-error-deployer-not-found-github"><a href="#问题：执行-hexo-deploy-后-出现-error-deployer-not-found-github" class="headerlink" title="问题：执行 hexo deploy 后,出现 error deployer not found:github"></a>问题：执行 hexo deploy 后,出现 error deployer not found:github</h3><p>解决：执行npm install hexo-deployer-git —save，再部署</p>
<h3 id="问题：YAMLException-bad-indentation-of-a-mapping-entry"><a href="#问题：YAMLException-bad-indentation-of-a-mapping-entry" class="headerlink" title="问题：YAMLException: bad indentation of a mapping entry"></a>问题：YAMLException: bad indentation of a mapping entry</h3><p>解决：YAML的语法错误，仔细检查冒号后面 要有一个空格</p>
<h3 id="问题：部署时候用git连接github提示没有权限被拒绝Permission-denied-publickey"><a href="#问题：部署时候用git连接github提示没有权限被拒绝Permission-denied-publickey" class="headerlink" title="问题：部署时候用git连接github提示没有权限被拒绝Permission denied (publickey)."></a>问题：部署时候用git连接github提示没有权限被拒绝Permission denied (publickey).</h3><p>$ ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a><br>Hi XXX! You’ve successfully authenticated, but GitHub does not provide shell access.<br>解决：重新生成一个SSH key，加到Github上</p>
]]></content>
      
        <categories>
            
            <category> 问题处理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> blog </tag>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo个人博客搭建]]></title>
      <url>https://longxuan.ren/2017/04/07/Hexo-Blog-Construction/</url>
      <content type="html"><![CDATA[<p><excerpt in index | 摘要><br>欢迎大家访问我的<a href="https://longxuan.ren">博客</a>，虽然一般都是简书和博客同步更新啦~~懒得搞图床，把简书当图床还挺好用的233333<a id="more"></a></excerpt></p>
<the rest of contents | 余下全文>


<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>准备放博客的空间，我是选择的github的github pages，免费，有逼格</p>
</li>
<li><p>配置Hexo环境，后期可以通过配置Travis CI自动化部署</p>
</li>
<li><p>绑定自己的域名，支持https，虽然github.io也挺好的，没事就喜欢折腾</p>
</li>
</ol>
<h2 id="github-pages设置"><a href="#github-pages设置" class="headerlink" title="github pages设置"></a>github pages设置</h2><p>首先得有一个<a href="https://github.com" target="_blank" rel="noopener">github账号</a>，账号申请就略过了。</p>
<p>在账号下新建一个仓库，仓库命名为yourname.github.io。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Hexo-Blog-Construction_01.png" alt="github新建仓库.png"></p>
<blockquote>
<p>设置好pages，等会儿Hexo生成博客push到仓库后，浏览器就可以输入yourname.github.io访问了。</p>
</blockquote>
<h2 id="配置Hexo"><a href="#配置Hexo" class="headerlink" title="配置Hexo"></a>配置Hexo</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>这里是<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方中文教程</a>，照着来就好了～前提条件是要安装git和node.js，用github的话git肯定是装好了，教程都有不赘述了。</p>
<h3 id="建博客"><a href="#建博客" class="headerlink" title="建博客"></a>建博客</h3><p>安装好Hexo后，终端先到你准备放博客源文件的目录下：</p>
<pre><code>hexo blogName

cd blogName

npm install

hexo s
</code></pre><p>现在已经可以在本地预览生成的博客了，在浏览器输入localhost:4000就能看见默认的博客了。</p>
<h3 id="关联github仓库"><a href="#关联github仓库" class="headerlink" title="关联github仓库"></a>关联github仓库</h3><p>为了能让其他人也能看见你的博客，就要把博客的源文件提交到你的github仓库，打开blog目录下的配置文件_config.yml，修改最底下的几行：</p>
<pre><code>deploy:

type: git

repository: git@github.com:yourname/yourname.github.io.git

branch: master
</code></pre><p>yml语法很蛋疼，冒号后面一定要有个空格，之前没打空格被坑过好几次</p>
<h3 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h3><pre><code>hexo clean

hexo g

hexo d
</code></pre><h3 id="Hexo主题"><a href="#Hexo主题" class="headerlink" title="Hexo主题"></a>Hexo主题</h3><p>Hexo修改主题相当方便，可以下载别人的主题，自己在主题的基础上再稍作修改，这里推荐两个主题</p>
<ul>
<li><p><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">Next</a>，大名鼎鼎的主题，看Star就知道了，主题还自带3种风格，简洁优雅</p>
</li>
<li><p><a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="noopener">yelee</a>，我现在用的主题，喜欢动画效果～</p>
</li>
</ul>
<h2 id="自定义域名-2018-08-15更新"><a href="#自定义域名-2018-08-15更新" class="headerlink" title="自定义域名 (2018-08-15更新)"></a>自定义域名 (2018-08-15更新)</h2><blockquote>
<p>折腾完前面的步骤，还想继续折腾域名的话就看看吧。</p>
</blockquote>
<h3 id="购买"><a href="#购买" class="headerlink" title="购买"></a>购买</h3><p>首先要先注册一个<a href="https://www.aliyun.com" target="_blank" rel="noopener">阿里云账号</a>，然后就可以去<a href="https://wanwang.aliyun.com" target="_blank" rel="noopener">买域名</a>了。域名的实名认证啥的按照说明自己做就好了。</p>
<h3 id="DNS修改"><a href="#DNS修改" class="headerlink" title="DNS修改"></a>DNS修改</h3><p>在阿里云的控制台，找到域名-&gt;管理，打开域名控制台，DNS地址修改为dns9.hichina.com和dns10.hichina.com (默认就是这俩)</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Hexo-Blog-Construction_02.png" alt="DNS修改"></p>
<p>然后在本地的博客目录里的source目录下添加一个名字为CNAME的文件，没有后缀。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Hexo-Blog-Construction_03.png" alt="添加CNAME.png"></p>
<p>在CNAME中添加一行你自己的域名：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Hexo-Blog-Construction_04.png" alt="CNAME文件.png"></p>
<p>之前看教程说CNAME是放在博客根目录，但是hexo d -g发布的时候不会提交根目录文件…于是就放到source文件夹下了</p>
<p>在控制台左侧选择域名解析，添加解析记录：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Hexo-Blog-Construction_05.png" alt="域名解析"></p>
<p>上面的A记录是github的服务器地址，github 会根据每个项目下的 CNAME 生成缓存，从而自动跳转。</p>
<p>最后就是等待ing，我设置的时候等了一个小时就可以访问了。</p>
<h3 id="支持https"><a href="#支持https" class="headerlink" title="支持https"></a>支持https</h3><p>github在2018年5月就支持给自定义域名添加https了，虽然我8月才发现……在github的博客项目页面点击Settings，找到下面的GitHub Pages：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Hexo-Blog-Construction_06.png" alt="https访问支持"></p>
<p>最底下的选项勾上就可以支持https了。如果该选项是灰色的，提示你的域名不支持的话，可以把再把项目里的CNAME文件删掉提交一次，Custom domain那里删掉然后Save，等几分钟后再重新提交一次CNAME文件。这时候可能提示你暂时还不支持，申请证书在24小时内完成，不过我就等了1个小时就好了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Longxr/PicStored/blog/Hexo-Blog-Construction_07.png" alt="支持https"></p>
</the>]]></content>
      
        <categories>
            
            <category> 环境搭建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> blog </tag>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
